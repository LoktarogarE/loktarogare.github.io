<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LRU &amp; LFU</title>
    <link href="/2024/07/29/LRU%20&amp;%20LFU/"/>
    <url>/2024/07/29/LRU%20&amp;%20LFU/</url>
    
    <content type="html"><![CDATA[<h2 id="LRU-基础"><a href="#LRU-基础" class="headerlink" title="LRU 基础"></a>LRU 基础</h2><p>内存的数据是有限的，因此不可能无限制地添加数据。假定我们设置缓存能够使用的内存大小为 N，那么在某一个时间点，添加了某一条缓存记录之后，占用内存超过了 N，这个时候就需要从缓存中移除一条或多条数据了。那移除谁呢？我们肯定希望尽可能移除“没用”的数据，那如何判定数据“有用”还是“没用”呢？</p><h2 id="FIFO-LFU-LRU-算法简介"><a href="#FIFO-LFU-LRU-算法简介" class="headerlink" title="FIFO&#x2F;LFU&#x2F;LRU 算法简介"></a>FIFO&#x2F;LFU&#x2F;LRU 算法简介</h2><h3 id="FIFO-First-In-First-Out"><a href="#FIFO-First-In-First-Out" class="headerlink" title="FIFO(First In First Out)"></a>FIFO(First In First Out)</h3><p>先进先出，也就是淘汰缓存中最老(最早添加)的记录。FIFO 认为，最早添加的记录，其不再被使用的可能性比刚添加的可能性大。这种算法的实现也非常简单，创建一个队列，新增记录添加到队尾，每次内存不够时，淘汰队首。但是很多场景下，部分记录虽然是最早添加但也最常被访问，而不得不因为呆的时间太长而被淘汰。这类数据会被频繁地添加进缓存，又被淘汰出去，导致缓存命中率降低。</p><h3 id="LFU-Least-Frequently-Used"><a href="#LFU-Least-Frequently-Used" class="headerlink" title="LFU(Least Frequently Used)"></a>LFU(Least Frequently Used)</h3><p>最少使用，也就是淘汰缓存中访问频率最低的记录。LFU 认为，如果数据过去被访问多次，那么将来被访问的频率也更高。LFU 的实现需要维护一个按照访问次数排序的队列，每次访问，访问次数加1，队列重新排序，淘汰时选择访问次数最少的即可。LFU 算法的命中率是比较高的，但缺点也非常明显，维护每个记录的访问次数，对内存的消耗是很高的；另外，如果数据的访问模式发生变化，LFU 需要较长的时间去适应，也就是说 LFU 算法受历史数据的影响比较大。例如某个数据历史上访问次数奇高，但在某个时间点之后几乎不再被访问，但因为历史访问次数过高，而迟迟不能被淘汰。</p><h3 id="LRU-Least-Recently-Used"><a href="#LRU-Least-Recently-Used" class="headerlink" title="LRU(Least Recently Used)"></a>LRU(Least Recently Used)</h3><p>最近最少使用，相对于仅考虑时间因素的 FIFO 和仅考虑访问频率的 LFU，LRU 算法可以认为是相对平衡的一种淘汰算法。<strong>LRU 认为，如果数据最近被访问过，那么将来被访问的概率也会更高</strong>。LRU 算法的实现非常简单，维护一个队列，如果某条记录被访问了，则移动到队尾，那么队首则是最近最少访问的数据，淘汰该条记录即可。</p><img src="/source_img/LRU & LFU/f9b38e437926afcdb1fc527bc475b6fc.jpeg" alt="f9b38e437926afcdb1fc527bc475b6fc" style="zoom:50%;" /><p>实现一个 LRU 需要用到一个哈希表和一个双向链表。</p><ul><li>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</li><li>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。 </li><li>LRU 要点：删除都在表尾，添加都在表头，维护 dummy_head 和 dummy_tail ，<ul><li>成员变量： cache, size, capacity; 头尾指针｜如果用list，自带head和tail</li><li>方法：<ul><li><ol><li>创建节点(到头); 删除一个节点 </li><li>访问一个节点(原来位置的node 删除，把node移动到头) ; 删除尾部 (optional)</li></ol></li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DLinkedNode</span> &#123;<br>    <span class="hljs-type">int</span> key, value;<br>    DLinkedNode* prev;<br>    DLinkedNode* next;<br>    <span class="hljs-built_in">DLinkedNode</span>(): <span class="hljs-built_in">key</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">DLinkedNode</span>(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _value): <span class="hljs-built_in">key</span>(_key), <span class="hljs-built_in">value</span>(_value), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, DLinkedNode*&gt; cache;<br>    DLinkedNode* head;<br>    DLinkedNode* tail;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">int</span> capacity;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> _capacity): <span class="hljs-built_in">capacity</span>(_capacity), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 使用伪头部和伪尾部节点</span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>();<br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!cache.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span><br>        DLinkedNode* node = cache[key];<br>        <span class="hljs-built_in">moveToHead</span>(node);<br>        <span class="hljs-keyword">return</span> node-&gt;value;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!cache.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-comment">// 如果 key 不存在，创建一个新的节点</span><br>            DLinkedNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>(key, value);<br>            <span class="hljs-comment">// 添加进哈希表</span><br>            cache[key] = node;<br>            <span class="hljs-comment">// 添加至双向链表的头部</span><br>            <span class="hljs-built_in">addToHead</span>(node);<br>            ++size;<br>            <span class="hljs-keyword">if</span> (size &gt; capacity) &#123;<br>                <span class="hljs-comment">// 如果超出容量，删除双向链表的尾部节点</span><br>                DLinkedNode* removed = <span class="hljs-built_in">removeTail</span>();<br>                <span class="hljs-comment">// 删除哈希表中对应的项</span><br>                cache.<span class="hljs-built_in">erase</span>(removed-&gt;key);<br>                <span class="hljs-comment">// 防止内存泄漏</span><br>                <span class="hljs-keyword">delete</span> removed;<br>                --size;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span><br>            DLinkedNode* node = cache[key];<br>            node-&gt;value = value;<br>            <span class="hljs-built_in">moveToHead</span>(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addToHead</span><span class="hljs-params">(DLinkedNode* node)</span> </span>&#123;<br>        node-&gt;prev = head;<br>        node-&gt;next = head-&gt;next;<br>        head-&gt;next-&gt;prev = node;<br>        head-&gt;next = node;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(DLinkedNode* node)</span> </span>&#123;<br>        node-&gt;prev-&gt;next = node-&gt;next;<br>        node-&gt;next-&gt;prev = node-&gt;prev;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(DLinkedNode* node)</span> </span>&#123;<br>        <span class="hljs-built_in">removeNode</span>(node);<br>        <span class="hljs-built_in">addToHead</span>(node);<br>    &#125;<br><br>    <span class="hljs-function">DLinkedNode* <span class="hljs-title">removeTail</span><span class="hljs-params">()</span> </span>&#123;<br>        DLinkedNode* node = tail-&gt;prev;<br>        <span class="hljs-built_in">removeNode</span>(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用 <code>std::list</code> 实现LRU，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> capacity;<br>    unordered_map&lt;<span class="hljs-type">int</span>, pair&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;::iterator&gt;&gt; cache; <span class="hljs-comment">// 存储键值对和对应在队列中的迭代器</span><br>    list&lt;<span class="hljs-type">int</span>&gt; recent; <span class="hljs-comment">// 存储最近使用的键，队首为最近使用的键，队尾为最久未使用的键</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;capacity = capacity;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cache.<span class="hljs-built_in">find</span>(key) != cache.<span class="hljs-built_in">end</span>()) &#123; <span class="hljs-comment">// 如果缓存中存在该键</span><br>            <span class="hljs-built_in">updateRecent</span>(key); <span class="hljs-comment">// 更新最近使用情况</span><br>            <span class="hljs-keyword">return</span> cache[key].first; <span class="hljs-comment">// 返回键对应的值</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 如果缓存中不存在该键，返回-1</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cache.<span class="hljs-built_in">find</span>(key) != cache.<span class="hljs-built_in">end</span>()) &#123; <span class="hljs-comment">// 如果缓存中已经存在该键</span><br>            <span class="hljs-built_in">updateRecent</span>(key); <span class="hljs-comment">// 更新最近使用情况</span><br>            cache[key].first = value; <span class="hljs-comment">// 更新值</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (cache.<span class="hljs-built_in">size</span>() &gt;= capacity) &#123; <span class="hljs-comment">// 如果缓存已满</span><br>                <span class="hljs-built_in">evict</span>(); <span class="hljs-comment">// 淘汰最久未使用的键</span><br>            &#125;<br>            recent.<span class="hljs-built_in">push_front</span>(key); <span class="hljs-comment">// 将新键加入队首</span><br>            cache[key] = &#123;value, recent.<span class="hljs-built_in">begin</span>()&#125;; <span class="hljs-comment">// 将键值对存入哈希表</span><br>        &#125;<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateRecent</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        recent.<span class="hljs-built_in">erase</span>(cache[key].second); <span class="hljs-comment">// 从队列中删除原位置</span><br>        recent.<span class="hljs-built_in">push_front</span>(key); <span class="hljs-comment">// 将该键移到队首</span><br>        cache[key].second = recent.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// 更新在队列中的位置迭代器</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">evict</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> evictKey = recent.<span class="hljs-built_in">back</span>(); <span class="hljs-comment">// 获取最久未使用的键</span><br>        cache.<span class="hljs-built_in">erase</span>(evictKey); <span class="hljs-comment">// 从哈希表中删除该键</span><br>        recent.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 从队列尾部淘汰该键</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">LRUCache <span class="hljs-title">cache</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">// 创建容量为2的LRU缓存</span><br>    <br>    cache.<span class="hljs-built_in">put</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存中：&#123;1=1&#125;</span><br>    cache.<span class="hljs-built_in">put</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存中：&#123;1=1, 2=2&#125;</span><br>    cout &lt;&lt; cache.<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>) &lt;&lt; endl;    <span class="hljs-comment">// 返回 1</span><br>    cache.<span class="hljs-built_in">put</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 缓存中：&#123;1=1, 3=3&#125;</span><br>    cout &lt;&lt; cache.<span class="hljs-built_in">get</span>(<span class="hljs-number">2</span>) &lt;&lt; endl;    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>    cache.<span class="hljs-built_in">put</span>(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 缓存中：&#123;3=3, 4=4&#125;，移除键 1</span><br>    cout &lt;&lt; cache.<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>) &lt;&lt; endl;    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>    cout &lt;&lt; cache.<span class="hljs-built_in">get</span>(<span class="hljs-number">3</span>) &lt;&lt; endl;    <span class="hljs-comment">// 返回 3</span><br>    cout &lt;&lt; cache.<span class="hljs-built_in">get</span>(<span class="hljs-number">4</span>) &lt;&lt; endl;    <span class="hljs-comment">// 返回 4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>LRU 实现注意：</p><ul><li>不要忘记及时更新map</li><li>双向链表把节点添加到head需要4步</li><li>put时元素若存在，也需要更新它的value</li><li>我的写法：两种成员方法， add2head（非新节点要把老位置的删掉） 和 evict(删除节点） 就够了</li></ul><h2 id="深入理解-LRU"><a href="#深入理解-LRU" class="headerlink" title="深入理解 LRU"></a>深入理解 LRU</h2><h3 id="LRU-K-2Q"><a href="#LRU-K-2Q" class="headerlink" title="LRU-K &amp; 2Q"></a>LRU-K &amp; 2Q</h3><p>LRU算法实现虽然简单，并且在大量频繁访问热点页面时十分高效，但同样也有一个缺点，就是如果该热点页面在偶然一个时间节点被其他大量仅访问了一次的页面所取代，那自然造成了浪费。</p><p>LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。</p><p>LRU-K的主要目的是为了解决LRU算法<code>缓存污染</code>的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使</p><p>用过K次”。</p><img src="/source_img/LRU & LFU/x76gwup6dn.png" alt="x76gwup6dn" style="zoom:80%;" /><p>LRU 需要维护两个队列：<code>历史队列</code>和<code>缓存队列</code>。</p><ul><li><p><code>历史队列</code>保存着每次访问的页面，当页面访问次数达到了k次，该页面出栈，并保存至<code>缓存队列</code>；若尚未达到k次则继续保存，直至<code>历史队列</code>也满了，那就根据一定的缓存策略(FIFO、LRU、LFU)进行淘汰。</p></li><li><p><code>缓存队列</code>则是保存已经访问k次的页面，当该队列满了之后，则淘汰最后一个页面，也就是<code>第k次访问距离现在最久</code>的那个页面。</p></li></ul><p>简单来说，如果历史队列中的元素被访问了 K 次，它会离开历史队列前往缓存队列。缓存队列的元素就没那么容易被随便淘汰，抗干扰能力就强一些。</p><p>LRU workflow</p><img src="https://image-static.segmentfault.com/274/214/274214196-5eb26535ac418_fix732" style="zoom:50%;" /><ul><li><p>LRU-K的历史队列和缓存队列在满时的更新策略可以自由选择</p></li><li><p>LFU 可以理解为 k &#x3D; ∞ 的 LRU-K 算法。</p></li><li><p><code>2Q</code> 算法是一种具体的 LRU-2 算法，其<code>历史队列</code>采用FIFO，<code>缓存队列</code>采用LRU-1。</p></li><li><p>LRU-K的性能：K &#x3D; 2可能是最常用也最好用的。</p></li></ul><h3 id="redis-的-LRU-实现"><a href="#redis-的-LRU-实现" class="headerlink" title="redis 的 LRU 实现"></a>redis 的 LRU 实现</h3><p>由于 LRU 算法需要用链表管理所有的数据，会造成大量额外的空间消耗。</p><p>除此之外，大量的节点被访问就会带来频繁的链表节点移动操作，从而降低了 Redis 性能。</p><p>所以 Redis 对该算法做了简化，Redis LRU 算法并不是真正的 LRU，Redis 通过<strong>对少量的 key 采样</strong>，并淘汰采样的数据中最久没被访问过的 key。</p><p>这就意味着 Redis 无法淘汰数据库最久前访问的数据</p><p>Redis LRU 算法 可以更改样本数量来调整算法的精度，使其近似接近真实的 LRU 算法，同时又避免了内存的消耗，因为每次只需要采样少量样本，而不是全部数据。</p><p>LFU 还没学会，过两天学</p><p><a href="https://leetcode.cn/problems/lfu-cache/">https://leetcode.cn/problems/lfu-cache/</a></p><p>其他资料：</p><ul><li>面试中的 LRU &#x2F; LFU 的青铜与王者 <a href="https://halfrost.com/lru_lfu_interview/">https://halfrost.com/lru_lfu_interview/</a></li><li><a href="https://segmentfault.com/a/1190000022558044">https://segmentfault.com/a/1190000022558044</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Operating system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating system</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VF3图同构算法</title>
    <link href="/2024/07/26/VF3%20%E5%9B%BE%E5%90%8C%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    <url>/2024/07/26/VF3%20%E5%9B%BE%E5%90%8C%E6%9E%84%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<ol><li><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1></li></ol><p>聊聊子图同构算法 VF3。</p><ol><li><h2 id="（子）图同构-匹配："><a href="#（子）图同构-匹配：" class="headerlink" title="（子）图同构&#x2F;匹配："></a>（子）图同构&#x2F;匹配：</h2></li></ol><p><img src="https://nat-sumi.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTYwODRjMTEyZjYwMTU1YmRlMDAyMmVjOWMyYzA1MjhfZkRFanNHZkVsWXYzVkpuSFk5MzljZ2FsQzlWeUtCSTFfVG9rZW46UnVSbGIyeUtPb09JVk14ZFNCb2NISzNjbmZlXzE3MjE5NzU4Nzg6MTcyMTk3OTQ3OF9WNA" alt="img"></p><ol><li><h3 id="图同构问题"><a href="#图同构问题" class="headerlink" title="图同构问题"></a>图同构问题</h3><ul><li>问题描述： 若$G_1 &#x3D;(V_1,E_1)$和 $G_2&#x3D;(V_2,E_2)$ 间存在一个双射 $f:V1\rightarrow V_2 $使得$(u,v)\in E_1$iff $(f(u), f(v)) \in E_2$，则$G_1$和 $G_2$同构。<ul><li>$f$被称为同构映射。它既是注射（不同元素有不同映射）也是满射（每个元素都包含在可行域中）。</li><li>*(iff 表示当且仅当)</li></ul></li><li>问题难度：不确定图同构问题是否为 NP 问题， 但已证明图同构问题在 quasi-polynomial 时间内可解， 即时间复杂度为 $O(e^{({log~n})^c})$。</li></ul></li><li><h3 id="子图同构问题"><a href="#子图同构问题" class="headerlink" title="子图同构问题"></a>子图同构问题</h3><p><img src="https://nat-sumi.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDA1OGMyZWQzZTM4ODdiOTUyN2NiNmQ1MmZhNDRmODZfcGdsZ2RIRmxiam5iUk1jWmRYWHlQU2ttU2syM21GamRfVG9rZW46T1kyVWIwdFRmb3RKRG94TjNWRmNtS0ZrbmNiXzE3MjE5NzU4Nzg6MTcyMTk3OTQ3OF9WNA" alt="img"></p><ul><li>问题描述：在一个较大的目标图（Target Graph）中找出与较小的查询&#x2F;模式图（Query&#x2F;Pattern Graph）同构的（所有）子图。</li><li>问题性质：已证明为 NP-Complete 问题（比图同构更难）。</li></ul><p> 理解子图同构与图同构的思路：</p><ol><li>目标图和模式图大小相同时，子图同构问题坍缩为图同构问题。</li><li>子图同构是允许执行删除（且cost &#x3D; 0）的图同构算法。</li></ol></li><li><h3 id="图匹配问题"><a href="#图匹配问题" class="headerlink" title="图匹配问题"></a>图匹配问题</h3></li></ol><p>同构与匹配问题的关系：</p><ul><li>图同构： 只需判断两个图是否同构， 但不需要找出同构映射。</li><li>图匹配： 判断是否同构， <strong>并找出一组满足同构条件的映射。</strong></li><li>由于几乎所有算法都需要找出这个映射才能确认同构，因此后续将不做区分。</li></ul><p>(近似求解)错误容忍的图匹配：</p><ul><li><p>在一些应用中，人们愿意接受存在一定差异的两张图为问题的近似解，因此产生了错误容忍的图匹配问题</p></li><li><p>可以通过 图编辑距离&#x2F;相似度算法进行错误容忍的graph matching </p><ul><li>编辑距离：不同的编辑操作对应不同的 Cost Func</li><li>图相似度算法： 一个例子就是 $\sigma(G_1, G_2)&#x3D;1-\frac{|mcs(G_1, G_2|}{max(|G_1|,|G_2|)}$ <ul><li>mcs &#x3D;&gt; 最大公共子图；|G| 表示图 G 的结点个数</li></ul></li></ul></li><li><p>从错误容忍的角度理解图同构和子图同构的关系：子图同构是允许执行删除（且cost &#x3D; 0）的图同构算法</p></li></ul><ol><li><h2 id="（子）图同构典型思路"><a href="#（子）图同构典型思路" class="headerlink" title="（子）图同构典型思路"></a>（子）图同构典型思路</h2></li></ol><p>比较流行的处理（子）图同构问题的思路有 3 种：</p><ul><li><strong>树搜索（Tree Search）</strong>：在树形的搜索空间深度优先搜索，配合启发式规则剪枝<strong>。</strong>这种方法通过构造一个搜索树来表示状态空间，每个状态代表一个部分解。搜索通常以深度优先的顺序进行，使用启发式方法来避免探索无用的部分。<ul><li>典型算法：Ullmann, VF series, RI&#x2F;RI-DS</li></ul></li><li><strong>约束传播（Constraint Propagation）</strong>：这种方法将子图同构问题视为一个约束满足问题 (CSP)，目标是找到满足所有互相制约的变量赋值。这些变量是模式图的节点，而约束是这些节点之间的关系需要与目标图中的对应节点匹配。这类算法维护每个模式节点的兼容节点域，并通过传播局部约束（如节点或边的一致性）来缩小域，最终缩减候选匹配。<ul><li>典型算法：McGregor, BVCR</li></ul></li><li><strong>图索引（Graph Indexing）</strong>：这种方法源于图数据库应用，目标是从大量图中检索出包含特定模式的图。这类算法通过建立索引结构来快速检查目标图中是否存在模式，通常不需要加载整个目标图，从而过滤掉不可能的目标。<ul><li>典型算法：GADDI, TurboISO</li></ul></li></ul><ol><li><h1 id="子图同构算法-VF3"><a href="#子图同构算法-VF3" class="headerlink" title="子图同构算法 VF3"></a>子图同构算法 VF3</h1></li><li><h2 id="VF3-概述"><a href="#VF3-概述" class="headerlink" title="VF3 概述"></a>VF3 概述</h2></li></ol><ul><li>VF3 是典型的树搜索算法，其在 VF2Plus 的基础上进行了一系列的改进，擅长处理大型（指 10000+个节点）和密集图。</li><li>算法需要解决的核心问题是: 1. 如何将所有搜索情况组织成树以避免重复访问；2. 在回溯算法中如何最大程度剪枝。</li></ul><p><strong>VF3 关键特性和改进点：</strong></p><ol><li><p><strong>状态空间表示（State Space Representation）</strong></p><ol><li>VF3 继承了 VF2 的状态空间表示方法，其中每个状态代表一个部分的顶点映射。VF3 使用深度优先搜索策略来遍历这个状态空间。</li></ol></li><li><p><strong>启发式搜索 + 剪枝（Heuristic Search and Pruning）</strong></p><ol><li>VF3 算法引入了更精细的启发式方法来选择下一个匹配的顶点对，这有助于减少搜索空间并提高算法效率。能够显著减少在大型和密集图中的计算复杂度。</li></ol></li><li><p><strong>图预处理和候选选择（Graph Preprocessing and Candidate Selection）</strong></p><ol><li>VF3 在搜索开始前进行图的预处理，计算可能的候选顶点集合，以便在搜索过程中快速决定候选顶点。</li><li>算法还改进了候选节点的选择过程，通过对图中顶点的动态分类和快速筛选来优化匹配步骤。</li></ol></li><li><h2 id="VF-算法基础"><a href="#VF-算法基础" class="headerlink" title="VF 算法基础"></a>VF 算法基础</h2></li></ol><p>我们的任务是在图 $G_1&#x3D;(V_1,E_1)<del>和</del>G_2&#x3D;(V_2,E_2)$间寻找一个<strong>同构映射</strong> $M:V_1\rightarrow V_2$<strong>。</strong></p><ol><li><h3 id="State-Space-Representation-SSR"><a href="#State-Space-Representation-SSR" class="headerlink" title="State Space Representation (SSR)"></a>State Space Representation (SSR)</h3></li></ol><p>SSR （状态空间表示） 是一种在图匹配算法中用来<strong>表示所有可能的节点匹配状态的结构。</strong></p><ul><li>SSR 中的每个状态 s 代表同构映射 M 的部分映射 $\widetilde M(s) $，满足 $\widetilde M(s)⊆ M$。</li></ul><p>为了表示映射 $\widetilde M(s) $，VF3 算法根据<strong>节点是否已经在映射中，</strong>将节点分为 3 个不同的集合。</p><p>暂时无法在飞书文档外展示此内容</p><ul><li>$\color{red}{\widetilde M_1(s)}$： 核心集。存放$G_1$中已经匹配好的节点，保证集合中的节点满足同构映射</li><li>$\color{blue}{\widetilde{\mathcal{T_1}}(s)}$：可行（候选）集。保存与${\tilde M_1(s)}$直接相连的节点，它们是当前有可能加入核心集的节点</li><li>$\widetilde{V_1}(s)$：存放$G_1 $中的不在前两个集合中的其他节点</li><li>$G_2$也存在对应的三个集合</li></ul><ol><li><h3 id="树状结构搜索-SSR"><a href="#树状结构搜索-SSR" class="headerlink" title="树状结构搜索 SSR"></a>树状结构搜索 SSR</h3></li></ol><p>前面提到，状态 s 代表一种特定的顶点映射情况。不同状态间可以通过增减节点得到，因此状态的空间表示（SSR）天然为图结构。</p><p>在 VF3 算法中，为了不重复访问相同的状态，作者把 SSR 组织成一棵树，其中每个节点代表一个状态，每条边则代表一个可能的状态转换。</p><ul><li>根节点代表一个空的匹配（即没有任何顶点映射），每个叶子节点代表一种完整的匹配方案。</li><li>每个状态可以通过添加<strong>一组</strong>新的节点对来扩展到下一个状态，或者通过去掉上一次加入匹配的节点对来回溯到上一个状态并重新探索。</li></ul><p><img src="https://nat-sumi.feishu.cn/space/api/box/stream/download/asynccode/?code=MzkzMGU1MTA2ZjgyNjkxZjRjNzE0Mzk1NTJmNjhmY2NfQmZHVXEwOHRLTG1lZEhXU1Z1WElJSnFpaDBKRzZ0Y3pfVG9rZW46TTd5SWJZdXFIb3NxbWV4cElrbWNWNFhWbnJnXzE3MjE5NzU4Nzg6MTcyMTk3OTQ3OF9WNA" alt="img"></p><p>为了将 SSR 组织成树，我们需要对 $G_1$的节点集 $V_1$排序，组成一个节点探索序列 $N_{G_1}$。</p><ul><li>$N_{G_1}$的核心思想是<strong>优先探索受到更多约束和稀有的节点</strong>（以减少搜索空间大小）。<ul><li>$G_1$中节点的<strong>稀有程度</strong>，对应在$G_2$中找到一个满足同构映射的节点的难度，节点 u 的稀有程度定义为（图同构情况下，子图同构则为 $d’≥d(u)$）：<ul><li>$P_f(u)&#x3D;P_l(\lambda_{V_1}(u)) \cdot \Sigma_{d’&#x3D;d(u)}P_d(d’)$.</li><li>稀有程度$P_f$由 $P_l$（找到标签为 $l$的节点的难度）和 $P_d$（找到度为 d 的节点的难度）决定。</li><li>$\lambda_V(u)$是标签分配函数，输出节点 u 的标签。</li></ul></li><li>节点 u 的<strong>约束程度</strong>，取决于它与多少个已经处于$N_{G_1}$中的节点间有边，用映射度$d_M(u)$表示 （就是度，但只考虑与$N_{G_1}$中的节点的连接）。</li></ul></li><li>因此，计算$N_{G_1}$的方式为对节点多级排序，排序优先级分别是：<ul><li>节点的$d_M(u)$</li><li>稀有程度$P_f$</li><li>度</li></ul></li></ul><p>（若这三项均一样，则会随机选一个节点放入序列中）</p><p><strong>在当前条件下，我们可以这样简单的描述 VF3 算法的流程：</strong></p><ol><li><p>每次向状态$s_c$中添加一组节点$(u_n,v_n)$，形成一个新的状态$s_n&#x3D;s_c\cup(u_n,v_n)$，其中来自模式图$G_1$的节点$u_n$由 $N_{G_1}$决定，$v_n$则是由算法动态选择。</p></li><li><p>重复第一步，直到找到包含所有节点的理想状态或者证实匹配不存在。</p></li><li><h3 id="可行性检查"><a href="#可行性检查" class="headerlink" title="可行性检查"></a>可行性检查</h3></li></ol><p>事实上，我们不会直接将候选节点对 $(u_n,v_n)$加入状态 s 中，而是先对它们进行可行性检查。</p><p>可行性检查由两个部分组成：</p><ul><li>$F_s$ <strong>（Semantic Feasibility）</strong>: 语义可行性，检查两个节点（以及它们之间的边）的标签是否一致。如果节点或边的标签不匹配，这对节点就不能被考虑作为当前搜索状态的一部分</li><li>$F_t$ <strong>（Structural Feasibility）</strong>: 结构可行性，检查两个节点的邻居节点是否能够满足同构的要求<ul><li>$F_t$ 由核心规则$F_c$（core rule） 和两级前瞻规则$F_{la1}$， $F_{la2}$（1-level and 2-level lookahead rules） 构成</li></ul></li></ul><p>$F_s$ 简单来说就是只让标签相同的节点通过，$F_t$ 则较为复杂，是确保映射保持结构一致性和提升算法效率的关键部分。</p><h4 id="结构可行性-Ft"><a href="#结构可行性-Ft" class="headerlink" title="结构可行性 Ft"></a>结构可行性 Ft</h4><p>$F_t$ 的核心目标是：确保<strong>所建立的节点对不仅在当前步骤中结构上可行，而且不会在将来的几个步骤中导致映射失败。</strong></p><h4 id="通过分类函数-ψ-划分等价类"><a href="#通过分类函数-ψ-划分等价类" class="headerlink" title="通过分类函数 ψ 划分等价类"></a>通过分类函数 ψ 划分等价类</h4><p>设置一个分类函数 $\psi:V_1<del>∪</del>V_2\rightarrow C&#x3D;c_1,…,c_q; $  （等价类的数量 q 和分类函数可以自己设置）</p><ul><li>分类函数会将节点划分成 q 个等价类，它只需要满足：<ul><li><strong>若节点 u 和 v 在同构映射中是一组匹配的节点对， 则 u 和 v 必须在同个等价类中。</strong></li></ul></li><li>作者并未给出端到端的划分方案， 但可以利用这些信息指导划分：<ul><li>节点的标签（可以直接拿来当分类函数，也 f 可以完全不使用）</li><li>节点的度或其他的邻接信息</li><li>上下文或领域知识</li></ul></li><li>进一步的，将${\widetilde{\mathcal{T_1}}(s)}$根据等价类进一步分成 q 个：$\widetilde T_1^{c_i}(s)$ （表示既在可行集中，又属于第 i 个等价类的节点），类似的也可以定义$\tilde V_1^{c_i}(s)$。划分等价类是为了计算结构可行性$F_t$ 。</li></ul><h4 id="结构可行性-Ft-1"><a href="#结构可行性-Ft-1" class="headerlink" title="结构可行性 Ft"></a>结构可行性 Ft</h4><p>结构可行性函数 $F_t$ 由三个部分组成，分别是 $F_c$，$F_{la1}$，$F_{la2}$，表示为：</p><p>$F_t(s_c,u_n,v_n)&#x3D;F_c(s_c,u_n,v_n)\wedge F_{la1}(s_c,u_n,v_n)\wedge F_{la2}(s_c,u_n,v_n)$</p><ol><li><strong>核心规则</strong> $F_c$： <ol><li>$F_c(s_c,u_n,v_n)\Leftrightarrow\forall u^{\prime}\in adj_1(u_n)\cap\widetilde{M}_1(s_c)\quad\exists v^{\prime}&#x3D;\widetilde{\mu}(s_c,u^{\prime})\in adj_2(v_n)\\wedge\forall v^{\prime}\in adj_2(v_n)\cap\widetilde{M}_2(s_c)\quad\exists u^{\prime}&#x3D;\widetilde{\mu}^{-1}(s_c,v^{\prime})\in adj_1(u_n)$</li><li>核心目标：<strong>确保当前这组节点的加入不会马上导致结果错误。</strong></li><li>假设当前考虑的节点组 $(u_n,v_n)$， 核心规则 $F_c$对所有与$u_n$相邻且已经在映射中的节点$u’$，检查$u’$对应的匹配节点$v’$是否与$v_n$相邻。</li><li></li></ol></li><li><strong>前瞻性规则 （Lookahead Rules</strong> $F_{la1}$ <strong>and</strong> $F_{la2}$<strong>）</strong>:</li></ol><p>回顾基础概念中的介绍，SSR 中的每个状态 s 对应映射 $\widetilde M(s) $，VF3 算法根据<strong>节点是否已经在映射中，</strong>将节点分为 3 个不同的集合，分别是 $\widetilde M(s),\widetilde{\mathcal{T}}(s),\widetilde V(s)$，对于当前考虑的节点组 $(u_n,v_n)$（它们在可行集${\widetilde{\mathcal{T}}(s)}$中），在创建新状态 $s_n&#x3D;s_c\cup(u_n,v_n)$之前，$(u_n,v_n)$需要满足两级前瞻性规则：</p><p> <strong>一级前瞻规则</strong> $F_{la1}$</p><p> $F_{la1}(s_c,u_n,v_n)\iff F_{la1}^1(s_c,u_n,v_n)\wedge\ldots\wedge F_{la1}^q(s_c,u_n,v_n)$</p><p> 对于第 i 个等价类，一级前瞻规则 $F^i_{la1}$定义为<strong>：</strong></p><p> $F_{la1}^i(s_c,u_n,v_n)\iff|adj_1(u_n)\cap\widetilde{\mathcal{T}}_1^{c_i}(s_c)|\leq|adj_2(v_n)\cap\widetilde{\mathcal{T}}_2^{c_i}(s_c)|$</p><ul><li>核心目标：<strong>提前识别和排除可能会未来几步中违反同构条件的节点</strong>。</li><li>查看可行集${\tilde{\mathcal{T_1}}(s)}&#x2F;{\tilde{\mathcal{T_2}}(s)}$，对于$u_n$（模式图）的<code>在当前可行集内且属于第 i 个等价类的邻居数量</code>不能多于$v_n$（目标图）的（同属于 i 且在可行集内的邻居）数量</li><li>对于图同构问题，满足条件的邻居数量应该相同</li></ul><p><strong>二级前瞻规则</strong> $F_{la2}$<strong>：</strong></p><p>$F_{la2}(s_c,u_n,v_n)\iff F_{la2}^1(s_c,u_n,v_n)\wedge\ldots\wedge F_{la2}^q(s_c,u_n,v_n)$</p><p>对于第 i 个等价类，二级前瞻规则 $F^i_{la2}$定义为<strong>：</strong></p><p>$F_{la2}^i(s_c,u_n,v_n)\iff|adj_1(u_n)\cap\widetilde{V_1}^{c_i}(s_c)|\leq|adj_2(v_n)\cap\widetilde{V_2}^{c_i}(s_c)|$</p><ul><li>核心目标：在一级规则的基础上，<strong>加入更远一级的节点关系，进一步剪枝。</strong></li><li>类似一级前瞻规则 $F_{la1}$<strong>，查看</strong>$u_n$<strong>既不在映射</strong>$\widetilde M_1(s) $<strong>中也不在可行集</strong>$\widetilde{\mathcal{T_1}}(s)$中的邻居节点，其数量不能多于$v_n$对应的此类邻居节点 （图同构问题则也为相等）。</li></ul><p>注意：对于有向图，需要分别考虑入边和出边。</p><ol><li><h2 id="VF3-算法的改进"><a href="#VF3-算法的改进" class="headerlink" title="VF3 算法的改进"></a>VF3 算法的改进</h2></li></ol><p>VF3 算法在 VF2Plus 算法的基础上主要有两点改进：</p><ol><li><p>改进模式图的预处理 (State Space Precalculation)</p></li><li><p>改进候选节点对的选择方式 (Candidate Selection)</p></li><li><h3 id="状态空间预计算（State-Space-Precalculation-）"><a href="#状态空间预计算（State-Space-Precalculation-）" class="headerlink" title="状态空间预计算（State Space Precalculation ）"></a>状态空间预计算（State Space Precalculation ）</h3></li></ol><p>预处理的对象均是对模式图$G_1$。</p><h4 id="根据-N-G-1-预计算-widetilde-M-1-s-与-widetilde-mathcal-T-1-s"><a href="#根据-N-G-1-预计算-widetilde-M-1-s-与-widetilde-mathcal-T-1-s" class="headerlink" title="根据$N_{G_1}$预计算${\widetilde M_1(s)}$与${\widetilde{\mathcal{T_1}}(s)}$"></a>根据$N_{G_1}$预计算${\widetilde M_1(s)}$与${\widetilde{\mathcal{T_1}}(s)}$</h4><p>2.2.1 中提到，为了按照树状结构搜索SSR，我们定义了节点探索序列$N_{G_1}$，它是$G_1$中所有节点的一个排列。在算法迭代过程中，$u_n$总会按照$N_{G_1}$的顺序被匹配，因此我们可以提前计算每一层 SSR 的${\widetilde M_1(s)}$与${\widetilde{\mathcal{T_1}}(s)}$。</p><ul><li>$\widetilde{\mathcal{T}}_1^{c_i}(s)$<strong>的存储优化：</strong><ul><li><strong>若按照定义实现</strong>$\widetilde{\mathcal{T}}_1^{c_i}(s)$<strong>，则其需要</strong>$O(N_1^{2})$的空间来存储。<ul><li>假设$G_1$有$N_1$个节点，由于我们每次往状态中添加一个节点，因此 SSR 组成的树总共有 $N_1$层，每一层都需要维护$\widetilde{\mathcal{T}}_1^{c_i}(s)$<strong>。</strong></li></ul></li><li>结合可行集$\widetilde{\mathcal{T}}_1^{c_i}(s)$的定义<strong>，</strong>由于 SSR 每一层对应的$u_n$是确定的，因此$G_1$中的每个节点总会在一个固定的 SSR 层加入可行集中(它的第一个邻居加入同构映射时)，并在一个确定的时间离开可行集(它自己加入同构映射或算法退出)，在此过程中，它将持续被视为候选节点。</li><li>由此，算法对于每个节点，只记录其加入$\widetilde{\mathcal{T}}_1^{c_i}(s)$和退出$\widetilde{\mathcal{T}}_1^{c_i}(s)$的 SSR 层级，这样总体$\widetilde{\mathcal{T}}_1(s)$的空间开销变为$O(N_1)$。</li></ul></li></ul><p>近一步的，由于可行性检查都是在比集合大小，因此实现时，作者也不会真的维护可行集，而是采用对不同层，不同等价类，仅维护其大小的方式。</p><h4 id="维护父节点树-parent-tree"><a href="#维护父节点树-parent-tree" class="headerlink" title="维护父节点树 (parent tree)"></a>维护父节点树 (parent tree)</h4><p>维护父节点树是预处理的另一个关键部分，算法会为每一个节点指定一个”父节点”。</p><p><img src="https://nat-sumi.feishu.cn/space/api/box/stream/download/asynccode/?code=M2QzZTBjZDZmOGQ1YWIwOGU3YjY4MzAwNTMyZjg1MzdfTTg2TUVZYldUNGNwbzRPcWRLYlVFdVV3V29DcnVkbXVfVG9rZW46WEVNMWJJaEFzb3FKcmp4aWhwcmNPM2RDbjRiXzE3MjE5NzU4Nzg6MTcyMTk3OTQ3OF9WNA" alt="img"></p><ul><li>核心目标：辅助后续的<strong>候选节点选择</strong>和<strong>状态回溯。</strong></li><li>父节点树根据 $N_{G_1}$生成，对于$N_{G_1}$中的每个节点，算法检查其所有邻接节点，并基于它们在$N_{G_1}$的<strong>前后顺序</strong>来设置父子关系：<ul><li>一个节点的父节点是在$N_{G_1}$<strong>中排在它前面且与它直接相连的第一个节点。</strong></li><li>第一个匹配节点或孤立节点没有父节点。</li></ul></li><li>显然，父节点树只是一个决策支持工具，我们不用真的创建一颗树，只需要保存每个节点的父节点，因此使用 KV 逻辑存储（节点作为 key，其父节点为 value）。</li></ul><p>在需要回溯时，可以通过父节点信息迅速找到上一合法状态，撤销当前的选择，尝试其他可能的节点匹配。</p><ol><li><h3 id="候选节点选择（Candidate-Selection）"><a href="#候选节点选择（Candidate-Selection）" class="headerlink" title="候选节点选择（Candidate Selection）"></a>候选节点选择（Candidate Selection）</h3></li></ol><p>在每一层 SSR 中，算法都会选取一组候选节点$(u_n,v_n)$，并对这组节点进行可行性检查。</p><ul><li>其中模式图$G_1$的候选节点$u_n$已经由 $N_{G_1}$给出，因此Candidate Selection 的核心目标是<strong>确定目标图</strong>$G_2$<strong>的候选节点</strong>$v_n$<strong>。</strong></li><li>主要原理是通过分析$G_1$候选节点$u_n$的父节点来缩小候选节点$v_n$的选择范围：<ul><li>如果在父节点树上存在一个父亲节点 $\text{Parent}(u_n)$，则找到上一轮匹配中的$G_2$节点 $\tilde v$，在 $\tilde v$的邻居中选择第一个没有匹配且和 $u_n$为同一等价类的节点。表示为：</li></ul></li></ul><p>$R_2^{adj}(s_c,\psi(u_n),\widetilde{v})&#x3D;{v_n\in V_2:v_n\in adj_2(\widetilde{v})\cap R_2(s_c,u_n)}.$</p><ul><li>如果不存在父节点(第一个节点或者孤立节点），则去掉邻居的条件， 在$G_2$中随机选择一个与$u_n$为同一等价类的节点。表示为：</li></ul><p>$R_2(s_c,\psi(u_n))&#x3D;{v_n\in V_2:v_n\notin\widetilde{M}_2(s_c)\wedge \psi(v_n)&#x3D;\psi(u_n)}.$</p><p>算法流程概括为：</p><p><img src="https://nat-sumi.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDMxNjFiYTE0NzNjNjFhNGUxNzI2N2NmZDhlOGNjOWVfVmw5T3JHUmxPTnJSUWt3N1gzcUhRQ09pT251aWZLdkJfVG9rZW46VTRuRGJJMEdXb1ZlcVB4d3NyeGNsTmxCblNiXzE3MjE5NzU4Nzg6MTcyMTk3OTQ3OF9WNA" alt="img"></p><ol><li><h2 id="VF3-算法总结"><a href="#VF3-算法总结" class="headerlink" title="VF3 算法总结"></a>VF3 算法总结</h2></li></ol><p>VF3 算法总共由 3 个模块(阶段)组成：</p><ol><li><strong>预处理阶段</strong>：<ol><li><strong>节点排序</strong>：基于节点的稀有性和约束程度(连接度)，为模式图$G_1$中的节点确定探索序列 $NG_1$</li><li><strong>状态空间预计算</strong>：为$G_1$中的每个节点预计算可能的候选节点集合，基于节点的属性和结构特征，确定$G_2$中哪些节点可能与之匹配。</li></ol></li><li><strong>匹配阶段</strong>：<ol><li><strong>递归搜索</strong>：从$G_1$的第一个节点开始，递归地尝试匹配$G_2$中的候选节点。</li><li><strong>候选选择</strong>：根据是否存在父节点，为当前$G_1$候选节点 u 选择$G_2$中的候选节点 v。</li><li><strong>可行性检查</strong>：对每组候选节点，检查结构和语义的可行性，确保新增的节点匹配不违反已有的匹配结构，且在有继续探索的潜力。</li><li><strong>回溯</strong>：如果当前节点没有找到合适的匹配或后续匹配失败，则回溯到上一节点，尝试其他候选节点。</li></ol></li><li><strong>终止条件</strong>：所有节点都匹配上，或无法继续探索且无法回溯</li></ol><h3 id="（待补充）并发-多线程"><a href="#（待补充）并发-多线程" class="headerlink" title="（待补充）并发 &amp; 多线程"></a>（待补充）并发 &amp; 多线程</h3><p>VF3 的作者在后续更新了详细的性能分析和支持并发的 VF3 算法：</p><ul><li>Challenging the time complexity of exact subgraph isomorphism for huge and dense graphs with VF3 </li><li>Comparing performance of graph matching algorithms on huge graphs </li><li>A Parallel Algorithm for Subgraph Isomorphism</li></ul><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>.grf test case的布局：</p><blockquote><p>暂时无法在飞书文档外展示此内容</p></blockquote><blockquote><ol><li>si2_rnd_eta04_m1000_00.grf</li></ol><p>Case info: 1000 个节点，399,770 条边，节点属性全部设置为 1 </p><p>结果 (处理时间&#x2F;s)：</p><ul><li>正确同构：0.0513868 </li><li>子图同构：363.737 (第一个解)；3826.8 (全部解)</li></ul></blockquote><table><thead><tr><th align="left">Benchmark</th><th align="left">Samples</th><th align="left">Edges</th><th align="left">Attributes</th></tr></thead><tbody><tr><td align="left">rand4</td><td align="left">1000</td><td align="left">99,904</td><td align="left">1 (等权)</td></tr><tr><td align="left">si2_rnd_eta04</td><td align="left">1000</td><td align="left">399,770</td><td align="left">1</td></tr><tr><td align="left">rnd_ldg1</td><td align="left">2500</td><td align="left">1,248,179</td><td align="left">1</td></tr></tbody></table><p>汇总了直接匹配、修改属性、修改边的数量之后的图同构算法结束时间(second)</p><table><thead><tr><th align="left">Benchmark</th><th align="left">同构(无修改)</th><th align="left">修改属性</th><th align="left">修改边</th></tr></thead><tbody><tr><td align="left">rand4</td><td align="left">1.20e-02</td><td align="left">3.68e-03</td><td align="left">1.27e-02</td></tr><tr><td align="left">si2_rnd_eta04</td><td align="left">5.51e-02</td><td align="left">9.39e−03</td><td align="left">2.11e-08</td></tr><tr><td align="left">rnd_ldg1</td><td align="left">1.91e-01</td><td align="left">3.32e-02</td><td align="left">2.08e-08</td></tr></tbody></table><h3 id="Q-A"><a href="#Q-A" class="headerlink" title="Q &amp; A:"></a>Q &amp; A:</h3><blockquote><p>Q1：VF3 算法的评价？</p></blockquote><p>A：VF3 算法和所有其他的 Tree Seach 方法一样，属于一种特别版本的 A* 搜索，即在树形结构上 dfs + 回溯，同时结合启发式策略剪枝。VF3 算法的设计精巧，因此展现了较强的表现，尤其擅长子图同构任务。虽然用 VF3 无法直接处理 LVS 规模的问题，但其可行性规则的设计值得参考。</p><blockquote><p>Q2: 在处理图同构时，VF3 总能找到正确的解吗？算法退出时是不是代表两张图不同构？</p></blockquote><p>A：是的，总能找到正确的解，退出则表示两张图不同构。虽然进行了大量剪枝，但是算法实际上还是能覆盖 G1 和 G2能匹配的所有情况，不过最坏情况下有可能需要从最后一步回溯到第一步。</p><blockquote><p>Q3：可行集$\widetilde{\mathcal{T}}^{c_i}(s)$的理解</p></blockquote><p>A:  在匹配过程中，G1 的候选节点总是根据$N_{G_1}$确定的，而 G2 的候选节点总是由候选选择确定的。</p><p>$\widetilde{\mathcal{T}}_1^{c_i}(s)$和$\widetilde{\mathcal{T}}_2^{c_i}(s)$的唯一作用就是进行可行性检查，无关节点选择。</p><blockquote><p>Q4: VF3 的复杂度？</p></blockquote><p>A:  最好情况下为线性，最坏情况下为指数级。VF3 算法的时间和空间复杂度与图的大小、密度、图的结构以及图中顶点和边的分布均有关。</p><ul><li>作者没有给出官方时间复杂度，考虑最坏情况，即所有启发式规则均失效或为完全图，时间复杂度应当为$O(N^2)$~$O(N!N) $。通常在实际应用中，通过各种启发式优化和剪枝策略，其平均性能会比最坏情况表现得更好，但</li><li>考虑到网表比较的问题规模，一个较快的算法应当对网表进行拆分，采用分布式 + 并发执行。</li></ul><ol><li><h1 id="（待补充）Implementation"><a href="#（待补充）Implementation" class="headerlink" title="（待补充）Implementation"></a>（待补充）Implementation</h1></li></ol><p>VF3 算法的实现有很多现实考虑，因此代码和论文并不会严格对应。本段简要介绍官方实现中需要使用的数据结构和算法流程。</p><p><a href="https://github.com/MiviaLab/vf3lib">GitHub - MiviaLab&#x2F;vf3lib: VF3 Algorithm</a>  </p><p>*(代码仓库是最新的版本，因此支持后续的并行优化等特性)</p><p>另外，NetworkX 封装了 VF2++算法，可以实现即插即用的图同构检测：<a href="https://networkx.org/documentation/stable/reference/algorithms/isomorphism.html">https://networkx.org/documentation/stable/reference/algorithms/isomorphism.html</a></p><ol><li><h2 id="必要数据结构"><a href="#必要数据结构" class="headerlink" title="必要数据结构"></a>必要数据结构</h2></li><li><h3 id="Graph-的表示"><a href="#Graph-的表示" class="headerlink" title="Graph 的表示"></a>Graph 的表示</h3></li></ol><p>VF3 使用 <code>ARGraph</code> 表示属性关系图（Attributed Relational Graph）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> std::vector&lt;nodeID_t&gt; NodeVec;<br><span class="hljs-keyword">typedef</span> std::vector&lt;Edge&gt; EdgeAttrVector;   <br><span class="hljs-keyword">typedef</span> std::vector&lt;Node&gt; NodeAttrVector;<br><br><span class="hljs-comment">// 基本属性</span><br><span class="hljs-type">uint32_t</span> n;                   <span class="hljs-comment">/**&lt; 节点数量 */</span><br><span class="hljs-type">uint32_t</span> n_attr_count;        <span class="hljs-comment">/**&lt; 不同节点属性的数量 */</span><br><span class="hljs-type">uint32_t</span> e_attr_count;        <span class="hljs-comment">/**&lt; 不同边属性的数量 */</span><br><span class="hljs-type">uint32_t</span> e_count;             <span class="hljs-comment">/**&lt; 边的总数 */</span><br><span class="hljs-type">uint32_t</span> e_out_count;         <span class="hljs-comment">/**&lt; 出边的总数 */</span><br><span class="hljs-type">uint32_t</span> e_in_count;          <span class="hljs-comment">/**&lt; 入边的总数 */</span><br><span class="hljs-type">uint32_t</span> node_label_count;    <span class="hljs-comment">/**&lt; 节点标签的数量 */</span><br><span class="hljs-type">uint32_t</span> max_deg_in;          <span class="hljs-comment">/**&lt; 最大入度 */</span><br><span class="hljs-type">uint32_t</span> max_deg_out;         <span class="hljs-comment">/**&lt; 最大出度 */</span><br><span class="hljs-type">uint32_t</span> max_degree;          <span class="hljs-comment">/**&lt; 最大度数 */</span><br><br><span class="hljs-comment">// 节点 &amp; 边的属性</span><br>std::vector&lt;Node&gt; attr;                        <span class="hljs-comment">/**&lt; 节点属性 */</span><br>std::vector&lt;EdgeAttrVector&gt; in_attr;           <span class="hljs-comment">/**&lt; 入边属性 */</span><br>std::vector&lt;EdgeAttrVector&gt; out_attr;          <span class="hljs-comment">/**&lt; 出边属性 */</span><br><br><span class="hljs-comment">// 邻接信息</span><br>std::vector&lt;NodeVec&gt; in;                       <span class="hljs-comment">/**&lt; 入边相连的节点 */</span><br>std::vector&lt;NodeVec&gt; out;                      <span class="hljs-comment">/**&lt; 出边相连的节点 */</span><br><br><span class="hljs-comment">// 功能：边的检查和获取；检查两节点之间是否存在边，并获取特定节点的入边和出边</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HasEdge</span><span class="hljs-params">(nodeID_t n1, nodeID_t n2)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HasEdge</span><span class="hljs-params">(nodeID_t n1, nodeID_t n2, Edge &amp;pattr)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">nodeID_t <span class="hljs-title">GetInEdge</span><span class="hljs-params">(nodeID_t node, <span class="hljs-type">uint32_t</span> i)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">nodeID_t <span class="hljs-title">GetInEdge</span><span class="hljs-params">(nodeID_t node, <span class="hljs-type">uint32_t</span> i, Edge&amp; pattr)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">nodeID_t <span class="hljs-title">GetOutEdge</span><span class="hljs-params">(nodeID_t node, <span class="hljs-type">uint32_t</span> i)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">nodeID_t <span class="hljs-title">GetOutEdge</span><span class="hljs-params">(nodeID_t node, <span class="hljs-type">uint32_t</span> i, Edge&amp; pattr)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">// 功能：边遍历；遍 历特定节点的所有入边、出边或所有边，并对每条边应用访问者模式进行处理。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VisitInEdges</span><span class="hljs-params">(nodeID_t node, edge_visitor vis, param_type param)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VisitOutEdges</span><span class="hljs-params">(nodeID_t node, edge_visitor vis, param_type param)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VisitEdges</span><span class="hljs-params">(nodeID_t node, edge_visitor vis, param_type param)</span></span>;<br></code></pre></td></tr></table></figure><p>VF3 使用 <code>ARGLoader</code> 加载图数据，从而将图的构建过程与具体的数据格式解耦。<code>ARGLoader</code> 提供了一组标准接口，任何实现了这些接口的加载器都可以用于构建 <code>ARGraph</code>。这促进了代码复用，不同的图加载器可以共享相同的图构建逻辑。</p><p><code>ARGLoader</code>的主要功能包括：</p><ul><li><code>virtual uint32_t NodeCount() const</code> 节点计数。</li><li><code>virtual Node GetNodeAttr(nodeID_t node)</code> 获取节点属性。</li><li><code>virtual uint32_t OutEdgeCount(nodeID_t node) const</code> 出边计数。</li><li><code>virtual nodeID_t GetOutEdge(nodeID_t node, uint32_t i, Edge *pattr)</code> 获取出边信息。返回指定节点的第 <code>i</code> 条出边的目标节点，并获取该边的属性。</li></ul><ol><li><h3 id="State-的表示"><a href="#State-的表示" class="headerlink" title="State 的表示"></a>State 的表示</h3></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint32_t</span> nodeID_t<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint8_t</span> nodeDir_t;<br><span class="hljs-keyword">typedef</span> vflib::VF3LightSubState&lt;<span class="hljs-type">data_t</span>, <span class="hljs-type">data_t</span>, vflib::Empty, vflib::Empty&gt; <span class="hljs-type">state_t</span>;<br><span class="hljs-type">const</span> nodeDir_t NODE_DIR_NONE = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> nodeDir_t NODE_DIR_IN  = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> nodeDir_t NODE_DIR_OUT = <span class="hljs-number">2</span>;<br><span class="hljs-type">const</span> nodeDir_t NODE_DIR_BOTH = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// 图的引用和比较函数</span><br>ARGraph&lt;Node1, Edge1&gt; *g1;<br>ARGraph&lt;Node2, Edge2&gt; *g2;<br><br><span class="hljs-comment">// 重载，用来比较节点和边</span><br>NodeComparisonFunctor nf;  <br>EdgeComparisonFunctor ef;<br><br><span class="hljs-comment">// 方向性标识</span><br>nodeDir_t* dir;    <span class="hljs-comment">// 表示节点的方向（无、入、出、双向）</span><br>nodeID_t* predecessors;    <span class="hljs-comment">// 每个节点在有序序列中的前驱节点。</span><br><br><span class="hljs-comment">// 核心集</span><br><span class="hljs-type">uint32_t</span> *core_len_c;<br>nodeID_t *core_1;<br>nodeID_t *core_2;<br><br><span class="hljs-comment">// 终端集大小（Terminal Set Sizes）</span><br><span class="hljs-type">uint32_t</span> t2in_len, t2both_len, t2out_len;     <span class="hljs-comment">// 第二个图的终端集大小</span><br><span class="hljs-type">uint32_t</span> *t1in_len, *t1both_len, *t1out_len;     <span class="hljs-comment">// 第一个图在每个深度级别的终端集大小</span><br><span class="hljs-type">uint32_t</span> *t2both_len_c, *t2in_len_c, *t2out_len_c;     <span class="hljs-comment">// 第二个图每个类的终端集大小</span><br><span class="hljs-type">uint32_t</span> **t1both_len_c, **t1in_len_c, **t1out_len_c;     <span class="hljs-comment">// 第一个图每个深度级别和每个类的终端集大小</span><br><br><span class="hljs-comment">// 终端集更新</span><br><span class="hljs-type">uint32_t</span> *termout2_c, *termin2_c, *new2_c;     <span class="hljs-comment">// 用于更新第二个图的终端集大小</span><br><span class="hljs-type">uint32_t</span> **termout1_c, **termin1_c, **new1_c;     <span class="hljs-comment">// 用于更新第一个图的终端集大小</span><br><span class="hljs-type">uint32_t</span> *termin1, *termout1, *new1;     <span class="hljs-comment">// 第一个图的终端集计数</span><br><br><span class="hljs-comment">// 节点集合</span><br>nodeID_t *in_2, *out_2;<br><span class="hljs-type">int64_t</span> last_candidate_index;<br><br><span class="hljs-comment">// 类和类别相关</span><br><span class="hljs-type">uint32_t</span> *class_1, *class_2;<br><span class="hljs-type">uint32_t</span> classes_count;<br></code></pre></td></tr></table></figure><ul><li><strong>核心集（Core Set）</strong>就是论文中的核心集${\widetilde M(s)}$，它负责记录匹配进展和指导后续匹配。</li><li><strong>终端集（Terminal Set）</strong>是文中可行集${\widetilde{\mathcal{T}}(s)}$ 的实现，但逻辑有变化。<ul><li><strong>状态跟踪</strong>：终端集帮助算法在匹配过程中跟踪每个节点的当前状态（如是否在核心集中，是否有入边或出边等），终端集在每个深度级别上动态更新。</li><li>核心：在状态转换时，只需更新大小，而不需要重新计算整个集合。<ul><li><strong>维护集合长度一致性而非内容一致性：</strong> 在匹配过程中，只需要知道某个节点集合是否为空（长度是否为零）或者其大小相对于另一个集合的大小来决定下一步的操作。通过跟踪集合的长度，可以简化状态管理和更新的逻辑。</li></ul></li><li>终端集有三种类型：<ul><li><strong>入边终端集（In-terminal set）</strong>：跟踪每个节点的入边集合。</li><li><strong>出边终端集（Out-terminal set）</strong>：跟踪每个节点的出边集合。</li><li><strong>双向终端集（Both-terminal set）</strong>：跟踪同时存在入边和出边的节点集合。</li></ul></li><li>一维数组 &amp; 二维数组：<ul><li>一维数组的项目是维护了不同等价类的大小，<ul><li>如<code>t2out_len_c[class]</code>，表示第二个图类别 <code>class</code> 的节点的出边终端集大小。</li></ul></li><li>二维数组的项是既维护了不同等价类，也维护不同层的集合大小：<ul><li>如<code>t1out_len_c[level][class]</code>，表示在第一个图的深度级别 <code>level</code> 下，类别 <code>class</code> 的节点的出边终端集大小。</li></ul></li></ul></li></ul></li></ul><ol><li><h3 id="对State的操作"><a href="#对State的操作" class="headerlink" title="对State的操作"></a>对State的操作</h3></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// public </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NextPair</span><span class="hljs-params">(nodeID_t *pn1, nodeID_t *pn2,</span></span><br><span class="hljs-params"><span class="hljs-function">    nodeID_t prev_n1 = NULL_NODE, nodeID_t prev_n2 = NULL_NODE)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsFeasiblePair</span><span class="hljs-params">(nodeID_t n1, nodeID_t n2)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddPair</span><span class="hljs-params">(nodeID_t n1, nodeID_t n2)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">IsGoal</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> core_len == n1; &#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsDead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-comment">// private</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BackTrack</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeFirstGraphTraversing</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UpdateTerminalSetSize</span><span class="hljs-params">(nodeID_t node,  <span class="hljs-comment">// 换行</span></span></span><br><span class="hljs-params"><span class="hljs-function">nodeID_t level, <span class="hljs-type">bool</span>* in_1, <span class="hljs-type">bool</span>* out_1, <span class="hljs-type">bool</span>* inserted)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>NextPair</code>：查找下一个可行的节点对，基于当前状态更新候选节点。</li><li><code>IsFeasiblePair</code>：检查节点对是否可以加入到当前状态中。</li><li><code>AddPair</code>：将节点对添加到核心集 M 中，并更新状态。</li><li><code>IsDead</code>：检查当前状态是否死节点，即是否不再可能找到匹配。</li><li><code>BackTrack</code>：回溯操作，撤销上一次添加的节点对。</li><li><code>ComputeFirstGraphTraversing</code>：初始化第一个图的遍历顺序和终端集大小，确保算法从最优的起点开始，并设置每个节点的初始状态。</li><li><code>UpdateTerminalSetSize</code>：在匹配过程中动态更新终端集的大小和状态，确保终端集的计数器和节点状态在每一步都保持最新。这两个方法共同作用，支持VF3算法的高效执行。</li></ul><ol><li><h2 id="VF3-算法-workflow"><a href="#VF3-算法-workflow" class="headerlink" title="VF3 算法 workflow"></a>VF3 算法 workflow</h2></li><li><h3 id="初始化-（命令参数解析-配置，信号处理，-读取图数据，初始化匹配引擎）"><a href="#初始化-（命令参数解析-配置，信号处理，-读取图数据，初始化匹配引擎）" class="headerlink" title="初始化 （命令参数解析&amp;配置，信号处理， 读取图数据，初始化匹配引擎）"></a><strong>初始化 （命令参数解析&amp;配置，信号处理， 读取图数据，初始化匹配引擎）</strong></h3></li></ol><ul><li><p>命令参数解析，参数实例 opt 包含了初始化需要的几乎所有参数 </p><ul><li><pre><code class="C++">Options opt;if(!GetOptions(opt, argc, argv)) &#123;exit(-1);&#125;<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>- 加载图数据（读取文件，通过 ARGLoader 构造为 ARGraph）<br><br>  - ```C++<br>    <span class="hljs-comment">// Pattern &amp; Target </span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int32_t</span> <span class="hljs-type">data_t</span></span><br><span class="hljs-function">    std::ifstream <span class="hljs-title">graphInPat</span><span class="hljs-params">(opt.pattern)</span></span>;<br>    <span class="hljs-function">std::ifstream <span class="hljs-title">graphInTarg</span><span class="hljs-params">(opt.target)</span></span>;<br>    ARGLoader&lt;<span class="hljs-type">data_t</span>, Empty&gt;* pattloader = <span class="hljs-built_in">CreateLoader</span>&lt;<span class="hljs-type">data_t</span>, Empty&gt;(opt, graphInPat);<br>    ARGLoader&lt;<span class="hljs-type">data_t</span>, Empty&gt;* targloader = <span class="hljs-built_in">CreateLoader</span>&lt;<span class="hljs-type">data_t</span>, Empty&gt;(opt, graphInTarg);<br>    <span class="hljs-function">ARGraph&lt;<span class="hljs-type">data_t</span>, Empty&gt; <span class="hljs-title">patt_graph</span><span class="hljs-params">(pattloader)</span></span>;<br>    <span class="hljs-function">ARGraph&lt;<span class="hljs-type">data_t</span>, Empty&gt; <span class="hljs-title">targ_graph</span><span class="hljs-params">(targloader)</span></span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>属性关系图（Attributed Relational Graph，ARG）是一种图形化表示方法，用于描述对象之间的属性和关系。其将对象表示为节点，对象之间的属性和关系表示为边。节点上通常带有属性信息，而边则表示对象之间的关联或依赖关系。</p></li></ul></li></ul><ol><li><h3 id="预处理（匹配引擎初始化，快速检查，节点分类，构造节点序列-NG-1-）"><a href="#预处理（匹配引擎初始化，快速检查，节点分类，构造节点序列-NG-1-）" class="headerlink" title="预处理（匹配引擎初始化，快速检查，节点分类，构造节点序列$NG_1$）"></a>预处理（匹配引擎初始化，快速检查，节点分类，构造节点序列$NG_1$）</h3><ul><li>初始化匹配引擎 &amp; FastCheck</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int32_t</span> <span class="hljs-type">data_t</span><br><span class="hljs-keyword">typedef</span> vflib::VF3LightSubState&lt;<span class="hljs-type">data_t</span>, <span class="hljs-type">data_t</span>, vflib::Empty, vflib::Empty&gt; <span class="hljs-type">state_t</span><br>MatchingEngine&lt;<span class="hljs-type">state_t</span>&gt;* me = <span class="hljs-built_in">CreateMatchingEngine</span>(opt);<br><span class="hljs-function">FastCheck&lt;<span class="hljs-type">data_t</span>, <span class="hljs-type">data_t</span>, Empty, Empty&gt; <span class="hljs-title">check</span><span class="hljs-params">(&amp;patt_graph, &amp;targ_graph)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>FastCheck 能够排除显然不同构的 Case，对于图同构问题，FastCheck能够排除这些情况：<ul><li>节点&#x2F;边的数量不同；入边&#x2F;出边的数量不同（有向图）</li><li>最大度不同；最大入度&#x2F;出度不同（有向图）</li><li>节点属性明显不同</li></ul></li><li>节点分类</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;<span class="hljs-type">uint32_t</span>&gt; class_patt;<br>std::vector&lt;<span class="hljs-type">uint32_t</span>&gt; class_targ;<br><br><span class="hljs-function">NodeClassifier&lt;<span class="hljs-type">data_t</span>, Empty&gt; <span class="hljs-title">classifier</span><span class="hljs-params">(&amp;targ_graph)</span></span>;<br><span class="hljs-function">NodeClassifier&lt;<span class="hljs-type">data_t</span>, Empty&gt; <span class="hljs-title">classifier2</span><span class="hljs-params">(&amp;patt_graph, classifier)</span></span>;<br>class_patt = classifier<span class="hljs-number">2.</span><span class="hljs-built_in">GetClasses</span>();<br>class_targ = classifier.<span class="hljs-built_in">GetClasses</span>();<br></code></pre></td></tr></table></figure><ul><li>构造模式图的节点序列$NG_1$，这一步的逻辑和论文一样，作者用优先队列 (堆)实现</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++">VF3NodeSorter&lt;<span class="hljs-type">data_t</span>, Empty, SubIsoNodeProbability&lt;<span class="hljs-type">data_t</span>, Empty&gt; &gt; <span class="hljs-built_in">sorter</span>(&amp;targ_graph);<br>std::vector&lt;nodeID_t&gt; sorted = sorter.<span class="hljs-built_in">SortNodes</span>(&amp;patt_graph);<br><br><span class="hljs-function">std::vector&lt;nodeID_t&gt; <span class="hljs-title">SortNodes</span><span class="hljs-params">(ARGraph&lt;Node, Edge&gt;* pattern)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint32_t</span> nodeCount;<br>    <span class="hljs-type">uint32_t</span> i;<br>    nodeCount = pattern-&gt;<span class="hljs-built_in">NodeCount</span>();<br>    std::vector&lt;nodeID_t&gt; nodes_order; <span class="hljs-comment">//Output vector with sorted nodes</span><br><span class="hljs-comment">//We use two structures the first used to quickly edit the deg_m of a node by its index</span><br><span class="hljs-comment">//The second to perform a priority queue by means a max heap</span><br>    <span class="hljs-function">std::vector&lt;VF3SortingNode*&gt; <span class="hljs-title">nodes</span><span class="hljs-params">(nodeCount)</span></span>;<br>    std::vector&lt;VF3SortingNode*&gt; candidates; <span class="hljs-comment">//Node candidate for the addition</span><br>    std::vector&lt;VF3SortingNode*&gt;::iterator candidate_it;<br>    std::vector&lt;VF3SortingNode*&gt;::iterator max_node;<br>    <span class="hljs-comment">//Initializing the node vector for sorting</span><br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nodeCount; i++) &#123;<br>        nodes[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">VF3SortingNode</span>(i, pattern-&gt;<span class="hljs-built_in">EdgeCount</span>(i), probability-&gt;<span class="hljs-built_in">GetProbability</span>(pattern, i));<br>    &#125;<br><br>    <span class="hljs-type">uint32_t</span> n = <span class="hljs-number">0</span>;<br>    candidate_it = std::<span class="hljs-built_in">min_element</span>(nodes.<span class="hljs-built_in">begin</span>(), nodes.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">CompareSortingNodeProbability</span>());<br>    nodeID_t top = (*candidate_it)-&gt;<span class="hljs-built_in">GetID</span>();<br>    <span class="hljs-built_in">AddNodeToSortedSet</span>(pattern, top, n, nodes, candidates, nodes_order);<br><br>    <span class="hljs-comment">//Getting the first node of the heap</span><br>    <span class="hljs-keyword">for</span> (; n &lt; nodeCount - <span class="hljs-number">1</span>; n++) &#123;<br>        candidate_it = std::<span class="hljs-built_in">min_element</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">CompareCandidates</span>&lt;VF3SortingNode&gt;());<br><br>        <span class="hljs-comment">//Searching for remaining user</span><br>        <span class="hljs-keyword">if</span> ((*candidate_it)-&gt;<span class="hljs-built_in">IsUsed</span>())<br>        &#123;<br>            candidate_it = std::<span class="hljs-built_in">find_if</span>(nodes.<span class="hljs-built_in">begin</span>(), nodes.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">FindUnused</span>());<br>            <span class="hljs-built_in">AddNodeToSortedSet</span>(pattern, (*candidate_it)-&gt;<span class="hljs-built_in">GetID</span>(), n, nodes, candidates, nodes_order);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (candidate_it != candidates.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            <span class="hljs-built_in">AddNodeToSortedSet</span>(pattern, (*candidate_it)-&gt;<span class="hljs-built_in">GetID</span>(), n, nodes, candidates, nodes_order);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nodes_order;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h3 id="匹配过程（从初始状态-s0-开始搜索）"><a href="#匹配过程（从初始状态-s0-开始搜索）" class="headerlink" title="匹配过程（从初始状态 s0 开始搜索）"></a>匹配过程（从初始状态 s0 开始搜索）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">state_t</span> <span class="hljs-title">s0</span><span class="hljs-params">(&amp;patt_graph, &amp;targ_graph, class_patt.data(), class_targ.data(), classes_count, sorted.data())</span></span>;<br>me-&gt;<span class="hljs-built_in">FindAllMatchings</span>(s0);    <span class="hljs-comment">//MatchingEngine&lt;state_t&gt;* me </span><br></code></pre></td></tr></table></figure></li></ol><p><code>FindAllMatchings</code>的逻辑和论文一样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> std::vector&lt;std::pair&lt;nodeID_t, nodeID_t&gt; &gt; MatchingSolution;<br>MatchingVisitor&lt;VFState&gt; *visit;<br>std::vector&lt;MatchingSolution&gt; solutions;<br><span class="hljs-type">bool</span> storeSolutions;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">FindAllMatchings</span><span class="hljs-params">(VFState &amp;s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">IsGoal</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (storeSolutions) &#123;<br>            MatchingSolution sol;<br>            s.<span class="hljs-built_in">GetCoreSet</span>(sol);<br>            solutions.<span class="hljs-built_in">push_back</span>(sol);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (visit) &#123;<br>            <span class="hljs-keyword">return</span> (*visit)(s);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">IsDead</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    nodeID_t n1 = NULL_NODE, n2 = NULL_NODE;<br>    <span class="hljs-keyword">while</span> (s.<span class="hljs-built_in">NextPair</span>(&amp;n1, &amp;n2, n1, n2)) &#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">IsFeasiblePair</span>(n1, n2)) &#123;<br>            <span class="hljs-function">VFState <span class="hljs-title">s1</span><span class="hljs-params">(s)</span></span>;<br>            s<span class="hljs-number">1.</span><span class="hljs-built_in">AddPair</span>(n1, n2);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FindAllMatchings</span>(s1)) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><h3 id="后处理-资源回收（释放-engine-和-loader-等）"><a href="#后处理-资源回收（释放-engine-和-loader-等）" class="headerlink" title="后处理 &amp; 资源回收（释放 engine 和 loader 等）"></a>后处理 &amp; 资源回收（释放 engine 和 loader 等）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">delete</span> me;<br><span class="hljs-keyword">delete</span> pattloader;<br><span class="hljs-keyword">delete</span> targloader;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/07/26/Hypergraph%20&amp;%20semi-supervised%20paper%20review/"/>
    <url>/2024/07/26/Hypergraph%20&amp;%20semi-supervised%20paper%20review/</url>
    
    <content type="html"><![CDATA[<hr><hr><h1 id="Hypergraph-semi-supervised-paper-review"><a href="#Hypergraph-semi-supervised-paper-review" class="headerlink" title="Hypergraph &amp; semi-supervised paper review"></a>Hypergraph &amp; semi-supervised paper review</h1><p>汇总了这几年的 超图 + 半监督中的有趣文献。</p><h1 id="Wasserstein-Soft-Label-Propagation-on-Hypergraphs-Algorithm-and-Generalization-Error-Bounds"><a href="#Wasserstein-Soft-Label-Propagation-on-Hypergraphs-Algorithm-and-Generalization-Error-Bounds" class="headerlink" title="Wasserstein Soft Label Propagation on Hypergraphs: Algorithm and Generalization Error Bounds"></a>Wasserstein Soft Label Propagation on Hypergraphs: Algorithm and Generalization Error Bounds</h1><p>核心思路：</p><ol><li><strong>背景和动机</strong>：随着超图在机器学习和数据挖掘算法中的应用不断增加，<strong>本文探讨了在超图上通过最优传输进行“软标签”传播的</strong>半监督学习算法。软标签（如概率分布、类别成员分数）传播相较于传统的硬标签传播，具有更高的灵活性和信息量，适用于不确定性和分布信息至关重要的场景。</li><li><strong>算法设计</strong>：借鉴Wasserstein传播算法（Solomon et al., 2014），本文将标签传播过程重新构建为<strong>消息传递算法</strong>，通过Wasserstein重心实现了其在超图上的一般化。利用2-Wasserstein距离，提出了一种新的消息传递算法，用于在超图上传播一维分布。</li><li><strong>理论贡献</strong>：在PAC学习框架内，本文提供了在图和超图上传播一维分布的泛化误差界，通过建立所提出算法的算法稳定性，揭示了Wasserstein传播算法在图上的新见解和更深层次的理解。</li></ol><p>贡献</p><ol><li><strong>扩展Wasserstein传播至超图</strong>：提出了基于Wasserstein重心的超图软标签传播算法，并通过多边最优传输问题解决了该算法在超图上的推广。</li><li><strong>算法稳定性和泛化误差界</strong>：在PAC学习框架下，本文建立了使用2-Wasserstein距离传播一维分布的泛化误差界，提供了关于Wasserstein传播算法在图上泛化能力的首个理论结果。</li><li><strong>数值实验和实际应用</strong>：通过在随机超图和UCI数据集（包括国会投票记录和蘑菇特征数据）上的实验，展示了所提出算法的有效性。</li></ol><p><strong>传统的标签传播算法</strong>（如Belkin等人提出的算法）通常用于图（graph）上的标签传播，<strong>其标签为数值或类别变量</strong>。而<strong>Wasserstein传播算法</strong>通过最优传输理论<strong>将标签扩展为概率分布或软标签</strong>（soft label），提高了算法的灵活性和信息量。</p><ul><li><strong>Wasserstein传播算法</strong>最初在图（graph）上定义，其<strong>目的是在节点之间传播概率分布标签</strong>。本文将这一过程重新构建为消息传递算法，并扩展到超图（hypergrap</li></ul><blockquote><p><strong>在图上的Wasserstein标签传播</strong></p></blockquote><p>给定一个图$$G &#x3D; (V, E)$$，定义一个度量空间上的概率分布映射$$\mu: V \to P(N)$$</p><p>假设有一部分节点 $$V_0 \subseteq V$$的标签已知，目标是确定其余节点 $$ V \setminus V_0 $$ 的标签。目标函数为：</p><p>$$ \min_{f: V \to P(N)} \frac{1}{m} \sum_{i&#x3D;1}^{m} W_2^2(\mu_i, f(i)) + \gamma \sum_{(i,j) \in E} \omega_{ij} W_2^2(f(i), f(j)) $$</p><p>其中$$\gamma$$是正则化参数，$$\omega_{ij}$$ 是边$$(i, j)$$的权重，$$W_2$$是2-Wasserstein距离。</p><p><strong>超图上的Wasserstein标签传播</strong></p><p>在超图$$H &#x3D; (V, E)$$上，由于超边（hyperedge）可以包含任意数量的顶点，目标函数需要重新定义。超图上的Wasserstein传播算法基于消息传递更新规则：</p><ol><li><strong>消息传递更新规则</strong></li></ol><p>从节点 i 向超边 E 发送消息$$ J_{i \to E}$$: </p><p>$$J_{i \to E}(b_i) &#x3D; W_2^2(\mu_i, b_i) + \sum_{E’ \in E \setminus {E}: i \in E’} J_{E’ \to i}(b_i) $$</p><p>超边 E 向节点 i 发送消息$$J_{E \to i}$$:</p><p>$$J_{E \to i}(b_i) &#x3D; \min_{f_{E \setminus {i}}} \left[ \text{bar}(E) + \sum_{k \in E \setminus {i}} J_{k \to E}(f_k) \right]$$</p><p>$$\text{bar}(E)$$是超边 E 上的 Wasserstein 重心</p><ol start="2"><li><strong>迭代更新信念</strong></li></ol><ul><li>节点  i 的信念  b_i  更新为：</li></ul><p>$$b_i &#x3D; \arg \min_{f_i \in P(N)} \left[ W_2^2(\mu_i, f_i) + \sum_{E \in E: i \in E} J_{E \to i}(f_i) \right] $$     </p><ol start="3"><li><strong>最终目标函数</strong></li></ol><ul><li>对整个超图的目标函数为：</li></ul><p>$$\min_{f: V \to P(N)} \frac{1}{m} \sum_{i&#x3D;1}^{m} W_2^2(\mu_i, f(i)) + \gamma \sum_{E \in E} \text{bar}(E) $$     </p><ol start="3"><li><strong>Wasserstein重心</strong></li></ol><p>Wasserstein重心的计算是核心步骤之一，具体定义如下：</p><p>给定 k  个概率分布 $$\rho_1, \ldots, \rho_k$$ ，它们的Wasserstein重心为：</p><p>$$\text{bar}({\rho_i}<em>{i&#x3D;1}^k) &#x3D; \inf</em>{\nu \in P(N)} \frac{1}{k} \sum_{i&#x3D;1}^k W_2^2(\rho_i, \nu)$$</p><p>对于一维概率分布，其Wasserstein重心可以通过累积分布函数的逆函数来计算：</p><p>$$F^{-1}<em>{b}(s) &#x3D; \frac{1}{k} \sum</em>{i&#x3D;1}^k F^{-1}_{\rho_i}(s)$$</p><h1 id="Semi-supervised-Hypergraph-Node-Classification-on-Hypergraph-Line-Expansion"><a href="#Semi-supervised-Hypergraph-Node-Classification-on-Hypergraph-Line-Expansion" class="headerlink" title="Semi-supervised Hypergraph Node Classification on Hypergraph Line Expansion"></a>Semi-supervised Hypergraph Node Classification on Hypergraph Line Expansion</h1><h3 id="一句话总结：用-线性扩展（LE）将超图转换为简单图结构"><a href="#一句话总结：用-线性扩展（LE）将超图转换为简单图结构" class="headerlink" title="一句话总结：用 线性扩展（LE）将超图转换为简单图结构"></a>一句话总结：用 线性扩展（LE）将超图转换为简单图结构</h3><p><img src="https://nat-sumi.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzg4MTkwMTM5NWQyOGFhYzNlMmU4YzY4YmU4M2Q5NGNfa3c0WHRWcFRObkNBQUxqeXhnMjJ1aFNEUXhVdVM0U1RfVG9rZW46UHM2QmI4S3VNbzk1N254c1loVGNhMThqbjhkXzE3MjE5NzU2ODA6MTcyMTk3OTI4MF9WNA" alt="img"></p><h1 id="Self-Supervised-Guided-Hypergraph-Feature-Propagation-for-Semi-Supervised-Classification-with-Missing-Node-Features"><a href="#Self-Supervised-Guided-Hypergraph-Feature-Propagation-for-Semi-Supervised-Classification-with-Missing-Node-Features" class="headerlink" title="Self-Supervised Guided Hypergraph Feature Propagation for Semi-Supervised Classification with Missing Node Features"></a>Self-Supervised Guided Hypergraph Feature Propagation for Semi-Supervised Classification with Missing Node Features</h1><h3 id="一句话总结：-用来解决只给一部分特征的任务。"><a href="#一句话总结：-用来解决只给一部分特征的任务。" class="headerlink" title="一句话总结： 用来解决只给一部分特征的任务。"></a>一句话总结： 用来解决只给一部分特征的任务。</h3><p>SGHFP通过以下步骤进行特征传播和重建：</p><ul><li><strong>特征超图构建</strong>：根据节点的已知特征构建特征超图。</li><li><strong>伪标签超图构建</strong>：利用前一迭代产生的重建特征通过两层GNN构建伪标签超图。</li><li><strong>超图融合</strong>：在每次迭代前，将特征超图和伪标签超图融合，生成更有效的超图。</li><li><strong>特征传播</strong>：使用融合后的超图进行特征传播，重建缺失的节点特征。</li><li><strong>迭代优化</strong>：通过多次迭代优化，最终重建的节点特征用于下游的半监督分类任务。</li></ul><p>自监督引导的超图特征传播（SGHFP）</p><p><img src="https://nat-sumi.feishu.cn/space/api/box/stream/download/asynccode/?code=YzUxODZkMjk2NjllMmQ0M2I3MzJjODg4ODg5ZWVmMWNfcjdGUHFHY3JmbDlETFE3dFk3b3hvMVBVYXg2ZkFSdTNfVG9rZW46TkdsRmJlUDhjbzlxVlF4ZnhQOWNUWERRbjJlXzE3MjE5NzU2ODA6MTcyMTk3OTI4MF9WNA" alt="img"></p><h1 id="Nonlinear-Feature-Diffusion-on-Hypergraphs"><a href="#Nonlinear-Feature-Diffusion-on-Hypergraphs" class="headerlink" title="Nonlinear Feature Diffusion on Hypergraphs"></a>Nonlinear Feature Diffusion on Hypergraphs</h1><h3 id="一句话总结：-提出一种非线性特征扩散方法，在超图上同时传播特征和标签，以捕捉更复杂的节点间关系。"><a href="#一句话总结：-提出一种非线性特征扩散方法，在超图上同时传播特征和标签，以捕捉更复杂的节点间关系。" class="headerlink" title="一句话总结： 提出一种非线性特征扩散方法，在超图上同时传播特征和标签，以捕捉更复杂的节点间关系。"></a>一句话总结： 提出一种非线性特征扩散方法，在超图上同时传播特征和标签，以捕捉更复杂的节点间关系。</h3><p><img src="https://nat-sumi.feishu.cn/space/api/box/stream/download/asynccode/?code=NWJlMTUwNzlkYTdlODJlNmQ2OGIyZmFjMjQzZjBiZDJfaVNGeDR4VExNQ3NsRWRGQ1gzczNKN1Q0TzMxa0JvYXBfVG9rZW46U0dVTmJQNE1Yb2VQU2Z4TTBBVmM5RUlFbmtiXzE3MjE5NzU2ODA6MTcyMTk3OTI4MF9WNA" alt="img"></p><h1 id="Sheaf-Hypergraph-Networks-重了-你多下了一个"><a href="#Sheaf-Hypergraph-Networks-重了-你多下了一个" class="headerlink" title="Sheaf Hypergraph Networks (重了, 你多下了一个)"></a>Sheaf Hypergraph Networks (重了, 你多下了一个)</h1><h3 id="一句话总结：通过在超图中引入纤维丛（cellular-sheaf）结构，增强了超图的表示能力，从而更好地建模复杂数据结构。"><a href="#一句话总结：通过在超图中引入纤维丛（cellular-sheaf）结构，增强了超图的表示能力，从而更好地建模复杂数据结构。" class="headerlink" title="一句话总结：通过在超图中引入纤维丛（cellular sheaf）结构，增强了超图的表示能力，从而更好地建模复杂数据结构。"></a>一句话总结：通过在超图中引入纤维丛（cellular sheaf）结构，增强了超图的表示能力，从而更好地建模复杂数据结构。</h3><p><strong>引入纤维丛超图结构</strong>：纤维丛超图通过在超图的节点和超边上关联向量空间，并提供线性投影，使信息在节点和超边之间传递，从而实现更丰富的数据表示。</p><p><strong>提出纤维丛超图拉普拉斯算子</strong>：包括线性和非线性两种形式，提供了更具表达力的归纳偏差，有效地建模复杂现象。</p><p><strong>开发新型<strong><strong>神经网络</strong></strong>模型</strong>：设计了基于纤维丛超图拉普拉斯算子的SheafHyperGNN和SheafHyperGCN模型，实验结果表明，这些模型在多个基准数据集上的表现优于现有方法。</p><p><img src="https://nat-sumi.feishu.cn/space/api/box/stream/download/asynccode/?code=MDQ0MzYyMjFkMTYwYmI1ZjZlODUyOGZjMThhYWJhOWNfRGdnS0Z2Z1VQamgxUzEzR0N0bmJrUlBJV0VyVFk0MmRfVG9rZW46R0hNZmJqdHA4b1B1YXZ4Yk14emN4eW4ybktkXzE3MjE5NzU2ODA6MTcyMTk3OTI4MF9WNA" alt="img"></p><h1 id="Hypergraph-enhanced-Dual-Semi-supervised-Graph-Classification"><a href="#Hypergraph-enhanced-Dual-Semi-supervised-Graph-Classification" class="headerlink" title="Hypergraph-enhanced Dual Semi-supervised Graph Classification"></a>Hypergraph-enhanced Dual Semi-supervised Graph Classification</h1><h3 id="一句话总结-提出了一种增强的双半监督图分类框架（HEAL），通过超图和线图两个视角捕捉图语义，从而更好地利用未标记图数据，提高分类性能。"><a href="#一句话总结-提出了一种增强的双半监督图分类框架（HEAL），通过超图和线图两个视角捕捉图语义，从而更好地利用未标记图数据，提高分类性能。" class="headerlink" title="一句话总结: 提出了一种增强的双半监督图分类框架（HEAL），通过超图和线图两个视角捕捉图语义，从而更好地利用未标记图数据，提高分类性能。"></a>一句话总结: 提出了一种增强的双半监督图分类框架（HEAL），通过超图和线图两个视角捕捉图语义，从而更好地利用未标记图数据，提高分类性能。</h3><p>HEAL框架包括三个主要模块：</p><ul><li><strong>高阶依赖学习模块</strong>：通过自适应学习超图结构，捕捉节点间的复杂依赖关系。</li><li><strong>线图卷积模块</strong>：利用线图捕捉超边间的交互，从而挖掘更深层次的语义结构。</li><li><strong>关系一致性学习模块</strong>：促进两个分支间的知识传递，增强模型在未标记图上的表现。</li></ul><p><img src="https://nat-sumi.feishu.cn/space/api/box/stream/download/asynccode/?code=NGYxMjdmODEwODc2ZGVlNjRkODQ1ZDVkNmYxY2I3OGVfM1N2SlZDTDJsRUlmdXV6T2VjQnVWV09KUklqeXRlUmlfVG9rZW46Q2ZkVGJjNTJDbzcxd094Rkk4eWNjaEI5bnZjXzE3MjE5NzU2ODA6MTcyMTk3OTI4MF9WNA" alt="img"></p><h1 id="Hypergraph-Transformer-for-semi-supervised-classification"><a href="#Hypergraph-Transformer-for-semi-supervised-classification" class="headerlink" title="Hypergraph Transformer for semi-supervised classification"></a>Hypergraph Transformer for semi-supervised classification</h1><h3 id="一句话总结-利用Transformer架构有效地捕捉超图中的全局相关性，同时保留局部连接模式。"><a href="#一句话总结-利用Transformer架构有效地捕捉超图中的全局相关性，同时保留局部连接模式。" class="headerlink" title="一句话总结:利用Transformer架构有效地捕捉超图中的全局相关性，同时保留局部连接模式。"></a>一句话总结:利用Transformer架构有效地捕捉超图中的全局相关性，同时保留局部连接模式。</h3><p><strong>提出HyperGraph Transformer框架</strong>：通过Transformer架构结合超图特定组件，实现同时捕捉全局和局部结构信息，提升了超图表示学习的效果。</p><p><strong>设计了新的位置编码机制和结构<strong><strong>正则化</strong></strong>方法</strong>：利用超图关联矩阵进行位置编码和结构正则化，有效地融合了超图的结构信息，提升了模型性能。</p><p><strong>实验验证</strong>：在四个实际数据集上的实验结果表明，HyperGT在节点分类任务中显著优于现有的最先进方法，并展示了各个设计组件的有效性。</p><p><img src="https://nat-sumi.feishu.cn/space/api/box/stream/download/asynccode/?code=MGQxMjRhZTgxZGFjODRhZjA3NDY1MGFkYjc0MGUyNTBfekhESGdNWnlrYVRMaWV6M3VWb3lUSmN1WkhjTm9JNERfVG9rZW46Skxyc2I4OHlIb2MydDh4WHFlU2MyZUU3bmJiXzE3MjE5NzU2ODA6MTcyMTk3OTI4MF9WNA" alt="img"></p><h1 id="Hypergraph-Label-Propagation-Network"><a href="#Hypergraph-Label-Propagation-Network" class="headerlink" title="Hypergraph Label Propagation Network"></a>Hypergraph Label Propagation Network</h1><h3 id="一句话总结-提出了一种超图标签传播网络（HLPN），将超图标签传播与深度神经网络结合，通过端到端架构优化特征嵌入，从而实现更高效的数据标注。"><a href="#一句话总结-提出了一种超图标签传播网络（HLPN），将超图标签传播与深度神经网络结合，通过端到端架构优化特征嵌入，从而实现更高效的数据标注。" class="headerlink" title="一句话总结: 提出了一种超图标签传播网络（HLPN），将超图标签传播与深度神经网络结合，通过端到端架构优化特征嵌入，从而实现更高效的数据标注。"></a>一句话总结: 提出了一种超图标签传播网络（HLPN），将超图标签传播与深度神经网络结合，通过端到端架构优化特征嵌入，从而实现更高效的数据标注。</h3><p><strong>提出了一种新的超图<strong><strong>半监督学习</strong></strong>框架</strong>：该框架通过稀疏样本捕捉流形结构，并实现端到端学习。</p><p><strong>提高超图学习效率</strong>：相比传统超图方法，HLPN不需要构建整个数据集的超图，从而提高了计算效率。</p><p><strong>实验验证</strong>：在实际数据集上的实验结果表明，HLPN在性能上显著优于最先进的方法。</p><p><img src="https://nat-sumi.feishu.cn/space/api/box/stream/download/asynccode/?code=OTRmMThhMzRhOGM4ODFiYTE5NjZiZDI5ZTM2ZjQ1ZGZfSHlhVm1CYW5qWFBOdGJVQXZIdGYxdVFjTmd6Qm5oZDJfVG9rZW46RHpmb2JvcnNCb0NoYld4WmFGOWN6QUk5bmRlXzE3MjE5NzU2ODA6MTcyMTk3OTI4MF9WNA" alt="img"></p><h1 id="Hypergraph-Convolutional-Network-based-Weakly-Supervised-Point-Cloud-Semantic-Segmentation-with-Scene-Level-Annotations"><a href="#Hypergraph-Convolutional-Network-based-Weakly-Supervised-Point-Cloud-Semantic-Segmentation-with-Scene-Level-Annotations" class="headerlink" title="Hypergraph Convolutional Network based Weakly Supervised Point Cloud Semantic Segmentation with Scene-Level Annotations"></a>Hypergraph Convolutional Network based Weakly Supervised Point Cloud Semantic Segmentation with Scene-Level Annotations</h1><h3 id="一句话总结-提出了一种基于加权超图卷积网络（WHCN）的弱监督点云语义分割方法，通过场景级别标注学习点级别伪标签，从而提高分割性能。"><a href="#一句话总结-提出了一种基于加权超图卷积网络（WHCN）的弱监督点云语义分割方法，通过场景级别标注学习点级别伪标签，从而提高分割性能。" class="headerlink" title="一句话总结: 提出了一种基于加权超图卷积网络（WHCN）的弱监督点云语义分割方法，通过场景级别标注学习点级别伪标签，从而提高分割性能。"></a>一句话总结: 提出了一种基于加权超图卷积网络（WHCN）的弱监督点云语义分割方法，通过场景级别标注学习点级别伪标签，从而提高分割性能。</h3><p><strong>算法设计</strong>：</p><ul><li><strong>超点生成与超图构建</strong>：利用几何同质划分生成超点，以平衡不同类别点数的不均衡性，并降低模型复杂度。基于高置信度超点种子构建超图。</li><li><strong>加权超图卷积网络</strong>：设计了加权超图卷积网络（WHCN），通过标签传播生成高精度的点级别伪标签。WHCN包括谱超图卷积块和超边注意力模块，调整超边权重以优化标签传播。</li><li><strong>伪标签生成与分割网络训练</strong>：利用生成的伪标签训练分割网络，实现高精度的点云语义分割。</li></ul><p><img src="https://nat-sumi.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWFkZGM5NTAxNGU2ZDkwODZkY2Q4MzdhZGEzNGU4NjBfaThRNFFWRDVXODFMMWZoVmE3alY1cTlXcW9uTFRva2tfVG9rZW46VEh4dmJidDJzb1FXU3J4OXVQa2N0SlVhbjFjXzE3MjE5NzU2ODA6MTcyMTk3OTI4MF9WNA" alt="img"></p><p><img src="https://nat-sumi.feishu.cn/space/api/box/stream/download/asynccode/?code=NmJiMzI1ZDNlZGY4ZjI0NmQwYTY1ZTE2MWQyYzAwOTZfREYxVFRtcUlPdjNXYlNTYnF1bUNFT082Mk1uRG1IeEhfVG9rZW46R3NhdmJ6N2ZFb2F5T1Z4WWVSOGNUelBybkdoXzE3MjE5NzU2ODA6MTcyMTk3OTI4MF9WNA" alt="img"></p><h1 id="From-Hypergraph-Energy-Functions-to-Hypergraph-Neural-Networks"><a href="#From-Hypergraph-Energy-Functions-to-Hypergraph-Neural-Networks" class="headerlink" title="From Hypergraph Energy Functions to Hypergraph Neural Networks"></a>From Hypergraph Energy Functions to Hypergraph Neural Networks</h1><h3 id="这个你看了-就不总结了"><a href="#这个你看了-就不总结了" class="headerlink" title="这个你看了, 就不总结了"></a>这个你看了, 就不总结了</h3><h1 id="CHGNN-A-Semi-Supervised-Contrastive-Hypergraph-Learning-Network"><a href="#CHGNN-A-Semi-Supervised-Contrastive-Hypergraph-Learning-Network" class="headerlink" title="CHGNN: A Semi-Supervised Contrastive Hypergraph Learning Network"></a>CHGNN: A Semi-Supervised Contrastive Hypergraph Learning Network</h1><h3 id="一句话总结-提出了一种对比超图神经网络（CHGNN），结合自监督对比学习技术，从标记和未标记数据中学习。CHGNN包括一个自适应超图视图生成器、改进的超图编码器和一个结合相似度损失、节点分类损失和超边同质性损失的联合损失函数。"><a href="#一句话总结-提出了一种对比超图神经网络（CHGNN），结合自监督对比学习技术，从标记和未标记数据中学习。CHGNN包括一个自适应超图视图生成器、改进的超图编码器和一个结合相似度损失、节点分类损失和超边同质性损失的联合损失函数。" class="headerlink" title="一句话总结: 提出了一种对比超图神经网络（CHGNN），结合自监督对比学习技术，从标记和未标记数据中学习。CHGNN包括一个自适应超图视图生成器、改进的超图编码器和一个结合相似度损失、节点分类损失和超边同质性损失的联合损失函数。"></a>一句话总结: 提出了一种对比超图神经网络（CHGNN），结合自监督对比学习技术，从标记和未标记数据中学习。CHGNN包括一个自适应超图视图生成器、改进的超图编码器和一个结合相似度损失、节点分类损失和超边同质性损失的联合损失函数。</h3><p><strong>算法设计</strong>：</p><ul><li><strong>自适应超图视图生成器</strong>：采用自动增强策略，学习最小充分视图的扰动概率分布。</li><li><strong>改进的超图****编码器</strong>：考虑超边的同质性，有效融合信息。</li><li><strong>联合****损失函数</strong>：结合视图生成器的相似度损失、节点分类损失和超边同质性损失，增强监督信号。此外，还包括基础对比损失和交叉验证对比损失，提高对比学习效果。</li></ul><p><img src="https://nat-sumi.feishu.cn/space/api/box/stream/download/asynccode/?code=YjQyNTM2NjYyNzEyNGViMDQ5ZTI4NTI0YjM0MDkwMWZfY09wbk5qNkZ0UHN6NXVVbUx4NG01NFhlaGRuNUQ1V1NfVG9rZW46UEpPWmJpbGlEb01jMWh4ZWljM2NRZTdmblFnXzE3MjE5NzU2ODA6MTcyMTk3OTI4MF9WNA" alt="img"></p><h1 id="Hypergraph-Dynamic-System"><a href="#Hypergraph-Dynamic-System" class="headerlink" title="Hypergraph Dynamic System"></a>Hypergraph Dynamic System</h1><h3 id="一句话总结-出了一种超图动态系统（HDS），将超图和动态系统联系起来，描述表示的连续动态演化过程。提出的控制扩散超图动态系统通过常微分方程（ODE）实现，设计了一个多层HDSode作为神经实现，包含控制步骤和扩散步骤。"><a href="#一句话总结-出了一种超图动态系统（HDS），将超图和动态系统联系起来，描述表示的连续动态演化过程。提出的控制扩散超图动态系统通过常微分方程（ODE）实现，设计了一个多层HDSode作为神经实现，包含控制步骤和扩散步骤。" class="headerlink" title="一句话总结: 出了一种超图动态系统（HDS），将超图和动态系统联系起来，描述表示的连续动态演化过程。提出的控制扩散超图动态系统通过常微分方程（ODE）实现，设计了一个多层HDSode作为神经实现，包含控制步骤和扩散步骤。"></a>一句话总结: 出了一种超图动态系统（HDS），将超图和动态系统联系起来，描述表示的连续动态演化过程。提出的控制扩散超图动态系统通过常微分方程（ODE）实现，设计了一个多层HDSode作为神经实现，包含控制步骤和扩散步骤。</h3><p>看起来解决了深层的 HGNN 模型的问题?</p><p><strong>算法设计</strong>：</p><ul><li><strong>超图****动态系统</strong>：基于ODE，引入控制和扩散函数，形成超图动态系统模型。</li><li><strong>HDSode框架</strong>：设计了一个多层HDSode框架，实现可控且稳定的超图表示学习。</li><li><strong>稳定性分析</strong>：证明了HDSode的稳定性，并展示了其在捕捉长距离顶点关系方面的能力。</li></ul><p><img src="https://nat-sumi.feishu.cn/space/api/box/stream/download/asynccode/?code=YTcyNTI5MzE1Mjg3OWQ4MDc1NDVmMDgyZWJhOGNiYWFfZFJORUs0NTdwR1RCRmtnYUVGR3VhSzVEZnNzQ1owejdfVG9rZW46UUVPUWIwSHNMb3Z4VFV4Q2Rwc2NmaGh0bkFkXzE3MjE5NzU2ODA6MTcyMTk3OTI4MF9WNA" alt="img"></p><h1 id="VilLain-Self-Supervised-Learning-on-Hypergraphs-without-Features-via-Virtual-Label-Propagation"><a href="#VilLain-Self-Supervised-Learning-on-Hypergraphs-without-Features-via-Virtual-Label-Propagation" class="headerlink" title="VilLain: Self-Supervised Learning on Hypergraphs without Features via Virtual Label Propagation"></a>VilLain: Self-Supervised Learning on Hypergraphs without Features via Virtual Label Propagation</h1><h3 id="一句话总结-提出了一种新的自监督超图表示学习方法VilLain，基于虚拟标签（v-labels）的传播"><a href="#一句话总结-提出了一种新的自监督超图表示学习方法VilLain，基于虚拟标签（v-labels）的传播" class="headerlink" title="一句话总结: 提出了一种新的自监督超图表示学习方法VilLain，基于虚拟标签（v-labels）的传播"></a>一句话总结: 提出了一种新的自监督超图表示学习方法VilLain，基于虚拟标签（v-labels）的传播</h3><p><strong>算法设计</strong>：</p><ul><li><strong>虚拟标签生成</strong>：假设存在d个虚拟标签，并为每个节点分配一个稀疏的v-label概率分布。</li><li><strong>超图上的v-label传播</strong>：通过交替在节点和超边之间传播v-label，来获得节点和超边的v-label分配矩阵。</li><li><strong>多v-label传播</strong>：为了捕捉复杂的结构-标签模式，将嵌入空间划分为多个子空间，分别进行v-label传播，并最终连接各子空间的输出作为节点嵌入。</li></ul><ol><li><strong>自监督损失函数设计</strong>：结合局部损失和全局损失，通过最大化节点和超边v-label分配向量的熵，确保标签的同质性和全局分布的均衡性和区分性。</li></ol><p><img src="https://nat-sumi.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGNiYjJjYzFjYjQ1MzA2Mjg2MmQ1MTBkZGMzZmY2MmNfNDgzaTFqc2VTYTlsRmVnOW1SMTVHajFvSHlZbTZhemRfVG9rZW46UVhORmJBd1dHbzVxRm94Wldwd2NSM3NtblllXzE3MjE5NzU2ODA6MTcyMTk3OTI4MF9WNA" alt="img"></p><h1 id="Multi-Task-Hypergraphs-for-Semi-supervised-Learning-using-Earth-Observations"><a href="#Multi-Task-Hypergraphs-for-Semi-supervised-Learning-using-Earth-Observations" class="headerlink" title="Multi-Task Hypergraphs for Semi-supervised Learning using Earth Observations"></a>Multi-Task Hypergraphs for Semi-supervised Learning using Earth Observations</h1><p><strong>背景和动机</strong>：在地球观测（Earth Observation）任务中，通常需要多任务处理不同的观测层数据。然而，由于传感器故障等原因，观测数据常常不完整。这一问题迫切需要一种能够在数据缺失情况下仍能有效学习的半监督学习方法。本文提出了一种强大的多任务超图（Multi-Task Hypergraph），通过利用不同任务之间的高阶依赖关系，在超图上实现多任务半监督学习。每个节点表示一个任务，通过不同路径形成的超边作为无监督教师，生成任务的可靠伪标签。</p><p><strong>多任务超图结构</strong>：每个任务作为超图的节点，不同路径通过超图中的超边形成无监督教师。这些超边既作为教师也作为学生，通过自监督的方式进行学习。</p><p><strong>超边集成模型</strong>：通过集成多个路径生成伪标签，提升伪标签的可靠性和鲁棒性。</p><p><strong>自监督学习过程</strong>：利用NASA NEO数据集，进行大量实验验证多任务半监督学习方法的有效性。实验结果表明，该方法在数据分布逐渐变化的情况下，能够可靠地恢复多达七年的缺失数据。</p><h4 id="主要贡献："><a href="#主要贡献：" class="headerlink" title="主要贡献："></a>主要贡献：</h4><ol><li><strong>提出多任务超图框架</strong>：通过高阶任务依赖关系，实现了一个集成的、鲁棒的半监督学习方法。</li><li><strong>设计了超边集成模型</strong>：利用多个路径生成伪标签，提升了伪标签的可靠性和模型的鲁棒性。</li><li><strong>实验验证</strong>：在NASA NEO数据集上的实验表明，本文方法在多个基准任务上均取得了显著的性能提升，并能够适应数据分布的逐渐变化。</li></ol><p>Efficient and Effective Attributed Hypergraph Clustering via 𝐾-Nearest Neighbor Augmentation </p><h1 id="Efficient-and-Effective-Attributed-Hypergraph-Clustering-via-𝐾-Nearest-Neighbor-Augmentation"><a href="#Efficient-and-Effective-Attributed-Hypergraph-Clustering-via-𝐾-Nearest-Neighbor-Augmentation" class="headerlink" title="Efficient and Effective Attributed Hypergraph Clustering via 𝐾-Nearest Neighbor Augmentation"></a>Efficient and Effective Attributed Hypergraph Clustering via 𝐾-Nearest Neighbor Augmentation</h1><p>属性超图聚类（Attributed Hypergraph Clustering，AHC）旨在将属性超图中的节点划分为k个不相交的簇，使得同一簇内的节点在结构上紧密连接，并且属性相似，而不同簇的节点则属性差异显著。现有的AHC方法在处理大规模属性超图时面临计算成本高、聚类质量不佳等问题。</p><p><strong>算法设计</strong>：本文提出了一种高效的属性超图聚类方法AHCKA（Attributed Hypergraph Clustering via K-nearest neighbor Augmentation），通过几个关键算法设计实现了高效的AHC：</p><ul><li><strong>K-最近邻增强策略</strong>：利用属性信息优化超图结构，通过引入KNN图来构建额外的连接。</li><li><strong>联合随机游走模型</strong>：设计了一个联合随机游走模型，以优化AHC目标。</li><li><strong>高效求解器</strong>：利用矩阵运算和贪心迭代框架，大幅提升计算效率。</li></ul><h4 id="主要贡献：-1"><a href="#主要贡献：-1" class="headerlink" title="主要贡献："></a>主要贡献：</h4><ol><li><strong>提出了KNN增强策略</strong>：通过KNN图构建额外连接，有效利用属性信息提升超图结构的聚类质量。</li><li><strong>设计了联合随机游走模型</strong>：结合超图和KNN图的高阶关系，以优化AHC的目标函数。</li><li><strong>实现了高效求解器</strong>：通过矩阵运算和贪心迭代框架，显著提升了AHC的计算效率。</li></ol><p><img src="https://nat-sumi.feishu.cn/space/api/box/stream/download/asynccode/?code=OTIyNTcwMzZlZWZhYmE2OGM2ZWQ2MWE2OGMxOTQzN2RfbEgwbkNWSmRGU1k3MU1DZDBPaFRDVjhwNkFJVlZkQ0NfVG9rZW46SlNIUGJTd2dab1Z6VUF4UlpMYWNWaTdEbjFpXzE3MjE5NzU2ODA6MTcyMTk3OTI4MF9WNA" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文提出的AHCKA方法通过KNN增强策略、联合随机游走模型和高效求解器，实现了高效的属性超图聚类。在多个实际数据集上的实验验证了其在聚类质量和计算效率上的优势，为大规模属性超图的聚类问题提供了一种有效的解决方案。未来工作将进一步优化KNN增强策略和随机游走模型，提高模型的适用性和鲁棒性。</p><h1 id="MEGA-Multi-View-Semi-Supervised-Clustering-of-Hypergraphs"><a href="#MEGA-Multi-View-Semi-Supervised-Clustering-of-Hypergraphs" class="headerlink" title="MEGA: Multi-View Semi-Supervised Clustering of Hypergraphs"></a><strong>MEGA: Multi-View Semi-Supervised Clustering of Hypergraphs</strong></h1><p>提出了一种多视图半监督超图聚类方法MEGA（Multi-view sEmi-supervised hyperGrAph clustering），结合实体的多种特征和部分已知标签信息，提升聚类性能。</p><p><strong>背景和动机</strong>：在现实世界中，超图模型可以有效地表示复杂的实体间关系。传统的超图聚类方法主要依赖超图的连接结构，忽略了实体的其他属性和多视图关系。本文提出了一种多视图半监督超图聚类方法MEGA（Multi-view sEmi-supervised hyperGrAph clustering），结合实体的多种特征和部分已知标签信息，提升聚类性能。</p><p><strong>算法设计</strong>：MEGA通过以下步骤实现多视图半监督聚类：</p><ul><li><strong>超图标准化切割与加权核K均值</strong>：证明超图标准化切割目标与加权核K均值目标的数学等价性，并基于此开发了一种高效的多级超图聚类算法hGraclus，为MEGA提供良好的初始化。</li><li><strong>多视图聚类目标函数</strong>：将超图结构、实体的多种特征和关系以及部分已知标签信息整合到统一的非负矩阵分解（NMF）框架中，定义多视图聚类目标函数。</li><li><strong>半监督聚类扩展</strong>：通过部分已知标签和成对约束，将多视图聚类目标函数扩展为半监督聚类框架。</li></ul><p><img src="https://nat-sumi.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmIwODkwOGMxMzlhZWE3MjhkMTY2YjYxYTg3NTNlNmJfMnE4NzBFWjdDblF4aUVVaE5lUWVoSDZCdUF3TGRJbXBfVG9rZW46RFJnVmIySHpvb3gxcWF4b1ZNdWNUUHNnbm5lXzE3MjE5NzU2ODA6MTcyMTk3OTI4MF9WNA" alt="img"></p><p>目标函数:</p><p>$$\min_{W, H, \hat{H}<em>j} \sum</em>{i&#x3D;1}^{p} \alpha_i |X_i - W_iH|<em>F^2 + \sum</em>{j&#x3D;1}^{q} \beta_j |S_j - \hat{H}_j^TH|<em>F^2 + \sum</em>{j&#x3D;1}^{q} \gamma_j |\hat{H}_j - H|_F^2 + |M \circ (P - WH)|_F^2$$</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Convolutional Nerual Network (Andrew Ng)</title>
    <link href="/2022/04/03/Convolutional-Nerual-Network(Andrew%20Ng)/"/>
    <url>/2022/04/03/Convolutional-Nerual-Network(Andrew%20Ng)/</url>
    
    <content type="html"><![CDATA[<p>title: ComSec &amp; Crypto 综述<br>date: 2021&#x2F;11&#x2F;24 20:46:25<br>tags: Computer security<br>categories: [Computer security, Crypto]<br>banner_img: &#x2F;bimg&#x2F;computer_security.jpg<br>index_img: &#x2F;bimg&#x2F;crypto.jpg</p><h1 id="Convolutional-Nerual-Network-Andrew-Ng"><a href="#Convolutional-Nerual-Network-Andrew-Ng" class="headerlink" title="Convolutional Nerual Network(Andrew Ng)"></a>Convolutional Nerual Network(Andrew Ng)</h1><p>本文是吴恩达老师关于卷积神经网络的课程笔记。</p><h5 id="卷积如何完成"><a href="#卷积如何完成" class="headerlink" title="卷积如何完成"></a>卷积如何完成</h5><p>首先以灰阶图像为例，此时的输入通道为1。下面的图演示了卷积的具体过程。</p><p>和矩阵乘法的思想类似，3x3的filter(kernel)和图片中对应的3x3相乘并相加得到最终矩阵里的一个数。之后平移整个 蓝色方块，就可以计算出周围的值(有时需要进行pedding)</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tv8p2502j21xm0u0q77.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tvcajweoj21va0ru42b.jpg"></p><p>用动画来展示这一点</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h337prm2pug20em0aojsv.gif"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tvcpeio0j21mo0u078m.jpg"></p><p>以灰阶图像<u><em>垂直边界检测</em></u>(6x6图像)为例。结果矩阵里白色就对应边界。 值得注意的是，边界看起来很厚，这是因为图像太小，如果是1000x1000的图像，那么其结果将会不那么厚。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tvdfq8udj21km0hs76a.jpg"></p><p>如果我们将原图片进行灰阶反转，得到的结果会不一样，但本质上仍然可以起到区分的作用。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tvgf6l9jj21kq0gk40g.jpg"></p><p>不难想到，如果想要对灰阶图像进行<u><em>水平边界检测</em></u>，那么可以使用右边的filter来遍历图像。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tvhehnamj21d00g075b.jpg"></p><p>如果输入的图片是彩色图片，它的输入通道数为3，输出通道数也为3。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tvhz3j9rj215o0ikdht.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
      <tag>Convolutional Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斌头之计算机安全学</title>
    <link href="/2021/12/12/%E6%96%8C%E5%A4%B4%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%AD%A6/"/>
    <url>/2021/12/12/%E6%96%8C%E5%A4%B4%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="斌头之计算机安全学"><a href="#斌头之计算机安全学" class="headerlink" title="斌头之计算机安全学"></a>斌头之计算机安全学</h1><h1 id="1-概论"><a href="#1-概论" class="headerlink" title="1. 概论"></a>1. 概论</h1><h2 id="「要在一条不安全的信道中传递信息，这是计算机安全存在的原因。」"><a href="#「要在一条不安全的信道中传递信息，这是计算机安全存在的原因。」" class="headerlink" title="「要在一条不安全的信道中传递信息，这是计算机安全存在的原因。」"></a>「要在一条不安全的信道中传递信息，这是计算机安全存在的原因。」</h2><h3 id="CIA三元组："><a href="#CIA三元组：" class="headerlink" title="CIA三元组："></a>CIA三元组：</h3><ul><li><p>integrity 完整性 系统完整+数据完整</p></li><li><p>availability  可用性</p></li><li><p>confidentiality 机密性</p></li></ul><p>真实性；可追溯性 不被算在这之中</p><h3 id="6种安全服务"><a href="#6种安全服务" class="headerlink" title="6种安全服务"></a>6种安全服务</h3><ul><li><p>认证：</p><ul><li>1.在连接的初始化阶段，认证服务要保证两个实体是可信的 2. 保证连接不受第三方的干扰(在交互中，不能有第三方能伪装成合法的实体传输或接受信息)</li><li>包括对等实体认证(有连接) 和 数据源认证(通信实体在通信前没有预先交互(无连接))</li></ul></li><li><p>访问控制：限制和控制通过通信连接对主机与应用进行访问的能力。每个试图获得访问控制的实体在获取权限之前必须被识别&#x2F;认证</p></li><li><p>数据保密性(防止被动攻击)</p></li><li><p>数据完整性(防止主动攻击) 确保收到的消息 和 发送出的消息是一致的。(同时也保护数据被破坏)</p></li><li><p>不可否认性：防止发送或者接收方 否认传输&#x2F;收到过某条信息。 「也就是 接收方能证明发送方确实发送了消息，而发送方能证明接收方肯定收到了这条消息」</p></li><li><p>可用性服务：系统资源可以被授权实体访问或使用时 称系统是可用的。</p></li></ul><h3 id="安全攻击"><a href="#安全攻击" class="headerlink" title="安全攻击"></a>安全攻击</h3><h3 id="security-attack-分为被动攻击和主动攻击-OSI-ITU-T-X-800"><a href="#security-attack-分为被动攻击和主动攻击-OSI-ITU-T-X-800" class="headerlink" title="security attack 分为被动攻击和主动攻击 (OSI ITU-T X.800)"></a>security attack 分为被动攻击和主动攻击 (OSI ITU-T X.800)</h3><ul><li>被动攻击：试图了解或利用系统信息 但不影响系统资源 <ul><li>截获、监听都是被动攻击    除了利用信息还可以  流量分析「判断通信性质、判断主机身份和位置」</li><li>使用VPN(虚拟专用网)  加密网络来预防</li></ul></li><li>主动攻击：试图改变系统资源或者影响系统运作 篡改数据流 或制造虚假流 可以被检测<ul><li>假冒、重放、篡改、拒绝服务</li><li>不容易被有效防止</li></ul></li></ul><h3 id="security-mechanisms-安全机制-「加密、数字签名、访问控制、认证交换」"><a href="#security-mechanisms-安全机制-「加密、数字签名、访问控制、认证交换」" class="headerlink" title="security mechanisms 安全机制 「加密、数字签名、访问控制、认证交换」"></a>security mechanisms 安全机制 「加密、数字签名、访问控制、认证交换」</h3><h1 id="2-密码系统与古典密码"><a href="#2-密码系统与古典密码" class="headerlink" title="2. 密码系统与古典密码"></a>2. 密码系统与古典密码</h1><h3 id="5个部分-M-明文空间-｜-C-密文空间-｜-K密钥空间-｜-E-encryption-｜-D-decryption"><a href="#5个部分-M-明文空间-｜-C-密文空间-｜-K密钥空间-｜-E-encryption-｜-D-decryption" class="headerlink" title="5个部分: M 明文空间 ｜ C 密文空间 ｜ K密钥空间 ｜ E(encryption)｜ D(decryption)"></a>5个部分: M 明文空间 ｜ C 密文空间 ｜ K密钥空间 ｜ E(encryption)｜ D(decryption)</h3><ul><li><p>加密： E(M, K1) &#x3D; C</p></li><li><p>解密： D(C, K2) &#x3D; M        而D(E(M, K1), K2) &#x3D; M    对称加密时 K1 &#x3D; K2 公钥加密 K1 !&#x3D; K2</p></li></ul><p>(古典密码系统是不存在认证概念的)</p><blockquote><p>公钥加密：M &#x3D; D(E(M, pubkey), privatekey)</p><p>认证：M &#x3D; E(D(M, privatekey), pubkey)</p></blockquote><h3 id="密码分析-攻击难度由高至低-："><a href="#密码分析-攻击难度由高至低-：" class="headerlink" title="密码分析(攻击难度由高至低)："></a>密码分析(攻击难度由高至低)：</h3><ul><li>唯密文攻击 </li><li>已知明文攻击 (掌握一段密文以及其对应的明文)</li><li>选择明文攻击 (掌握加密机，可以对任意明文加密得到密文)</li><li>选择密文攻击(掌握解密机，可以对任意密文解密得到明文)</li><li>选择文本攻击</li></ul><h3 id="密码的安全性"><a href="#密码的安全性" class="headerlink" title="密码的安全性"></a>密码的安全性</h3><ul><li><p>无条件安全</p></li><li><p>计算上安全</p><ul><li>破译代价超过密文价值</li><li>破译时间超过生命周期</li></ul></li></ul><h4 id="古典密码的基本模块"><a href="#古典密码的基本模块" class="headerlink" title="古典密码的基本模块"></a>古典密码的基本模块</h4><ul><li>Substitution 代换(用其他符号代替) </li><li>Permutation 置换(得到类型不同的映射)</li></ul><h1 id="3-分组密码、AES、分组密码的工作模式"><a href="#3-分组密码、AES、分组密码的工作模式" class="headerlink" title="3. 分组密码、AES、分组密码的工作模式"></a>3. 分组密码、AES、分组密码的工作模式</h1><h4 id="分组密码的设计思想：-「扩散与混淆」"><a href="#分组密码的设计思想：-「扩散与混淆」" class="headerlink" title="分组密码的设计思想： 「扩散与混淆」"></a>分组密码的设计思想： 「扩散与混淆」</h4><ul><li>diffusion 扩散  「将明文冗余的分散到密文中，要实现这种思想 可以采用 <em>置换 permutation</em>」 (增加方程次数)</li><li>confusion 混淆 「防止统计分析攻击的方法。 通常使用 <em>代换 substitution</em>」(增加)</li></ul><blockquote><p>应当注意的是， 我认为分组密码和对称&#x2F;非对称密码是不同的分类，<strong>分组密码对应的是流密码</strong>。</p></blockquote><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><ul><li>分组长度必须 128 bit  密钥长度可为 128 196 256 bit 三种</li><li>密码需要加密N轮 轮数由密钥长度决定 16字节 $\rightarrow$ 10轮   24字节 $\rightarrow$ 12轮  32字节 $\rightarrow$ 14轮</li><li>加密时 前N-1轮是相同的4个步骤。而最后一轮只包含3个步骤(没有列混淆)，第一轮之前有一次轮密钥加</li><li>解密时 先进行一次轮密钥加  然后 逆向行移位、逆向字节代替、轮密钥加、逆向列混淆,最后一轮不进行列混淆</li><li>(以128为例)在最开始需要输入一个16字节密钥。输入的密钥被扩展成由 44个32位字(4bit) 组成的数组 w[i]。 10轮之中，每一轮搞4个w[i]数组作为这一轮的轮密钥。  扩展密钥 $\rightarrow$ 44个w[i]数组</li></ul><h4 id="AES的步骤"><a href="#AES的步骤" class="headerlink" title="AES的步骤"></a>AES的步骤</h4><ol><li><p>字节代换 ByteSubstitution  查表操作 4x4字节矩阵 Sbox则是 16x16的字节矩阵</p></li><li><p>行移位Shift Rows  第0行不动 第一行左移1字节，第二行左移2字节，第三行左移3字节</p></li><li><p>列混淆Mix Columns  给定一个特殊的可逆矩阵，每一列分别和矩阵相乘 得到的列替换掉原来的列 </p></li><li><p>轮密钥加  这个分组和扩展密钥中的4行   按位XOR</p></li></ol><p>(密钥扩展函数将产生N+1轮密钥，它们是互不相同的4x4矩阵，作为轮密钥加的输入)</p><h4 id="关于AES"><a href="#关于AES" class="headerlink" title="关于AES"></a>关于AES</h4><h4 id="AES可以构造-消息验证码-这时只使用了加密过程。-任何其他的分组密码也可以"><a href="#AES可以构造-消息验证码-这时只使用了加密过程。-任何其他的分组密码也可以" class="headerlink" title="AES可以构造 消息验证码 这时只使用了加密过程。(任何其他的分组密码也可以)"></a>AES可以构造 消息验证码 这时只使用了加密过程。(任何其他的分组密码也可以)</h4><hr><h3 id="分组密码工作模式-讨论-多组明文需要发送时如何选择密钥"><a href="#分组密码工作模式-讨论-多组明文需要发送时如何选择密钥" class="headerlink" title="分组密码工作模式    讨论 多组明文需要发送时如何选择密钥"></a>分组密码工作模式    讨论 多组明文需要发送时如何选择密钥</h3><ol><li><h4 id="电码本-ECB-相同的密钥分别对明文分组独立加密"><a href="#电码本-ECB-相同的密钥分别对明文分组独立加密" class="headerlink" title="电码本 ECB     相同的密钥分别对明文分组独立加密"></a>电码本 ECB     相同的密钥分别对明文分组独立加密</h4></li></ol><blockquote><p>因为每次用一样的，所以一样的明文自然对应一样的输出。</p></blockquote><ol start="2"><li><h4 id="密文分组链接-CBC-加密算法的输入是上一个密文组和自己这个明文组的异或"><a href="#密文分组链接-CBC-加密算法的输入是上一个密文组和自己这个明文组的异或" class="headerlink" title="密文分组链接 CBC  加密算法的输入是上一个密文组和自己这个明文组的异或"></a>密文分组链接 CBC  加密算法的输入是上一个密文组和自己这个明文组的异或</h4><blockquote><p> 面向分组的通用传输, 认证    意思就是 实际上加密的是上一个密文组和这个明文组的异或</p></blockquote></li></ol><blockquote><p>解密时 分别解密 然后和上一块密文异或就行了</p></blockquote><ol start="3"><li><h4 id="密文反馈-CFB-一次处理s位，上一块密文作为加密算法的输入，产生的伪随机数输出和明文异或作为下一单元的密文"><a href="#密文反馈-CFB-一次处理s位，上一块密文作为加密算法的输入，产生的伪随机数输出和明文异或作为下一单元的密文" class="headerlink" title="密文反馈 CFB 一次处理s位，上一块密文作为加密算法的输入，产生的伪随机数输出和明文异或作为下一单元的密文"></a>密文反馈 CFB 一次处理s位，上一块密文作为加密算法的输入，产生的伪随机数输出和明文异或作为下一单元的密文</h4><blockquote><p>面向数据流的通用传输 、 认证  </p><p>搞一个移位寄存器(因为加密每次需要128位，我们每次只要s位)  </p><p>拿128位加密，加密完成后只拿前s位 然后和明文异或 异或的结果再加入移位寄存器。</p></blockquote></li><li><h4 id="输出反馈-OFB"><a href="#输出反馈-OFB" class="headerlink" title="输出反馈 OFB"></a>输出反馈 OFB</h4><blockquote><p> 和CFB类似，加密算法的输入是上一次加密的输出，且使用整个分组</p></blockquote></li><li><h4 id="计数器-CTR"><a href="#计数器-CTR" class="headerlink" title="计数器 CTR"></a>计数器 CTR</h4><blockquote><p> 每个明文分组都与一个经过加密的计数器相异或。对每个后续分组计数器递增。 </p><p>明文还是和加密后的异或直接得到密文。但不链接各个明文！</p></blockquote></li></ol><p><a href="https://www.cnblogs.com/Terry-Wu/p/10314070.html">不同加密模式之间如何选择</a></p><p>《实用密码学》[Schneier,2003]一书中指出，不应使用ECB模式，而推荐使用CBC模式和CTR模式。</p><hr><h1 id="4-公钥密码学RSA-ECC-Ellptic-Curve-DSS"><a href="#4-公钥密码学RSA-ECC-Ellptic-Curve-DSS" class="headerlink" title="4. 公钥密码学RSA   ECC(Ellptic Curve) DSS"></a>4. 公钥密码学RSA   ECC(Ellptic Curve) DSS</h1><h3 id="提问：-与公私钥加密相比-对称加密又是建立在什么概念上的？"><a href="#提问：-与公私钥加密相比-对称加密又是建立在什么概念上的？" class="headerlink" title="提问： 与公私钥加密相比 对称加密又是建立在什么概念上的？"></a>提问： 与公私钥加密相比 对称加密又是建立在什么概念上的？</h3><blockquote><p>对一个对称加密来说  $E_k(M) &#x3D; C; D_k(C) &#x3D; M$</p><ul><li>加密与解密算法可以不同</li><li>对密钥K的使用方法可以不同</li></ul><p>对称密码<code>算法</code> 包括 </p><ul><li>分组加密 DES, AES, TEA, SM4</li><li>流密码 RC4, ZUC(中国4G国标)</li><li>哈希函数 SHA , SM3</li><li>消息认证码  CBC-MAC. AES-GCM. HMAC&#x2F;NMAC</li></ul></blockquote><h3 id="公钥密码学解决的问题-「加解密-密钥交换-和-数字签名」"><a href="#公钥密码学解决的问题-「加解密-密钥交换-和-数字签名」" class="headerlink" title="公钥密码学解决的问题 「加解密 密钥交换 和 数字签名」"></a>公钥密码学解决的问题 「加解密 密钥交换 和 数字签名」</h3><ul><li><p>加&#x2F;解密：发送方用接收方的公钥来加密 接收方用其私钥来解密</p></li><li><p>密钥交换：通信的双方交换会话密钥 「将使用一方或者双方的私钥」</p></li><li><p>数字签名：发送方用私钥对消息签名。(可以加密整个信息，也可以加密消息的一个小数据块，这个数据块是整条消息的函数(Hash))   注意数字签名因为用私钥加密, 会丧失保密性</p></li><li><p>但也可以先PR加密，再PU加密。 接收方就先用自己的私钥解密，再用发送方的公钥获取数字签名</p></li></ul><h3 id="其中RSA和ECC可以实现3种功能-Diffie-Hellman只能进行密钥交换-DSS只能进行数字签名"><a href="#其中RSA和ECC可以实现3种功能-Diffie-Hellman只能进行密钥交换-DSS只能进行数字签名" class="headerlink" title="其中RSA和ECC可以实现3种功能 Diffie-Hellman只能进行密钥交换   DSS只能进行数字签名"></a><em>其中RSA和ECC可以实现3种功能 Diffie-Hellman只能进行密钥交换   DSS只能进行数字签名</em></h3><h3 id="对公钥密码体制的要求"><a href="#对公钥密码体制的要求" class="headerlink" title="对公钥密码体制的要求"></a>对公钥密码体制的要求</h3><p> 产生一对密钥(公+私)是容易的。 发送方加密和接收方解密是容易的。 已知公钥PUb 不能确定私钥。  已知公钥PUb和密文C 不能恢复出明文M。 加解密函数可以互换顺序。</p><p> <em><strong>总结起来就是：加解密容易。公钥 $\rightarrow$ 私钥不可行。公钥+密文 $\rightarrow$ 明文不可行。  并且加密函数和解密函数最好可以交换(支持公钥加密 私钥解密)这条不是必须的</strong></em></p><h3 id="RSA-Rivest-Shamir-Adleman"><a href="#RSA-Rivest-Shamir-Adleman" class="headerlink" title="RSA Rivest-Shamir-Adleman"></a>RSA Rivest-Shamir-Adleman</h3><blockquote><p>明文和密文是 0-n-1之间的整数</p><p>n一般为 1024位二进制(309位10进制) </p></blockquote><h4 id="RSA的步骤"><a href="#RSA的步骤" class="headerlink" title="RSA的步骤"></a>RSA的步骤</h4><ol><li>两个大素数 p q   ，n &#x3D; p * q</li><li>phi(n) &#x3D; (p-1) * (q-1)</li><li>选一个和 phi(n) 互素的 e 作为公钥，d 则是 e mod phi(n)的逆元</li><li>e和n可以公开， d和p q 必须保密</li></ol><p>公钥{E, K}. 私钥{D, N};</p><h5 id="RSA的加解密"><a href="#RSA的加解密" class="headerlink" title="RSA的加解密"></a>RSA的加解密</h5><p>明文^e^ &#x3D; 密文 (mod n)</p><p>密文^d^ &#x3D; 明文 (mod n)</p><p><strong><u>大数因式分解的困难造就了RSA的安全性</u></strong></p><h3 id="我们为什么使用混合加密："><a href="#我们为什么使用混合加密：" class="headerlink" title="我们为什么使用混合加密："></a>我们为什么使用混合加密：</h3><blockquote><p>公钥密码的加解密比较慢，我们可以用公钥加密来加密密钥，对称加密来加密消息，接收方先用私钥解密出密钥然后再进行对称解密 (这里其实也一定程度上揭示了TLS和SSL的原理)</p></blockquote><hr><h1 id="Diffie-Hellman-密钥交换"><a href="#Diffie-Hellman-密钥交换" class="headerlink" title="Diffie-Hellman 密钥交换"></a>Diffie-Hellman 密钥交换</h1><ul><li><p>离散对数的计算困难造就了Diffie-Hellman的可行性</p></li><li><p>产生一个密钥，所以一般用在对称加密里</p></li></ul><h4 id="Diffie-Hellman预备知识："><a href="#Diffie-Hellman预备知识：" class="headerlink" title="Diffie-Hellman预备知识："></a>Diffie-Hellman预备知识：</h4><p>定义<em><strong>素数p的原根</strong></em>：一个整数，其幂可以产生1-p-1之间的所有整数</p><p>产生整数的原则是模运算   一共模p-1次</p><p>$a \space mod \space p\space |  \space \space a^2 \space mod  \space p  \space| \space a^3\space mod\space p\space …a^{p-1} \space mod\space p$</p><p>⚠️它们的顺序可以不是1-p-1，但是一定不能重复  </p><p>计算<code>离散对数</code>: 对于素数p和其原根a, 任意的  $b \equiv a^i \mod{m}$</p><p>计算出指数i 就是离散对数。</p><h3 id="在Diffie-Hellman中-素数q和原根a-是公开的这时A和B想要交换密钥，他们俩要分别选择一个小于素数q的数"><a href="#在Diffie-Hellman中-素数q和原根a-是公开的这时A和B想要交换密钥，他们俩要分别选择一个小于素数q的数" class="headerlink" title="在Diffie-Hellman中 素数q和原根a 是公开的这时A和B想要交换密钥，他们俩要分别选择一个小于素数q的数"></a>在Diffie-Hellman中 素数q和原根a 是公开的这时A和B想要交换密钥，他们俩要分别选择一个<strong>小于素数q的数</strong></h3><p>令它们分别为 XA 、XB(这两个是保持私有的)  利用原根a 算出YA和YB（这两个对另一方可见）</p><p>$用户A计算出：Y_A &#x3D; a^{X_A}\mod q$</p><p>$用户B计算出：Y_B &#x3D; a^{X_B}\mod q$</p><p>$用户A计算密钥K&#x3D;Y_B^{X_A}\mod q$</p><p>$用户B计算密钥K &#x3D; Y_A^{X_B}\mod q$</p><p>这两种计算的结果是一样的 这也就算是完成了密钥交换（两边的密钥是一样的）</p><p>几个例子：</p><ol><li><p>在知道q和a的情况下：用户A产生一个一次密钥XA，把自己算出的YA发给B，用户B则一样，并把自己算出的YB发给A，这样两边就都可以算出密钥K。并且在接下来的一段时间进行信息交互了。</p></li><li><p>LAN上的一组用户共用q和a，他们每个人都产生一个永久的X，并把自己的Y公开。任何一个用户就都可以发送消息给对方了。不能抗重播攻击。</p></li></ol><h3 id="攻击Diffie-Hellman"><a href="#攻击Diffie-Hellman" class="headerlink" title="攻击Diffie-Hellman"></a>攻击Diffie-Hellman</h3><ol><li><p>直接穷举</p><p>比如 q &#x3D; 353；a &#x3D; 3。XA &#x3D; 97, XB &#x3D; 233</p><p>这时 YA &#x3D; 3^97 mod 353 &#x3D; 40,  YB &#x3D; 3^233 mod 353 &#x3D; 248</p><p>K &#x3D; 248^97 mod 353 &#x3D; 40^233 mod 353 &#x3D; 160</p><p>攻击者知道：q &#x3D; 353， a &#x3D; 3， YA &#x3D; 40， YB &#x3D; 248</p><p>那么 解方程 3^a mod 353 &#x3D; 40, 或者 3^b mod 353 &#x3D; 248  就能找到XA或者XB，那么就相当于确定了密钥K</p><p>一个个试就完了</p></li><li><p>中间人攻击</p><p>A和B想交换密钥， q 和 a 已知。 <strong>现在C同时拦截了YA和YB，他生成XC1和XC2两个私钥，然后求出YC1和YC2，现在他将YC1和YC2分别给A和B，这样他和A就共享密钥K1，和B共享密钥K2，</strong>到这一步，攻击就已经奏效了。</p><p>接下来，C可以只窃听，也可以修改，并且A和B是无法解密对方的消息的，因为密钥K不对。</p><p><strong>Diffie- Hellman无法抵抗中间人攻击，因为没有认证机制。 <code>数字签名</code> <code> 公钥证书</code>可以克服这个问题</strong></p></li></ol><hr><h3 id="ECC-可以使用比RSA短的多的密钥得到相同的安全性-具体见Ellptic-Curve-pdf"><a href="#ECC-可以使用比RSA短的多的密钥得到相同的安全性-具体见Ellptic-Curve-pdf" class="headerlink" title="ECC 可以使用比RSA短的多的密钥得到相同的安全性  具体见Ellptic Curve.pdf"></a>ECC 可以使用比RSA短的多的密钥得到相同的安全性  具体见Ellptic Curve.pdf</h3><hr><h1 id="Hash-MAC"><a href="#Hash-MAC" class="headerlink" title="Hash&amp;MAC"></a>Hash&amp;MAC</h1><ul><li>Hash不是用来加密或解密的而是用来产生数字指纹或者进行消息认证</li><li>Hash的应用：消息认证「消息没有被修改等」｜数字签名｜单向口令文件｜入侵检测｜随机函数(PRF)&#x2F;伪随机数发生器(PRNG)</li><li>哈希函数的构造： 1. 分块 2. 填充 3. 迭代压缩</li></ul><h3 id="Hash提供消息认证时的几种情况：-由MAC来完成"><a href="#Hash提供消息认证时的几种情况：-由MAC来完成" class="headerlink" title="Hash提供消息认证时的几种情况：(由MAC来完成)"></a>Hash提供消息认证时的几种情况：(由MAC来完成)</h3><ol><li>使用对称密码加密消息和Hash码。 或者对无需保密性，<em><strong>只需要认证性的，可以只加密Hash码</strong></em></li><li>如果通信的双方已经共享了一个秘密值S，发送方可以将明文和S串联后计算Hash，接收方重新计算Hash。 这样可以不使用加密算法。当然 也可以再将整个消息和Hash值加密提供保密性。</li></ol><h4 id="Hash提供数字签名：-「知道公钥的人都可以通过数字签名验证消息完整性」"><a href="#Hash提供数字签名：-「知道公钥的人都可以通过数字签名验证消息完整性」" class="headerlink" title="Hash提供数字签名： 「知道公钥的人都可以通过数字签名验证消息完整性」"></a>Hash提供数字签名： 「知道公钥的人都可以通过数字签名验证消息完整性」</h4><ol><li>使用发送方PrivateKey 只对Hash码加密(又可签名又可认证) 。当然 也可以再用对称密码中的密钥加密。</li></ol><h3 id="Hash的安全要求"><a href="#Hash的安全要求" class="headerlink" title="Hash的安全要求"></a>Hash的安全要求</h3><ol><li>单向 「抗原像攻击」</li><li>弱抗碰撞性 给你一个x(是任意给的) 找到另一个x2 使得H(x) &#x3D; H(x2) 是不可行的 「抗第二原像攻击」</li><li>强抗碰撞性 寻找任意的 (x, x2)对 使得他们的H(x)相等不可行。   「参考生日悖论」</li><li>伪随机</li><li>高效</li></ol><h3 id="安全Hash算法-SHA系列"><a href="#安全Hash算法-SHA系列" class="headerlink" title="安全Hash算法   SHA系列"></a>安全Hash算法   SHA系列</h3><h3 id="SHA-512-输入小于-2-128位的消息，输出512位的消息摘要，输入的消息以1024bit-的分组进行处理。"><a href="#SHA-512-输入小于-2-128位的消息，输出512位的消息摘要，输入的消息以1024bit-的分组进行处理。" class="headerlink" title="SHA-512  输入小于 2^128位的消息，输出512位的消息摘要，输入的消息以1024bit 的分组进行处理。"></a>SHA-512  输入小于 2^128位的消息，输出512位的消息摘要，输入的消息以1024bit 的分组进行处理。</h3><ol><li>附加填充位</li><li>附加长度</li><li>初始化Hash缓冲区</li><li>处理消息并且输出</li></ol><h2 id="SHA-3-「Keccak」⚠️和SHA-512区分"><a href="#SHA-3-「Keccak」⚠️和SHA-512区分" class="headerlink" title="SHA-3 「Keccak」⚠️和SHA-512区分"></a>SHA-3 「Keccak」⚠️和SHA-512区分</h2><ul><li><p>海绵结构是Keccak使用的基本迭代结构。<strong>输入的消息 仍然是被分成固定长度的分组，每个分组逐次作为每轮迭代的输入，同时上一轮迭代的输出也会反馈至下一轮的迭代中，最终产生一组输出块。</strong></p></li><li><p>可以被看作轻量级密码(因为海绵函数允许输入和输出的长度都可变)，有着新的压缩函数(XOR AND NOT，没有查表和算术运算)</p></li><li><h4 id="海绵函数由-f-内部函数，每轮迭代中执行一次-包括置换和代替-r-输入分组的位长度，称其为位速率-pad-填充算法-为了保持格式一致，哪怕刚好整除，也会直接填充一个块"><a href="#海绵函数由-f-内部函数，每轮迭代中执行一次-包括置换和代替-r-输入分组的位长度，称其为位速率-pad-填充算法-为了保持格式一致，哪怕刚好整除，也会直接填充一个块" class="headerlink" title="海绵函数由 ƒ(内部函数，每轮迭代中执行一次 包括置换和代替)   r(输入分组的位长度，称其为位速率)   pad 填充算法(为了保持格式一致，哪怕刚好整除，也会直接填充一个块)"></a>海绵函数由 ƒ(内部函数，每轮迭代中执行一次 包括置换和代替)   r(输入分组的位长度，称其为位速率)   pad 填充算法(为了保持格式一致，哪怕刚好整除，也会直接填充一个块)</h4></li></ul><h4 id="Keccak的-Sponge-Structure-分为Absorbing和Squeezing-挤压"><a href="#Keccak的-Sponge-Structure-分为Absorbing和Squeezing-挤压" class="headerlink" title="Keccak的 Sponge Structure 分为Absorbing和Squeezing(挤压)"></a>Keccak的 Sponge Structure 分为Absorbing和Squeezing(挤压)</h4><ul><li>吸水：initialize state $\rightarrow$ XOR some of the message to the state $\rightarrow$ Apply compression function「调用压缩函数压缩」 （然后在XOR和压缩函数中不断往复）</li><li>状态变量s的长度为 b ，b &#x3D; r + c(r为每个分组的长度，c是容量)。 默认情况下，c &#x3D; 1024bit， r &#x3D; 576bit， 所以b &#x3D; 1600bit</li><li>状态变量的初始长度为0。吸水时：通过填充0，将分组的长度从r 扩展到b位 (加入c位的0) $\rightarrow$ 扩展后的消息分组，和s进行XOR得到b位，并且作为ƒ的输入。(ƒ的输出则作为下一轮迭代时s的取值)</li><li><strong>不是每个SHA-3都需要挤压。如果需要的输出长度 L 比 b(一个分组的长度)还要小，那么就不需要挤压了。直接返回前L位。</strong></li><li>挤压：Apply compression function  $\rightarrow$ Extract some output「提取部分输出」  （在这两个部分不断往复）</li><li>先在s中拿出前r位作为Z0，之后将s加入ƒ中进行运算，结果再取前r位。直到输出长度 &#x3D; L。</li><li>现在来讨论压缩函数ƒ  每次输入s的都是1600bit，我们把这1600bit分成5x5x64的矩阵，5x5作为面，64的称为纵。形成一个纵深64格的长方体。函数对矩阵执行24圈操作，每圈5个步骤，除了最后一步之外完全一样的</li><li>$R&#x3D;\theta<del>\rho</del>\pi<del>\chi</del>\iota$<ul><li><strong>theta：代替。每个字中都每一位的新值取决于当前值、其前一列的每个字的同一位、后一列的每个字的邻接位</strong></li><li><strong>rho ：置换。每个字的内部使用循环移位进行置换 向后移位。W[0, 0]不变。</strong></li><li><strong>pi：置换。字之间进行5x5矩阵的置换。W[0, 0]不变</strong></li><li><strong>chi：代替。每个字中的每一位的新值取决于当前值、相同行下一个字的对应位的值、相同行的下下一个字的对应位的值。</strong></li><li><strong>iota：代替。W[0, 0]和圈常数进行XOR运算。</strong></li><li><strong>其中： theta步实现的扩散非常明显</strong></li></ul></li></ul><hr><h2 id="报文认证码-消息认证码-："><a href="#报文认证码-消息认证码-：" class="headerlink" title="报文认证码(消息认证码) ："></a>报文认证码(消息认证码) ：</h2><blockquote><p>验证收到的消息确实来自真实的发送方，且没有被修改，并且顺序和时间正确。MAC是多对一函数</p><p>在网络通信中的攻击 这里的认证码不阻止被动攻击</p></blockquote><ul><li><p>消息认证防止：1. 伪装 2. 内容修改、顺序修改、时间修改(延时、重播)</p></li><li><p>在设计消息认证函数时 一般需要分层。底层负责产生认证符，而上层则指导验证消息真实性。 我们把消息认证符分为三类： Hash函数｜消息加密函数(整个消息加密后的密文作为认证符)｜消息认证码(消息和密钥的函数。产生定长的值作为认证符)</p></li><li><p>消息认证码(消息和密钥的函数 产生定长的值作为认证符 MAC &#x3D; C(K, M) 「C$\rightarrow$MAC函数」</p></li></ul><p>发送方把消息认证码和消息一起发送出去，接收方根据收到的消息以及密钥K<strong>再计算一次MAC(不是解密，是再加密然后比对)。</strong></p><h4 id="值得注意的是-双方共享密钥K，这使得MAC无法进行数字签名，MAC也不能防止顺序修改。而且，虽然与加密函数类似，但是MAC是不需要可逆的。-接收方和发送方实际上都是进行了加密操作-MAC也可以做PRNG"><a href="#值得注意的是-双方共享密钥K，这使得MAC无法进行数字签名，MAC也不能防止顺序修改。而且，虽然与加密函数类似，但是MAC是不需要可逆的。-接收方和发送方实际上都是进行了加密操作-MAC也可以做PRNG" class="headerlink" title="值得注意的是 双方共享密钥K，这使得MAC无法进行数字签名，MAC也不能防止顺序修改。而且，虽然与加密函数类似，但是MAC是不需要可逆的。(接收方和发送方实际上都是进行了加密操作) MAC也可以做PRNG"></a>值得注意的是 双方共享密钥K，这使得MAC无法进行数字签名，MAC也不能防止顺序修改。而且，虽然与加密函数类似，但是MAC是不需要可逆的。(接收方和发送方实际上都是进行了加密操作) MAC也可以做PRNG</h4><h4 id="对称加密其实是可以实现认证的-因为只有收发的双方持有密钥K-，但是它无法处理广播、明文认证和快速认证。并且消息在被解密之后就失去了认证性，而MAC则将认证和加密分离，并且可以维持认证性"><a href="#对称加密其实是可以实现认证的-因为只有收发的双方持有密钥K-，但是它无法处理广播、明文认证和快速认证。并且消息在被解密之后就失去了认证性，而MAC则将认证和加密分离，并且可以维持认证性" class="headerlink" title="对称加密其实是可以实现认证的(因为只有收发的双方持有密钥K)，但是它无法处理广播、明文认证和快速认证。并且消息在被解密之后就失去了认证性，而MAC则将认证和加密分离，并且可以维持认证性"></a>对称加密其实是可以实现认证的(因为只有收发的双方持有密钥K)，但是它无法处理广播、明文认证和快速认证。并且消息在被解密之后就失去了认证性，而MAC则将认证和加密分离，并且可以维持认证性</h4><p><strong>一般情况下 先认证 后加密更好一些，为什么更好一些？ 我也不知道。我觉得先加密后认证更好</strong></p><h4 id="MAC需要具有抗计算性：给定多对-message-MAC-对于新的message-计算出其MAC是不可行的"><a href="#MAC需要具有抗计算性：给定多对-message-MAC-对于新的message-计算出其MAC是不可行的" class="headerlink" title="MAC需要具有抗计算性：给定多对[message-&gt;MAC],对于新的message, 计算出其MAC是不可行的"></a>MAC需要具有抗计算性：给定多对[message-&gt;MAC],对于新的message, 计算出其MAC是不可行的</h4><h4 id="基于Hash的HMAC，但是SHA这样的Hash不需要密钥K，我们需要把密钥加入到现有的Hash方案里。HMAC在IP安全和其他Internet协议中-SSL-中使用"><a href="#基于Hash的HMAC，但是SHA这样的Hash不需要密钥K，我们需要把密钥加入到现有的Hash方案里。HMAC在IP安全和其他Internet协议中-SSL-中使用" class="headerlink" title="基于Hash的HMAC，但是SHA这样的Hash不需要密钥K，我们需要把密钥加入到现有的Hash方案里。HMAC在IP安全和其他Internet协议中(SSL)中使用"></a>基于Hash的HMAC，但是SHA这样的Hash不需要密钥K，我们需要把密钥加入到现有的Hash方案里。HMAC在IP安全和其他Internet协议中(SSL)中使用</h4><p>HMAC的描述如下：</p><ol><li>在密钥K左边填充0至b位，令其为K+。</li><li>K+和ipad进行位XOR，产生b位的分组Si。  「K的一半的信息位发生变化」</li><li>将M加在Si的后面(也是分组)，然后对它们进行Hash，得到一个Hash码。  「⚠️ 密钥放在了最前面」</li><li>K+和opad进行位XOR，产生b位的分组S0。 「K的另一半的信息位发生变化」</li><li>将步骤3中的Hash码加在S0的后面，然后再Hash一次就得到结果了。</li></ol><h3 id="基于分组密码的DAA和CMAC-AES、3DES适用"><a href="#基于分组密码的DAA和CMAC-AES、3DES适用" class="headerlink" title="基于分组密码的DAA和CMAC(AES、3DES适用)"></a>基于分组密码的DAA和CMAC(AES、3DES适用)</h3><p>DAA 数据认证算法：建立在DES之上，采用CBC。已经被证明不安全</p><h4 id="CMAC使用3个密钥，一个长度为k的K，用在密文分组链接的每一步，两个"><a href="#CMAC使用3个密钥，一个长度为k的K，用在密文分组链接的每一步，两个" class="headerlink" title="CMAC使用3个密钥，一个长度为k的K，用在密文分组链接的每一步，两个"></a>CMAC使用3个密钥，一个长度为k的K，用在密文分组链接的每一步，两个</h4><p>首先，消息长度是分组长度b(每个分组称为Mi)的整数倍时，对AES，b &#x3D; 128，有一个b位的常数K1。按照如下方式计算：</p><p>如果不是整数倍，则在最后一个分组的右边填充一个1和若干0使得它也是b长度。</p><p>C1 &#x3D; E(K, M1);</p><p>C2 &#x3D; E(K, [M2 xor C1]);</p><p>C3 &#x3D; E(K, [M3 xor C2]);</p><p>Cn &#x3D; E(K, [Mn xor Cn-1 xor K1])</p><p> $T &#x3D; MSB_{Tlen}(C_n)~~~~~~~T为消息认证码(tag)，MSB_s(X)-&gt;X最左边的s位$ </p><p>两个密钥K1，K2的长度都是b位，并且由密钥K(k位)导出 </p><p>$L &#x3D; E(K,~0^b); <del>K1 &#x3D; L·x;</del>K2 &#x3D; L·x^2&#x3D; L·x·x$</p><p>$乘法”·”在GF(2^b)内进行，所以说x对应b-2个0跟上10，x^2则是b-3个0跟上100$</p><hr><h4 id="认证加密-CCM-GCM"><a href="#认证加密-CCM-GCM" class="headerlink" title="认证加密 CCM &amp;GCM"></a>认证加密 CCM &amp;GCM</h4><p>认证加密AE指的是通信中实现保密性+认证性的加密系统。</p><ul><li>先Hash再加密：无线加密协议WEP中用来保护WIFI网络</li><li>先认证再加密 ：先计算MAC，T &#x3D; MAC(K1, M), 然后再把消息和MAC一起加密。(比如SSL)</li><li>先加密再认证： IP安全使用的就是这种。</li><li>独立进行加密和认证</li></ul><hr><h1 id="6-数字签名"><a href="#6-数字签名" class="headerlink" title="6. 数字签名"></a>6. 数字签名</h1><h2 id="提问：我们应该先加密后签名还是先签名后加密？"><a href="#提问：我们应该先加密后签名还是先签名后加密？" class="headerlink" title="提问：我们应该先加密后签名还是先签名后加密？"></a>提问：我们应该先加密后签名还是先签名后加密？</h2><p>A和B发送消息的过程中，假设B不使用其他安全措施的情况下，应该先签名后加密。(的确，先验签再解密更加方便，但这也给中间人攻击带来了可能。)</p><blockquote><p>具体的攻击方式非常简单：Oscar拦截A发给B的消息，然后对消息签名，并且把Alice的换掉就行了。 就这么简单。 所以先签名后加密更好</p></blockquote><h4 id="数字签名可以防止-发送方否认。-但是接收方否认不行，需要用到协议。"><a href="#数字签名可以防止-发送方否认。-但是接收方否认不行，需要用到协议。" class="headerlink" title="数字签名可以防止 发送方否认。   但是接收方否认不行，需要用到协议。"></a>数字签名可以防止 发送方否认。   但是接收方否认不行，需要用到协议。</h4><h4 id="在MAC中-或者任何对称加密-，双方共享一个密钥，这也意味着接收方可以直接伪造出一条来自发送方的消息。而如果接收方可以伪造发送发发出的消息，那么发送方自然也可以就任何消息否认是自己发出的。｜数字签名就是为了解决发送双方不互信时的情况"><a href="#在MAC中-或者任何对称加密-，双方共享一个密钥，这也意味着接收方可以直接伪造出一条来自发送方的消息。而如果接收方可以伪造发送发发出的消息，那么发送方自然也可以就任何消息否认是自己发出的。｜数字签名就是为了解决发送双方不互信时的情况" class="headerlink" title="在MAC中(或者任何对称加密)，双方共享一个密钥，这也意味着接收方可以直接伪造出一条来自发送方的消息。而如果接收方可以伪造发送发发出的消息，那么发送方自然也可以就任何消息否认是自己发出的。｜数字签名就是为了解决发送双方不互信时的情况"></a>在MAC中(或者任何对称加密)，双方共享一个密钥，这也意味着接收方可以直接伪造出一条来自发送方的消息。而如果接收方可以伪造发送发发出的消息，那么发送方自然也可以就任何消息否认是自己发出的。｜数字签名就是为了解决发送双方不互信时的情况</h4><h4 id="数字签名的特征：-「它一般也同时有认证性，必须得是-确认发送方身份的同时确认消息未被修改」-相当于覆盖了消息认证码的内容"><a href="#数字签名的特征：-「它一般也同时有认证性，必须得是-确认发送方身份的同时确认消息未被修改」-相当于覆盖了消息认证码的内容" class="headerlink" title="数字签名的特征： 「它一般也同时有认证性，必须得是 确认发送方身份的同时确认消息未被修改」(相当于覆盖了消息认证码的内容&#x3D; &#x3D;)"></a>数字签名的特征： 「它一般也同时有认证性，必须得是 确认发送方身份的同时确认消息未被修改」(相当于覆盖了消息认证码的内容&#x3D; &#x3D;)</h4><ol><li><h4 id="能验证签名者、签名日期-时间"><a href="#能验证签名者、签名日期-时间" class="headerlink" title="能验证签名者、签名日期+时间"></a>能验证签名者、签名日期+时间</h4></li><li><h4 id="能认证被签名的消息内容"><a href="#能认证被签名的消息内容" class="headerlink" title="能认证被签名的消息内容"></a>能认证被签名的消息内容</h4></li><li><h4 id="能被第三方仲裁。"><a href="#能被第三方仲裁。" class="headerlink" title="能被第三方仲裁。"></a>能被第三方仲裁。</h4></li></ol><h3 id="针对数字签名的攻击："><a href="#针对数字签名的攻击：" class="headerlink" title="针对数字签名的攻击："></a>针对数字签名的攻击：</h3><ol><li><h5 id="唯密钥攻击：C知道A的公钥"><a href="#唯密钥攻击：C知道A的公钥" class="headerlink" title="唯密钥攻击：C知道A的公钥"></a>唯密钥攻击：C知道A的公钥</h5></li><li><h5 id="已知消息攻击：C掌握一些消息对应的合法签名。"><a href="#已知消息攻击：C掌握一些消息对应的合法签名。" class="headerlink" title="已知消息攻击：C掌握一些消息对应的合法签名。"></a>已知消息攻击：C掌握一些消息对应的合法签名。</h5></li><li><h4 id="一般选择-定向选择消息攻击：C对选定的消息在A处获取合法签名，并攻击A的签名方案。-前面那种是先选择消息获得签名，再获得公钥。后面的则是先获得公钥，再选择消息生成签名"><a href="#一般选择-定向选择消息攻击：C对选定的消息在A处获取合法签名，并攻击A的签名方案。-前面那种是先选择消息获得签名，再获得公钥。后面的则是先获得公钥，再选择消息生成签名" class="headerlink" title="一般选择&#x2F;定向选择消息攻击：C对选定的消息在A处获取合法签名，并攻击A的签名方案。(前面那种是先选择消息获得签名，再获得公钥。后面的则是先获得公钥，再选择消息生成签名)"></a>一般选择&#x2F;定向选择消息攻击：C对选定的消息在A处获取合法签名，并攻击A的签名方案。(前面那种是先选择消息获得签名，再获得公钥。后面的则是先获得公钥，再选择消息生成签名)</h4></li><li><h4 id="适应性选择消息攻击：允许C将A作为“oracle”轮询，A需要给出对于特定消息的签名，而它们可能和C之前已经获得-消息-rightarrow-签名-对有关。"><a href="#适应性选择消息攻击：允许C将A作为“oracle”轮询，A需要给出对于特定消息的签名，而它们可能和C之前已经获得-消息-rightarrow-签名-对有关。" class="headerlink" title="适应性选择消息攻击：允许C将A作为“oracle”轮询，A需要给出对于特定消息的签名，而它们可能和C之前已经获得[消息$\rightarrow$签名]对有关。"></a>适应性选择消息攻击：允许C将A作为“oracle”轮询，A需要给出对于特定消息的签名，而它们可能和C之前已经获得[消息$\rightarrow$签名]对有关。</h4></li><li><h4 id="同时C也有一定概率完成以下的攻击：1-完全破译-判断出私钥-2-通用伪造-掌握某种签名算法，任意消息都能造出一样的签名-3-选择伪造：对于特定消息能伪造合法签名-4-存在性伪造：至少能伪造出一个消息的合法签名，但不能控制该消息的选择。"><a href="#同时C也有一定概率完成以下的攻击：1-完全破译-判断出私钥-2-通用伪造-掌握某种签名算法，任意消息都能造出一样的签名-3-选择伪造：对于特定消息能伪造合法签名-4-存在性伪造：至少能伪造出一个消息的合法签名，但不能控制该消息的选择。" class="headerlink" title="同时C也有一定概率完成以下的攻击：1. 完全破译(判断出私钥) 2. 通用伪造(掌握某种签名算法，任意消息都能造出一样的签名)  3. 选择伪造：对于特定消息能伪造合法签名  4. 存在性伪造：至少能伪造出一个消息的合法签名，但不能控制该消息的选择。"></a>同时C也有一定概率完成以下的攻击：1. 完全破译(判断出私钥) 2. 通用伪造(掌握某种签名算法，任意消息都能造出一样的签名)  3. 选择伪造：对于特定消息能伪造合法签名  4. 存在性伪造：至少能伪造出一个消息的合法签名，但不能控制该消息的选择。</h4></li></ol><h4 id="对数字签名的要求："><a href="#对数字签名的要求：" class="headerlink" title="对数字签名的要求："></a>对数字签名的要求：</h4><ol><li>必须是和消息相关的二进制串</li><li>必须使用发送方独有的信息。 防止伪造和否认</li><li>产生签名、识别和验证签名都比较容易。 并且可以保存数字签名的副本。</li><li>伪造数字签名 「从数字签名伪造消息，从消息伪造数字签名  都不可行」</li></ol><h3 id="ElGamal数字签名方案"><a href="#ElGamal数字签名方案" class="headerlink" title="ElGamal数字签名方案"></a>ElGamal数字签名方案</h3><p>同样用到原根。 p 和 a</p><h5 id="ElGamal的加密方案和Diffie很像。同样生产随机整数XA-其范围是1～q-1-不取q-1"><a href="#ElGamal的加密方案和Diffie很像。同样生产随机整数XA-其范围是1～q-1-不取q-1" class="headerlink" title="ElGamal的加密方案和Diffie很像。同样生产随机整数XA,  其范围是1～q-1 (不取q-1)"></a>ElGamal的加密方案和Diffie很像。同样生产随机整数XA,  其范围是1～q-1 (不取q-1)</h5><h5 id="XA作为A的PriKey，计算Y-A-a-XA-mod-q-A的PubKey-q，a，YA-，"><a href="#XA作为A的PriKey，计算Y-A-a-XA-mod-q-A的PubKey-q，a，YA-，" class="headerlink" title="XA作为A的PriKey，计算Y A &#x3D; a ^ XA  mod q  , A的PubKey {q，a，YA}，"></a>XA作为A的PriKey，计算Y A &#x3D; a ^ XA  mod q  , A的PubKey {q，a，YA}，</h5><h4 id="为了对消息签名，-A首先计算-m-H-M-同时要求m是小于等于q-1的整数。-然后A通过如下步骤产生数字签名："><a href="#为了对消息签名，-A首先计算-m-H-M-同时要求m是小于等于q-1的整数。-然后A通过如下步骤产生数字签名：" class="headerlink" title="为了对消息签名， A首先计算 m &#x3D; H(M) 同时要求m是小于等于q-1的整数。 然后A通过如下步骤产生数字签名："></a>为了对消息签名， A首先计算 m &#x3D; H(M) 同时要求m是小于等于q-1的整数。 然后A通过如下步骤产生数字签名：</h4><ol><li><h4 id="随机选择整数K，1"><a href="#随机选择整数K，1" class="headerlink" title="随机选择整数K，1&lt;&#x3D; K &lt;&#x3D; q-1 并且gcd(K, q-1) &#x3D; 1"></a>随机选择整数K，1&lt;&#x3D; K &lt;&#x3D; q-1 并且gcd(K, q-1) &#x3D; 1</h4></li><li><h4 id="计算-S1-a-K-mod-q-然后计算K-1-mod-q-1-K模q-1的逆元-）"><a href="#计算-S1-a-K-mod-q-然后计算K-1-mod-q-1-K模q-1的逆元-）" class="headerlink" title="计算$S1 &#x3D; a^K\mod q~~然后计算K^{-1}\mod {q-1}(K模q-1的逆元)）$"></a>计算$S1 &#x3D; a^K\mod q~~然后计算K^{-1}\mod {q-1}(K模q-1的逆元)）$</h4></li><li><h4 id="计算出-S2-K-1-m-X-AS1-mod-q-1"><a href="#计算出-S2-K-1-m-X-AS1-mod-q-1" class="headerlink" title="计算出$S2 &#x3D; K^{-1}(m - X_AS1)\mod (q-1)$"></a>计算出$S2 &#x3D; K^{-1}(m - X_AS1)\mod (q-1)$</h4></li><li><p>签名就是 (S1,  S2) 组成的</p></li></ol><h4 id="对于任何一个用户B来说，他可以这样验证签名："><a href="#对于任何一个用户B来说，他可以这样验证签名：" class="headerlink" title="对于任何一个用户B来说，他可以这样验证签名："></a>对于任何一个用户B来说，他可以这样验证签名：</h4><ol><li><h4 id="计算-V1-a1-m-mod-q，-V2-Y-A-S1-·S1-S2-mod-q-如果说V1-V2，则签名合法。"><a href="#计算-V1-a1-m-mod-q，-V2-Y-A-S1-·S1-S2-mod-q-如果说V1-V2，则签名合法。" class="headerlink" title="计算$V1&#x3D;a1^m \mod q，~V2 &#x3D; (Y_A^{S1}·S1^{S2} \mod q)$   如果说V1 &#x3D; V2，则签名合法。"></a>计算$V1&#x3D;a1^m \mod q，~V2 &#x3D; (Y_A^{S1}·S1^{S2} \mod q)$   如果说V1 &#x3D; V2，则签名合法。</h4></li></ol><h3 id="Schnorr-数字签名方案"><a href="#Schnorr-数字签名方案" class="headerlink" title="Schnorr 数字签名方案"></a>Schnorr 数字签名方案</h3><p>同样也是基于离散对数</p><h3 id="DSA-数字签名算法-同样是基于离散对数"><a href="#DSA-数字签名算法-同样是基于离散对数" class="headerlink" title="DSA 数字签名算法  同样是基于离散对数"></a>DSA 数字签名算法  同样是基于离散对数</h3><p>使用安全Hash (SHA) 最新版本还包括基于RSA和椭圆曲线密码的数字签名算法</p><h4 id="DSA使用的是-只提供数字签名功能的算法。虽然是一种公钥密码方案，但不能用来加密或者密钥交换"><a href="#DSA使用的是-只提供数字签名功能的算法。虽然是一种公钥密码方案，但不能用来加密或者密钥交换" class="headerlink" title="DSA使用的是 只提供数字签名功能的算法。虽然是一种公钥密码方案，但不能用来加密或者密钥交换"></a>DSA使用的是 只提供数字签名功能的算法。虽然是一种公钥密码方案，但不能用来加密或者密钥交换</h4><h6 id="RSA和DSA在实现数字签名时的不同结构"><a href="#RSA和DSA在实现数字签名时的不同结构" class="headerlink" title="RSA和DSA在实现数字签名时的不同结构"></a><em><strong>RSA和DSA在实现数字签名时的不同结构</strong></em></h6><h4 id="在DSA中，k是随机数，签名函数-Sig-依赖于-发送方的私钥PRa-和通信伙伴们一起构建的参数，我们称其为全局公钥PUG。"><a href="#在DSA中，k是随机数，签名函数-Sig-依赖于-发送方的私钥PRa-和通信伙伴们一起构建的参数，我们称其为全局公钥PUG。" class="headerlink" title="在DSA中，k是随机数，签名函数(Sig)依赖于 发送方的私钥PRa 和通信伙伴们一起构建的参数，我们称其为全局公钥PUG。"></a>在DSA中，k是随机数，签名函数(Sig)依赖于 发送方的私钥PRa 和通信伙伴们一起构建的参数，我们称其为全局公钥PUG。</h4><h4 id="签名由两部分组成，标记为s和r。"><a href="#签名由两部分组成，标记为s和r。" class="headerlink" title="签名由两部分组成，标记为s和r。"></a>签名由两部分组成，标记为s和r。</h4><h4 id="接收方对收到的消息进行Hash-产生的Hash码和签名-一起输入到验证函数-Ver-。如果说函数的输出-r-部分，则签名有效。"><a href="#接收方对收到的消息进行Hash-产生的Hash码和签名-一起输入到验证函数-Ver-。如果说函数的输出-r-部分，则签名有效。" class="headerlink" title="接收方对收到的消息进行Hash 产生的Hash码和签名 一起输入到验证函数(Ver) 。如果说函数的输出&#x3D; r 部分，则签名有效。"></a>接收方对收到的消息进行Hash 产生的Hash码和签名 一起输入到验证函数(Ver) 。如果说函数的输出&#x3D; r 部分，则签名有效。</h4>]]></content>
    
    
    <categories>
      
      <category>Computer security</category>
      
      <category>Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ComSec &amp; Crypto 综述</title>
    <link href="/2021/11/24/ComSec&amp;Crypto%20%E7%BB%BC%E8%BF%B0/"/>
    <url>/2021/11/24/ComSec&amp;Crypto%20%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Symmetric-Ciphers"><a href="#Symmetric-Ciphers" class="headerlink" title="Symmetric Ciphers"></a>Symmetric Ciphers</h1><h3 id="Symmetric-Cipher-Model-对称算法模型"><a href="#Symmetric-Cipher-Model-对称算法模型" class="headerlink" title="Symmetric Cipher Model 对称算法模型"></a>Symmetric Cipher Model 对称算法模型</h3><h5 id="对于对称算法来说重要的概念"><a href="#对于对称算法来说重要的概念" class="headerlink" title="对于对称算法来说重要的概念"></a>对于对称算法来说重要的概念</h5><blockquote><p>Plaintext 明文</p><p>Encryption algorithm 加密算法</p><p>Secret key </p><p>Ciphertext 密文</p><p>Decryption algorithm 解码算法 $\rightarrow$ 本质上是加密算法的reverse 从密文中获取明文</p></blockquote><h5 id="对于传统的起保护作用的加密算法有两个需要"><a href="#对于传统的起保护作用的加密算法有两个需要" class="headerlink" title="对于传统的起保护作用的加密算法有两个需要"></a>对于传统的起保护作用的加密算法有两个需要</h5><ol><li>我们需要一个强大的加密算法 最少 需要当你的对手<em><strong>知道你的算法并且能获得一个以上密文</strong></em> 的情况下也无法获得密钥或者破译密文。</li><li>发送方和接收方都需要有密钥的副本并且需要保证密钥的安全。如果对手知道你的算法并获取了你的密钥，那么使用这个密钥加密的对话会对其透明。</li></ol><h5 id="对称加密模型"><a href="#对称加密模型" class="headerlink" title="对称加密模型"></a>对称加密模型</h5><p>X 代表明文 K代表密钥 </p><p>For encryption, a key of the form $K &#x3D; [k1,k2,…kj]$ is generated, if the key is generated at the meesage source then it must also be provided to the destination by means of some secure channel.Alternatively, a third party could generate the key and securely deliver it to both source and destination</p><blockquote><p>在编码端 密钥被产出，并安全的递送给接收端。(也可以让第三方接手)</p></blockquote><p>Y 代表密文 </p><p>其中 $Y &#x3D; E(K,X)$, </p><blockquote><p>表示编码算法E 将明文X用K加密，得到密文Y</p></blockquote><p>在信道里，想要，并且<strong>持有密钥</strong>的接收者，能够逆转这个信息</p><p>$X &#x3D; D(K,Y)$</p><blockquote><p>表示解码算法D 将密文Y用K解码， 得到明文X</p></blockquote><p>**<u><em>对刚刚的模型，在密码分析的角度(攻破密码) Cryptanalyst(图的上方)</em></u>**：</p><p>相反，得到Y 但没有X或者K，并且想要得到X或者K或都要。并且 我们假定 <strong>你的对手持有加密算法E和解码算法D</strong></p><p>如果只想要这一个密文的内容，就要分析X，如果想要阅读之后的消息，则需要恢复出密钥K。</p><h5 id="密码学-Cryptography"><a href="#密码学-Cryptography" class="headerlink" title="密码学 Cryptography"></a>密码学 Cryptography</h5><p>密码学有着以下的3个独立的维度</p><blockquote><ol><li>The type of operations used for transforming plaintext to ciphertext</li></ol></blockquote><p>所有的编码算法都基于两种原理 ：</p><p><strong>substitution</strong> 替换，<strong>某个元素</strong>被替换成明文中其他的元素，相当于交换位置(<strong>不会出现明文里没有的元素</strong>)</p><p><strong>transposition</strong> 调换，将明文的元素重排 </p><p>这两种原理的特征就是$\Rightarrow$所有的操作都是可逆的(no info be lost)</p><blockquote><ol start="2"><li>The number of keys used</li></ol></blockquote><p>如果接收和发送双方都使用同样的密钥，这个密码系统偏向于传统加密算法(对称加密算法)。如果使用不同的密钥，则偏向于asymmetric(非对称的)或者公钥算法</p><blockquote><ol start="3"><li>The way in which the plaintext is processed (攻破密码系统)</li></ol></blockquote><p><em>Block Cipher</em> 分组密码 ：每次放入一组元素，一组一组的加密。</p><p><em>Stream Cipher</em> 流密码 ： 连续放入元素 一个个的加密。</p><hr><h1 id="公钥密码学"><a href="#公钥密码学" class="headerlink" title="公钥密码学"></a>公钥密码学</h1><h2 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h2><ul><li>1976年 Diffie和Hellman在 《密码学新方法》提出</li><li>使用 公钥和私钥 $\rightarrow$ 解密和加密并非对称</li><li>利用数论的方法。 补充了对称密码</li></ul><blockquote><p><strong>公钥密码的重要特点</strong></p><ul><li><strong>仅根据 密码算法 和 加密密钥 无法确定解密密钥</strong></li><li><strong>两个密钥中的任何一个可以加密 而另一个解密</strong></li></ul></blockquote><hr><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><ul><li>1977 来自MIT的 Rivest，Shamir &amp; Adleman</li><li>是最著名 应用最广泛的公钥加密体制</li><li><strong>明文和密文是 0-n-1 之间的整数，n的大小通常为 1024位 或者 309位十进制</strong></li></ul><h3 id="RSA描述"><a href="#RSA描述" class="headerlink" title="RSA描述"></a>RSA描述</h3><p>$加密： C &#x3D; M^e mod N, (0\leq M &lt;N ) $</p><p>$解密： M &#x3D; C^d mod N$</p><p>公钥$\rightarrow$ (e,N)   ; 私钥 $\rightarrow$ (d,N)</p><p>其中$M^{ed}&#x3D;MmodN$()</p><p>计算M^e 和 C^d 比较容易 ，但由e和n确定n 是不可行的</p><hr><h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><h2 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h2><ul><li><p>Hash 并不用来 encryption &#x2F; decryption 但在密码学中具有重要的价值</p></li><li><h3 id="Hash-函数：任意长度的报文-rightarrow-HASH-rightarrow-较短的-定长的-报文"><a href="#Hash-函数：任意长度的报文-rightarrow-HASH-rightarrow-较短的-定长的-报文" class="headerlink" title="Hash 函数：任意长度的报文 $\rightarrow$ HASH $\rightarrow$ 较短的 定长的 报文"></a>Hash 函数：任意长度的报文 $\rightarrow$ HASH $\rightarrow$ 较短的 定长的 报文</h3><ul><li><h3 id="即-h-H-M-M-is-variable-and-h-is-Hash-value"><a href="#即-h-H-M-M-is-variable-and-h-is-Hash-value" class="headerlink" title="即 h &#x3D; H(M) (M is variable and h is Hash value)"></a>即 h &#x3D; H(M) (M is variable and h is Hash value)</h3></li></ul></li><li><p>Hash函数的目的是为 报文等分组数据 产生 “数字指纹”</p></li></ul><h2 id="对Hash-函数的要求"><a href="#对Hash-函数的要求" class="headerlink" title="对Hash 函数的要求"></a>对Hash 函数的要求</h2><ul><li>H 可以用于任意大小的 数据分组 并且 一定产生定长输出</li><li>对于任意的 x，H(x) 要容易计算 (比AES更容易) </li><li><em><strong>单向性 ： 对于任意给定的码y， 寻求 x 使得 H(x) &#x3D; y 在计算上不可行 [即value $\Rightarrow$ key 不可行]</strong></em> </li><li><em><strong>弱抗碰撞性： 任意给定分组 x  寻求不等于x 的 x2 使得 H(x) &#x3D; H(x2) 在计算上不可行 (在班上找和某人 生日相同的人)</strong></em></li><li><em><strong>强抗碰撞性：找到任意一组 (x1, x2) 使得H(x1) &#x3D; H(x2) 在计算上不可行  (在一个班级找任意两个 生日相同的人)</strong></em><ul><li>碰撞 $\rightarrow$ 两个不等的 x  对应同一个 H(x) <strong>在安全学中 我们需求碰撞 不发生</strong></li></ul></li></ul><blockquote><h5 id="弱碰撞和强碰撞相比-强碰撞非常容易发生-与-生日悖论的原理相同-，-因为弱碰撞指定了x"><a href="#弱碰撞和强碰撞相比-强碰撞非常容易发生-与-生日悖论的原理相同-，-因为弱碰撞指定了x" class="headerlink" title="弱碰撞和强碰撞相比 强碰撞非常容易发生(与 生日悖论的原理相同)， 因为弱碰撞指定了x"></a>弱碰撞和强碰撞相比 强碰撞非常容易发生(与 生日悖论的原理相同)， 因为弱碰撞指定了x</h5></blockquote><h2 id="Keccak"><a href="#Keccak" class="headerlink" title="Keccak"></a>Keccak</h2><ul><li>使用了海绵结构 可以 被视为轻量级密码</li><li>压缩函数 只使用了 XOR ｜ ROT(移位)   无查表和算术运算 $\rightarrow$ 速度 更快</li></ul><h4 id="Sponge-construction"><a href="#Sponge-construction" class="headerlink" title="Sponge construction"></a>Sponge construction</h4><p>全0起手 每次吸收一个m</p><p>包括absorbing phase和Squeezing phase 「吸收和挤压阶段」</p><ul><li>algorithm Theta<ul><li>每个字中的每一位新的值 $\rightarrow$ 当前值 前一列每个字的相同位 后一列每个字的邻接位(移位)</li><li>对 C[x] &#x3D; XOR_i |L[x, i]|</li><li>L[x, y] &#x3D; L[x, y] XOR C[x - 1] XOR ROT(C[x + 1], 1)</li></ul></li><li>algorithm Rho<ul><li>除了L[0, 0]外 每个字的内部使用循环移位进行置换  移位值为 (t+1)(t+2)&#x2F;2 mod 64  「t 使得 [x, y] &#x3D; M^t *[1, 0]^T」  t不是移位值 是找移位值的根据</li></ul></li><li>algorithm Pi<ul><li>字之间进行5x5矩阵 置换 L[0,0] 不变</li><li>L[x, y] &#x3D; L[x1, y1]  其中(x, y ) &#x3D; M * (x1, y1);</li></ul></li><li>algorithm Chi<ul><li>每个字的 每一位新值 取决与 当前值 ｜ 同行的下一个字 的对应位 ｜ 相同行的下下个字的对应位 [循环]</li></ul></li></ul><hr><h1 id="About-MPC-Homomorphic-Encryption-CrypTen"><a href="#About-MPC-Homomorphic-Encryption-CrypTen" class="headerlink" title="About MPC, Homomorphic Encryption &amp; CrypTen"></a>About MPC, Homomorphic Encryption &amp; CrypTen</h1><h2 id="MPC-Secure-multi-party-computation"><a href="#MPC-Secure-multi-party-computation" class="headerlink" title="MPC   Secure multi-party computation"></a>MPC   Secure multi-party computation</h2><p>MPC的概念最初是由姚期智教授提出来的，Goldreich等人对其进行了深入研究，奠定了MPC的理论基础。Goldwasser与Cramer认为MPC是密码学中一个极其重要且强有力的工具。对于隐私数据共享的巨大需求使得MPC受到密码学界的高度重视并发展成为解决各种隐私保护问题的关键技术。</p><p>Multiparty Computation (MPC) is a research area within cryptography whose application is generally limited to preserving the privacy of participants to a conversation from each other, rather than to preventing eavesdropping by an outsider.</p><ul><li><p>MPC 用到的三种安全模型： 理想模型(全是好人) ，半诚实模型(不破坏规则，但会推理出额外信息)，恶意模型</p></li><li><p>在无可信第三方的情况下，如何安全的计算一个约定函数(这可能有点像diffie Hellman)</p></li><li><p>Zero-Knowledge Proof 不向验证者提供有效信息的情况下使验证者相信你的论断</p></li><li><p>differential privacy 差分隐私 「利用噪声来实现安全(计算上安全)，而非加密手段」</p></li></ul><p>可以拿出以下这个例子： 两个百万富翁比财产(他们不想让任何人知道自己有多少钱)</p><p>假设两人的财富都是1kw ～ 10kw  拿来10个编号的箱子，编号代表kw数(比如3kw 就是3号箱)，甲会对这10个箱子，每一个的编号对应的钱数 少于自己的 放入苹果，和自己一样的，放入香蕉，多于自己的，放入梨。 然后将10个箱子寄给乙。 乙选出自己对应财富的箱子，并销毁其他的箱子和编号。  这时打开箱子，甲和乙就能知道谁更富有。</p><p>「这个例子 基于半诚实模型，同时也有<code>不经意传输 Obivious Transfer</code>的影子, 即发送方向接收方发送信息中的一个部分，接收方可以正确的接收到信息，但不知道这个信息属于整体的哪个部分」</p><ul><li>MPC的两种应用形式： 外包计算 &#x2F; 多方计算   </li><li>MPC需要确保输入数据的独立性、传递数据的准确性、计算过程的正确性，同时不能将个人的隐私数据泄露给其他参与者。MPC主要是针对在没有可信第三方时保密计算所有参与者约定的一个函数的情况，它在数字签名、电子拍卖、秘密共享等场景中有着重要的作用。</li></ul><p>多方安全计算主要通过以下四大技术来进行保障:</p><p>（1）同态加密（Homomorphic Encryption，简称HE）<br>同态加密是一类具有特殊自然属性的加密方法， 可在密文域下进行数据运算的加密算法。 与一般加密算法相比， 同态加密除了能实现基本的加密操作之外， 还能实现密文间的多种计算功能， 即先计算后解密等价于先解密后计算。</p><p>（2）混淆电路（Garbled Circuit，简称GC）<br>混淆电路思想是利用计算机模拟集成电路的方式来实现多方安<br>全计算的， 它将运算任务转化为门电路的形式， 并且对每一条线路进行加密， 在很大程度上保障了用户的隐私安全。</p><p>（3）不经意传输（Oblivious Transfer，简称OT）</p><p>不经意传输协议是一种可保护隐私的秘密协议， 它使得服务发送方和服务接收方以不经意的方式交互信息， 从而可达到保护隐私的目的。 不经意传输协议是一个两方安全计算协议， 接收方从发送方的数据中选取部分数据， 协议使得接收方除选取的内容外， 对剩余数据一无所知， 并且发送方也无从知道被选取的内容。</p><p>（4） 秘密分享（Secret Sharing，简称SS）<br>秘密分享也被称为秘密分割， 是一种对秘密信息的管理方式， 它将秘密进行拆分， 拆分后的每一个分片由不同的参与者管理， 单个参与者无法恢复秘密信息， 需要超过一定门限数量的人一同协作进行合并才能恢复秘密文件。</p><hr><h2 id="Homomorphic-Encrytion"><a href="#Homomorphic-Encrytion" class="headerlink" title="Homomorphic Encrytion"></a><a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86">Homomorphic Encrytion</a></h2><p>对密文进行特定形式的代数运算后 仍然是加密的结果，这样解密得到的结果和明文进行同样的运算结果一样。 也就是说，这项技术能够在 数据加密的情况下进行诸如 检索、比较等操作，并且得出正确的结果。  这项技术的意义就 是从根本上解决数据被委托给第三方时的保密问题。  </p><p>同态加密在以往都只能实现部分操作，全同态加密的可行性是由09年 斯坦福大学的 Craig Gentry 的 <a href="https://www.cs.cmu.edu/~odonnell/hits09/gentry-homomorphic-encryption.pdf">《Fully Homomorphic encryption Using Ideal Lattices》</a>一文中，从数学角度上证明了全同态加密的可行性。</p><p>个人比较欣赏Gentry教授的定义，简明扼要的点出了其中的关键</p><blockquote><p> A way to delegate processing of your data, without giving away access to it.</p></blockquote><p>$指定运算符\Delta,加密算法E,解密算法D, 同态加密满足以下条件: E(x\Delta y)&#x3D;E(x)\Delta E(y)$</p><hr><h2 id="CrypTen"><a href="#CrypTen" class="headerlink" title="CrypTen"></a><a href="https://crypten.readthedocs.io/en/latest/">CrypTen</a></h2><p>隐藏&#x2F;获取明文：</p><blockquote><p>CrypTen支持两种分享类型：arithmetic（ArithmeticSharedTensor）和binary(BinarySharedTensor)。<br>通过cryptensor()方法构造的MPCTensor中默认使用arithmetic分享类型。其中ArithmeticSharedTensor中实现了“add”，“sub”，“mul”，“matmul”等方法。</p><p>明文获取：由于n方的PRZS.share的所有值相加为0。通过pytorch的reduce方式，sum所有节点的tensor.share即可恢复原始tensor。然后使用FixedPointEncoder将tensor解码</p></blockquote><p>模型加密</p><blockquote><p>CrypTen可以先读取pytorch的模型文件，将pytorch模型转化成onnx（Open Neural Network Exchange）文件，并进一步解读onnx文件来构造crypten_model（Graph类或是Module类。Graph继承Container，Container继承Module）调用crypten_model类即可完成对模型的各类操作。图2.3中的同态加密张量和安全加密张量还未实现或通过测试。图2.4演示了使用CrypTen加密模型的方法。</p></blockquote><p><a href="https://blog.csdn.net/u012386311/article/details/105264884?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2.pc_relevant_paycolumn_v3&utm_relevant_index=5">Crypten核心代码分析</a></p><p><a href="https://blog.csdn.net/u012386311/article/details/104650936">Crypten 环境变量配置</a></p>]]></content>
    
    
    <categories>
      
      <category>Computer security</category>
      
      <category>Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cryptography in Solidity</title>
    <link href="/2021/10/22/Cryptography-in-Solidity-Key-management,-encryption,-and-digital-signatures/"/>
    <url>/2021/10/22/Cryptography-in-Solidity-Key-management,-encryption,-and-digital-signatures/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.amazon.com/Solidity-Blueprint-Building-Decentralized-Applications/dp/B0BT1Y6FM3/ref=tmm_pap_swatch_0?_encoding=UTF8&qid=&sr="><strong>The Solidity Blueprint : A 21-Day Journey to Building Decentralized Applications</strong></a></p></blockquote><p>Smart contracts have become increasingly popular in recent years, providing a secure and decentralized way of executing transactions and agreements. Cryptography plays a crucial role in ensuring the security and privacy of these transactions. Solidity, the programming language used for writing smart contracts on the Ethereum blockchain, provides a number of built-in cryptographic functions and libraries for key management, encryption, and digital signatures. In this article, we will explore the importance of cryptography in Solidity smart contracts, the techniques and best practices for key management, encryption, and digital signatures, and the challenges and future developments in implementing cryptography in Solidity smart contracts.</p><h1 id="The-Importance-of-Cryptography-in-Smart-Contracts"><a href="#The-Importance-of-Cryptography-in-Smart-Contracts" class="headerlink" title="The Importance of Cryptography in Smart Contracts"></a>The Importance of Cryptography in Smart Contracts</h1><p>Cryptography is an essential component of smart contract technology. Smart contracts involve the execution of digital agreements and transactions on a decentralized blockchain network, where trust is established through cryptographic algorithms and protocols. Cryptography provides the security and privacy necessary to ensure that these agreements and transactions are tamper-proof and resistant to malicious attacks.</p><p>Cryptography allows for secure communication between parties, ensuring that data and information shared within a smart contract are protected from eavesdropping or interception. It also enables the secure storage of sensitive information, such as private keys, passwords, and other authentication credentials.</p><p>In addition to securing data, cryptography is also used for verifying the identity of parties involved in a smart contract, using digital signatures and public-key cryptography. This allows for the authentication of transactions and the non-repudiation of contracts, ensuring that parties cannot deny their involvement in a transaction.</p><p>Overall, cryptography is a fundamental part of smart contract technology, providing the security and trust needed for digital agreements and transactions to function on a decentralized blockchain network.</p><blockquote><p><a href="https://medium.com/@solidity101/step-by-step-guide-to-developing-a-calculator-with-solidity-27d05d4ebfa3"><strong>Step-by-Step Guide to Developing a Calculator with Solidity</strong></a></p></blockquote><h1 id="Key-Management-in-Solidity-Best-Practices-and-Techniques"><a href="#Key-Management-in-Solidity-Best-Practices-and-Techniques" class="headerlink" title="Key Management in Solidity: Best Practices and Techniques"></a>Key Management in Solidity: Best Practices and Techniques</h1><p>Key management is a critical aspect of cryptography in Solidity, as it involves the secure generation, storage, and use of cryptographic keys for encryption, decryption, and digital signature operations. Here are some best practices and techniques for key management in Solidity:</p><ol><li><strong>Secure Key Generation:</strong> Use a trusted random number generator to generate keys, and ensure that the key length is appropriate for the intended use. Avoid using predictable or weak keys that can be easily guessed or cracked.</li><li><strong>Secure Key Storage:</strong> Store keys in a secure and protected location, such as a hardware wallet or a trusted key management system. Never store keys in plaintext or in an easily accessible location.</li><li><strong>Key Rotation:</strong> Regularly rotate keys to reduce the risk of compromise and to ensure that old keys are no longer in use. Use a secure and auditable process for key rotation.</li><li><strong>Multi-Factor Authentication:</strong> Use multi-factor authentication to protect access to keys, such as a combination of a password, biometric authentication, or a hardware security module.</li><li><strong>Key Usage Policy:</strong> Define a clear and concise policy for key usage, including who has access to keys, how they can be used, and when they should be revoked or decommissioned.</li><li><strong>Key Recovery:</strong> Develop a plan for key recovery in case of loss or damage to keys, and ensure that the recovery process is secure and auditable.</li><li><strong>Regular Auditing:</strong> Regularly audit key usage and storage to identify any vulnerabilities or issues, and address them promptly.</li></ol><p>By following these best practices and techniques, key management in Solidity can be significantly improved, reducing the risk of compromise and ensuring the security and privacy of smart contracts and their associated transactions.</p><blockquote><p><a href="https://medium.com/@solidity101/solidity-security-pitfalls-best-practices-101-a9a64010310e"><strong>Solidity Security Pitfalls &amp; Best Practices : Developing Secure Smart Contracts on Ethereum</strong></a></p></blockquote><h1 id="Encryption-Techniques-for-Data-Protection-in-Solidity"><a href="#Encryption-Techniques-for-Data-Protection-in-Solidity" class="headerlink" title="Encryption Techniques for Data Protection in Solidity"></a>Encryption Techniques for Data Protection in Solidity</h1><p>Encryption is an important technique used in Solidity to protect sensitive data and information from unauthorized access and tampering. Here are some common encryption techniques used in Solidity for data protection:</p><ol><li><strong>Symmetric Encryption:</strong> This involves using the same key for both encryption and decryption of data. Solidity provides built-in libraries such as AES (Advanced Encryption Standard) and DES (Data Encryption Standard) for symmetric encryption.</li><li><strong>Asymmetric Encryption:</strong> This involves the use of two separate keys for encryption and decryption of data. Solidity provides built-in libraries such as RSA (Rivest-Shamir-Adleman) and Elliptic Curve Cryptography (ECC) for asymmetric encryption.</li><li><strong>Hashing:</strong> Hashing is a one-way function that takes in input data and produces a fixed-size output called a hash. Solidity provides built-in libraries such as SHA3 (Secure Hash Algorithm 3) for hashing, which is commonly used for password storage.</li><li><strong>Key Derivation:</strong> This involves deriving one or more secret keys from a single master key. Solidity provides built-in libraries such as PBKDF2 (Password-Based Key Derivation Function 2) for key derivation.</li><li><strong>Salting:</strong> Salting involves adding random data to the input data before hashing, to prevent pre-computed attacks. Solidity provides built-in libraries such as Keccak256 for salting.</li><li><strong>Encrypted Communication:</strong> This involves encrypting communication between parties using secure channels such as SSL (Secure Sockets Layer) or TLS (Transport Layer Security).</li></ol><p>By using these encryption techniques, data can be protected from unauthorized access and tampering in Solidity smart contracts, providing the security and privacy necessary for digital agreements and transactions to function on a decentralized blockchain network.</p><h1 id="Understanding-Digital-Signatures-in-Solidity"><a href="#Understanding-Digital-Signatures-in-Solidity" class="headerlink" title="Understanding Digital Signatures in Solidity"></a>Understanding Digital Signatures in Solidity</h1><p>Digital signatures are a critical component of cryptography in Solidity, as they provide a way for parties to authenticate transactions and verify the identity of the parties involved. Here is an overview of how digital signatures work in Solidity:</p><ol><li><strong>Key Pair Generation:</strong> A user generates a key pair consisting of a private key and a public key. The private key is kept secret, while the public key is shared with others.</li><li><strong>Signing:</strong> To sign a message or transaction, the user generates a hash of the message using a hashing algorithm such as SHA3, and then encrypts the hash using their private key.</li><li><strong>Verification:</strong> To verify the digital signature, the recipient of the message or transaction generates a hash of the message using the same hashing algorithm, and then decrypts the signature using the public key of the signer. If the decrypted signature matches the hash of the message, the signature is considered valid.</li></ol><p>Solidity provides built-in libraries such as ECDSA (Elliptic Curve Digital Signature Algorithm) and RSA for digital signature operations. Digital signatures in Solidity are used for a variety of purposes, such as verifying the authenticity of smart contracts, authenticating the origin of transactions, and ensuring non-repudiation of contracts.</p><p>Overall, digital signatures are a critical component of cryptography in Solidity, providing the security and trust necessary for digital agreements and transactions to function on a decentralized blockchain network.</p><h1 id="Securing-Transactions-in-Solidity-with-Cryptography"><a href="#Securing-Transactions-in-Solidity-with-Cryptography" class="headerlink" title="Securing Transactions in Solidity with Cryptography"></a>Securing Transactions in Solidity with Cryptography</h1><p>Securing transactions is a crucial aspect of developing decentralized applications in Solidity. Cryptography is an essential tool in achieving this security. Here are some key techniques for securing transactions in Solidity:</p><ol><li><strong>Nonce:</strong> A nonce is a unique identifier added to each transaction to ensure that it can only be processed once. Solidity has built-in libraries that allow developers to generate and manage nonces, such as the “nonce” property in the “Transaction” object.</li><li><strong>Gas Limit:</strong> A gas limit is a value that sets the maximum amount of gas a transaction can consume. Solidity provides developers with a way to set the gas limit for each transaction, preventing attackers from executing code that consumes excessive gas and causes the transaction to fail.</li><li><strong>Signature Verification:</strong> As discussed earlier, digital signatures provide a way to authenticate transactions and verify the identity of parties involved. Solidity provides built-in libraries for signature verification, allowing developers to authenticate transactions and verify the identity of parties involved in the transaction.</li><li><strong>Two-Factor Authentication:</strong> In some cases, two-factor authentication can be implemented to provide additional security. For example, a user may be required to enter a password or use a hardware token in addition to signing a transaction with their private key.</li><li><strong>Multi-Signature Contracts:</strong> Multi-signature contracts require the approval of multiple parties before a transaction can be executed. This can be implemented using smart contracts, allowing for more complex and secure transactions.</li></ol><p>By using these techniques, developers can secure transactions in Solidity, providing the security and trust necessary for digital agreements and transactions to function on a decentralized blockchain network.</p><h1 id="Solidity-Libraries-for-Cryptography-Available-Options-and-Their-Features"><a href="#Solidity-Libraries-for-Cryptography-Available-Options-and-Their-Features" class="headerlink" title="Solidity Libraries for Cryptography: Available Options and Their Features"></a>Solidity Libraries for Cryptography: Available Options and Their Features</h1><p>Solidity provides developers with built-in libraries and functions for implementing various cryptographic operations. Additionally, there are also third-party libraries that can be used for advanced cryptographic operations. Here are some of the most popular Solidity libraries for cryptography and their features:</p><ol><li><strong>Crypto:</strong> Solidity’s built-in “crypto” library provides functions for hashing, signature verification, and random number generation. It uses SHA3 as the default hashing algorithm.</li><li><strong>ECDSA:</strong> The Elliptic Curve Digital Signature Algorithm (ECDSA) is a widely used signature algorithm in blockchain technology. Solidity provides a built-in “ecrecover” function for signature verification using ECDSA.</li><li><strong>Gnosis Safe:</strong> Gnosis Safe is a popular smart contract library that provides a secure way to manage and execute transactions on the Ethereum network. It includes features such as multi-signature support, transaction history tracking, and configurable approval requirements.</li><li><strong>OpenZeppelin:</strong> OpenZeppelin is a popular library for building secure smart contracts on the Ethereum network. It includes various cryptography-related features, such as safe math operations, digital signatures, and role-based access control.</li><li><strong>Chainlink:</strong> Chainlink is an oracle network that provides secure and reliable off-chain data to smart contracts on the Ethereum network. It includes various cryptographic features, such as tamper-proofing data, and decentralized randomness generation.</li></ol><p>By leveraging these libraries, developers can implement robust and secure cryptography in their Solidity smart contracts, allowing for secure transactions and data protection on the decentralized blockchain network.</p><h1 id="Challenges-in-Implementing-Cryptography-in-Solidity-Smart-Contracts"><a href="#Challenges-in-Implementing-Cryptography-in-Solidity-Smart-Contracts" class="headerlink" title="Challenges in Implementing Cryptography in Solidity Smart Contracts"></a>Challenges in Implementing Cryptography in Solidity Smart Contracts</h1><p>While implementing cryptography in Solidity smart contracts provides a high level of security and trust, it also comes with several challenges. Here are some of the major challenges faced when implementing cryptography in Solidity smart contracts:</p><ol><li><strong>Gas Costs:</strong> Cryptographic operations are computationally expensive and can consume a large amount of gas in a Solidity smart contract. This can lead to higher transaction fees and slower contract execution times. Developers need to carefully consider the trade-off between security and gas efficiency when implementing cryptography in Solidity smart contracts.</li><li><strong>Key Management:</strong> The secure management of private keys is crucial for implementing cryptography in Solidity smart contracts. Developers need to implement secure key management practices, such as storing keys in hardware wallets, using multi-signature contracts, and setting appropriate access controls.</li><li><strong>Compatibility with Ethereum EVM:</strong> Solidity smart contracts must be compatible with the Ethereum Virtual Machine (EVM) to execute on the Ethereum network. This means that cryptographic libraries used in Solidity smart contracts must also be compatible with the EVM, which can limit the available options for cryptographic operations.</li><li><strong>Security Auditing:</strong> Implementing cryptography in Solidity smart contracts requires a high level of expertise in cryptography and smart contract development. Developers need to conduct rigorous security audits to ensure that the smart contract is free from vulnerabilities and exploits that could compromise the security of the contract.</li><li><strong>Regulatory Compliance:</strong> Cryptography and blockchain technology are subject to various regulatory frameworks, such as data protection and financial regulations. Developers need to ensure that their cryptography implementations in Solidity smart contracts comply with these regulations, which can vary by jurisdiction.</li></ol><p>By addressing these challenges, developers can implement secure and trustworthy cryptography in Solidity smart contracts, enabling decentralized applications to function securely and reliably on the blockchain network.</p><h1 id="Future-Developments-in-Cryptography-for-Solidity-Smart-Contracts"><a href="#Future-Developments-in-Cryptography-for-Solidity-Smart-Contracts" class="headerlink" title="Future Developments in Cryptography for Solidity Smart Contracts"></a>Future Developments in Cryptography for Solidity Smart Contracts</h1><p>As the blockchain industry continues to evolve, so do the cryptographic techniques used in Solidity smart contracts. Here are some future developments in cryptography for Solidity smart contracts:</p><ol><li><strong>Homomorphic Encryption:</strong> Homomorphic encryption is a technique that enables computations to be performed on encrypted data without the need for decryption. This can enable secure and private computation in Solidity smart contracts, allowing sensitive data to be processed without being exposed.</li><li><strong>Zero-Knowledge Proofs:</strong> Zero-knowledge proofs enable one party to prove the validity of a statement to another party without revealing any information beyond the validity of the statement. This can enable privacy-preserving smart contracts in Solidity, allowing users to execute transactions without revealing their underlying data.</li><li><strong>Multi-Party Computation:</strong> Multi-party computation (MPC) enables multiple parties to jointly compute a function without revealing their individual inputs. This can enable secure and trustless collaboration in Solidity smart contracts, allowing multiple parties to execute transactions without revealing their underlying data.</li><li><strong>Quantum-Resistant Cryptography:</strong> As quantum computing becomes more advanced, traditional cryptographic techniques may become vulnerable to attacks. Quantum-resistant cryptography is a developing field that aims to provide cryptographic techniques that are secure against attacks from quantum computers. Implementing quantum-resistant cryptography in Solidity smart contracts can provide long-term security against future threats.</li></ol><p>As the blockchain industry continues to mature, the development of new cryptographic techniques will play a critical role in enabling secure and trustworthy smart contracts in Solidity. By keeping up with these developments, developers can ensure that their smart contracts are future-proof and capable of adapting to new cryptographic techniques as they emerge.</p><h1 id="Examples-of-Cryptography-in-Real-World-Solidity-Applications"><a href="#Examples-of-Cryptography-in-Real-World-Solidity-Applications" class="headerlink" title="Examples of Cryptography in Real-World Solidity Applications"></a>Examples of Cryptography in Real-World Solidity Applications</h1><p>Cryptography is a fundamental aspect of Solidity smart contracts and plays a critical role in ensuring the security and trustworthiness of decentralized applications. Here are some examples of how cryptography is used in real-world Solidity applications:</p><ol><li><strong>Tokenization:</strong> Tokenization is a common use case for Solidity smart contracts and involves the creation of digital tokens that represent real-world assets. Cryptography is used to secure the token issuance process, prevent double-spending, and ensure the authenticity of the tokens.</li><li><strong>Decentralized Exchanges:</strong> Decentralized exchanges (DEXs) are platforms that allow users to trade cryptocurrencies without relying on centralized intermediaries. Cryptography is used to secure the exchange process, including the matching of orders, execution of trades, and settlement of funds.</li><li><strong>Identity Management:</strong> Cryptography is used to manage user identities in Solidity smart contracts, ensuring that users can securely and privately interact with decentralized applications. Techniques such as public-key cryptography and digital signatures are used to authenticate users and secure their transactions.</li><li><strong>Voting Systems:</strong> Cryptography is used to secure voting systems in Solidity smart contracts, ensuring that the voting process is secure, transparent, and tamper-proof. Techniques such as homomorphic encryption and zero-knowledge proofs are used to ensure the privacy and authenticity of votes.</li><li><strong>Supply Chain Management:</strong> Cryptography is used to secure supply chain management in Solidity smart contracts, ensuring that goods and assets are tracked securely and transparently. Techniques such as digital signatures and hash functions are used to authenticate and verify the provenance of goods and assets.</li></ol><p>These are just a few examples of how cryptography is used in real-world Solidity applications. As the blockchain industry continues to evolve, we can expect to see even more innovative uses of cryptography in Solidity smart contracts, enabling decentralized applications to function securely and reliably on the blockchain network.</p><h1 id="Legal-and-Regulatory-Considerations-for-Cryptography-in-Solidity-Smart-Contracts"><a href="#Legal-and-Regulatory-Considerations-for-Cryptography-in-Solidity-Smart-Contracts" class="headerlink" title="Legal and Regulatory Considerations for Cryptography in Solidity Smart Contracts"></a>Legal and Regulatory Considerations for Cryptography in Solidity Smart Contracts</h1><p>As Solidity smart contracts increasingly integrate cryptography, it’s important to consider the legal and regulatory implications of using these techniques. Here are some key considerations:</p><ol><li><strong>Data Protection Regulations:</strong> Cryptography is often used to protect data in Solidity smart contracts. However, depending on the jurisdiction, data protection regulations may place restrictions on the use of cryptography or require specific safeguards to be implemented. It’s important to ensure that any cryptography used in Solidity smart contracts complies with relevant data protection regulations.</li><li><strong>Export Control Regulations:</strong> The use of certain cryptographic techniques may be subject to export control regulations, which restrict the export of sensitive technologies to certain countries or individuals. Developers should ensure that any cryptography used in Solidity smart contracts complies with relevant export control regulations.</li><li><strong>Digital Signature Regulations:</strong> Some jurisdictions have specific regulations around the use of digital signatures, including requirements for the type of cryptographic algorithm used, the key length, and the use of trusted third parties. It’s important to ensure that any digital signatures used in Solidity smart contracts comply with relevant regulations.</li><li><strong>Liability and Legal Certainty:</strong> The use of cryptography in Solidity smart contracts can provide enhanced security and trustworthiness. However, it can also introduce additional legal and liability considerations, particularly in the event of a security breach or other issue. It’s important to ensure that the use of cryptography in Solidity smart contracts does not compromise legal certainty or create additional liability risks.</li><li><strong>Jurisdictional Considerations:</strong> The use of cryptography in Solidity smart contracts can create jurisdictional challenges, particularly when parties are located in different jurisdictions with different legal and regulatory frameworks. It’s important to ensure that any cryptography used in Solidity smart contracts is compatible with the legal and regulatory frameworks of all relevant jurisdictions.</li></ol><p>These are just a few of the legal and regulatory considerations that developers should keep in mind when integrating cryptography into Solidity smart contracts. By staying aware of these issues and working closely with legal experts, developers can ensure that their Solidity smart contracts comply with relevant laws and regulations while providing enhanced security and trustworthiness.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>In conclusion, cryptography is a vital component of smart contract security and privacy, and Solidity provides a comprehensive set of tools for key management, encryption, and digital signatures. However, implementing cryptography in Solidity smart contracts can be challenging, and it is important to follow best practices and stay up-to-date with the latest developments in the field. As the use of smart contracts continues to grow and evolve, we can expect to see continued innovation in cryptography for Solidity and other blockchain programming languages, as well as increased attention to legal and regulatory considerations surrounding the use of cryptography in decentralized systems.</p>]]></content>
    
    
    <categories>
      
      <category>Computer security</category>
      
      <category>Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rebirth</title>
    <link href="/2013/07/13/rebirth/"/>
    <url>/2013/07/13/rebirth/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>1</category>
      
      <category>2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>1</tag>
      
      <tag>2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CHECK IT OUT!</title>
    <link href="/1976/04/01/2022%20GameList/"/>
    <url>/1976/04/01/2022%20GameList/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="32fec178b72ab36f66a586ec1eb4365f48c9fa2ae6594165b5a681a923a3a264">52c2541be51f9a75d781c2b392e0fa40c74f96ee420d5a5e03a8e3450ce45855aacc9fad8177932af354dc8adb5bcb5b5ef4e55d3a3f590e29df78a04f565b335cf748281124e7fa8976d2dde1ba252695e6b37e0df4786ffb2b8d5e06da13b9f3abf9721c1e210a1020722b7073def6c6300c7c9de1decb0c75a94597ed513260bbd8235db973859734b705d0e808cbd4824ada86a322d8e121a3170e25ec386511673214905ab7c8dbe4771d478b56c92a011261f9f8823845138f63b301fa51f6ee09b90c906eadec51a6aede41766fe9a59f256f4c438a5685d14d63a5f1ca298b62788cd16eca0f810a8b60f4cf67f1ee2594ca28b15eddabbf4220a914ea487e8f2c9eced18dc452dd3598c408d97cedf15bfe75476f407749cbc75feb0a6d212267e18e87c117ba75613804e08e21e5cae7f4bfedea000afcfd7c8d85fc8a612d417ee217210c5b43034ce4c84781281bf752800f26296aa5a8fb288834d9816add51b6f91195db955986ca914798d1972f0535ef14541fae1e1d570db7bba42dff475f1e20a48c68bfede15077ecf86b6e4816cac178c649646510d12c1d1f62577d545f931f8bb63859a47118e7687a23ef2ea1a8b7db96f9c1e2b2c8c1bd20f68c9c2ace5f4cc4b3ff470ddc2cfda872469f681aa9b4a8366129467ace25035c05e032d6b0ece1c4865b5176088b8df72a53622e510f8188e6eeaaeeeeb20697c565cc7eb5cb8f449fa46306d19adb563a64dc30a9b0303349ff6dd3f5549eb11b0565facb8dc68d6d1372208477fd930678538d524528930486936c3b3b33ff754a89f45d988e8e7209a2977e29752ef52780ffbe0e7a18d582218738b8a71b543c0e8ec7cf1e98059a4e142eabbe6137459e469b7a7c0ec9d00040ba4895d91ab8f0d72fb9b538d83f7615e94988dee843e03806525c825fe32ed83f036c496b3085219288650c30b2f15be7c2e1666082e010716e98f5b34b7a0f4c53d0e7e75fc934208b24e18857c006d37c4d95d0d02486d7210bf351ce06600b5f0aa7dc0883b89c36dfc0e5a791ece21b49aa98fae00f07af1ec516c5904244fc131553b5bdc07dd6f7f02659387b03a3fe51c0dfc53f72fcd32973cbe7ccee7bfa7bbf2ea978619e881b8e3102fec232ec43d2c560286ad15cb42f65793d706fcbc3554d6d688d5410ffeb39bb976fe15530b32f49c4641212c87c985ff02f98ae16237e72b70841e8826081d8e3ebbed447e9474a5734723311cfc966e597096cfdbbe71729ed0606a3d43718a77cb29bc389fe7ea7f1aec45017daeabe8516ece2ab87ad3c0cd82c04b2dd0aedd2b0f201cc25c0545b21bcc34280a1cfef71c2abc7e162ef768b27d2ec3bc5345a930e12245e00e984360f433b097987bdfd93e3595b6243734b567f464709eb8673c6d67077dc544a78f2082123f84fa6f46a29dc329cfde6766b534bdec8a6b19f4b22ed970d5b124497d4287fc296bb8d403f6863c912b1fcdbd9f2b2ec18bf11cff067c9dc0bdc10177515b1e58599ad1cbd940d008584c2c59abf92af</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Deep Learning(Andrew Ng)</title>
    <link href="/1976/04/01/Deep%20Learning(Andrew%20Ng)/"/>
    <url>/1976/04/01/Deep%20Learning(Andrew%20Ng)/</url>
    
    <content type="html"><![CDATA[<ul><li>为什么整个机器学习都有数据依赖：<ul><li><code>维度诅咒</code> 如果只选取1个特征，假如选取10个数据即可接近真实情况，那么选取两个特征时 两个轴都需要达到10，所以同样的数据密度就需要100个数据，同理 n个不同的特征，就需要10^n^个数据，因此特征选取的数量是几何倍数级的。</li></ul></li><li>Representation Learning 表示学习<ul><li>主要目标是对数据进行降维 </li><li>传统机器学习方法是手工进行特征提取(hand-designed features) 而Representation Learning 则是自动进行特征提取。</li><li><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tp47y47dj21qs0e0mzb.jpg"></li></ul></li></ul><p>以房价预测为例</p><p>如果只用到一个神经元，假设输入size(x), 输出price(y)</p><p>$size \rightarrow O_{neuron} \rightarrow price$</p><p>if you got more feature(like walk ability or zip code), you can stack together these neurons and then you form a neuro network.</p><p> 诸如房价预测等方面，我们可以直接使用一般的神经网络模型(Standard NN)，在图像领域则一般使用CNN，而序列数据(音频、语言)一般则会使用RNN,   </p><hr><h2 id="从逻辑回归开始-神经元在做什么"><a href="#从逻辑回归开始-神经元在做什么" class="headerlink" title="从逻辑回归开始: 神经元在做什么"></a>从逻辑回归开始: 神经元在做什么</h2><ul><li>神经网络如何组织数据：</li><li>每张图片 $x$ 拉成一个np array, 然后作为一列, 所有的输入图片 竖排组成输入 $X$</li><li>每个label $y$ 作为一列，和输入图片一一对应，所有的label 竖排组成label $Y$</li></ul><h5 id="一个简单的问题："><a href="#一个简单的问题：" class="headerlink" title="一个简单的问题："></a>一个简单的问题：</h5><p>以猫的二分类问题为例，你需要提供这张图是🐱的概率。</p><p>最简单的方法就是令 <strong>$y^{(i)}<em>{pred} &#x3D;\sigma(w^Tx</em>{(i)} + b), \space(其中\sigma &#x3D; \frac{1}{1+e^{-x}})$</strong></p><p>这个方法利用了sigmoid函数来对预测值进行激活，最后的结果在0～1之间，接下来的使用中，我们是把这两步分开来进行的</p><p>可以考虑使用常见的平方损失：$L(y_{pred},y)&#x3D;\frac{1}{2}(y_{pred}-y)^2$</p><p>但这个方法的问题在于，在逻辑回归中可能出现多个局部最优，平方损失不能很好的让梯度下降找到全局最优。因此在逻辑回归中一般使用下面这种：</p><p>$L(y_{pred},y)&#x3D;-{ylog(y_{pred})+(1-y)(log(1-y_{pred}))}$</p><p>以二元分类问题为例，例如，当 y &#x3D; 1时, 那么 $L&#x3D;-log(y_{pred})$，显然$y_{pred}$的值越接近1，Loss的值就越接近0</p><p>而 y &#x3D; 0时, $L &#x3D; log(1-y_{pred})$，显然 $y_{pred}$的值越接近0，Loss的值就越接近0</p><blockquote><p>Loss func 与 Cost func</p><ul><li>Loss是对每个sample而言的，而则是Cost是全局的Loss</li><li>这也就是说Cost func可以被抽象为： $J(w,b)&#x3D;\frac{1}{m}\sum^{m}<em>{i&#x3D;1}L(y^{(i)}</em>{pred},y^{(i)})$</li><li>找到作为空间曲面的$J$的全局最小值就是我们的目标</li></ul></blockquote><blockquote><p>Gradient Descent的具体工作方式：</p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3oyn1q8g9j21780f475n.jpg" style="zoom:50%;" /><p>在这张图中，我们暂时忽略b并把W看作一个实数(这样就变成了二维的情况)，W :&#x3D; 表示的是一次迭代</p><p>当然，去掉b只是因为二维的图更加直观，实际上对于 $J(w,b)$的更新直接利用偏导完成：(学习率$\alpha$)</p><p><font color = 'red' font size = 5> $w:&#x3D;w-\alpha\frac{\part J(w,b)}{\part w} $</font></p><p> <strong><font color = 'red' font size = 5>$b:&#x3D;b-\alpha\frac{\part J(w,b)}{\part b}$</font></strong> </p></blockquote><blockquote><p>利用计算图理解Gradient Descent</p><p>假设： $J &#x3D; 3(a+bc)$,我们现在将这个式子的计算分解开来，令 $u&#x3D;bc,\space v&#x3D;a+u,\space J&#x3D;3v$，得到下图</p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3p053zmhcj210e08g3yy.jpg" style="zoom:60%;" /><p>当你给定一组(a, b, c)的值，前向传播 &#x3D;&gt; 计算结果</p><p>值得注意的是，我们关注的是: 改变(a, b, c)时, 最终的结果 J 将会改变多少，换言之，就是要研究 $\frac {\part J}{\part a}$、$\frac {\part J}{\part b}$、$\frac {\part J}{\part c}$的值，再通过梯度下降来更新参数</p><p>$\frac {\part J}{\part a}$、$\frac {\part J}{\part b}$、$\frac {\part J}{\part c}$ 可以通过链式法则来计算 </p></blockquote><p>假如你有两个特征(它们对应了两个权重w(实数))，使用 a 来代替 $y_{pred}$，那么就可以得到下图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3p5czxonvj215s09y3z6.jpg"></p><p>其中$\sigma(z)&#x3D;\frac{1}{1+e^{-z}}$,  $L(a,y)&#x3D;-ylna+(1-y)ln(1-a)$</p><p>我们的目标：更新 $w_1,w_2$的值，使得 $L(a,y)$尽可能小</p><p>为了使用梯度下降的方法，我们需要得到这些参数的值：  $\frac{\part L}{\part w_1}$，$\frac{\part L}{\part w_2}$，$\frac{\part L}{\part b}$</p><p>以$\frac{\part L}{\part w_1}$为例，根据链式法则:  $\frac{\part L}{\part w_1}&#x3D;\frac{\part L}{\part a}*\frac{da}{dz}<em>\frac{\part z}{\part w_1}&#x3D;x_1</em>(a-y)$</p><p>因此， $w_1 :&#x3D; w1-\alpha \frac{\part L}{\part w_1}$，这样我们就完成了一次参数的更新</p><p>⚠️ <strong>这里的 $x_1,x_2$不是两个sample，而是同一个sample的两个feature！也就是说，刚刚计算的是 一个样例的两个不同特征的损失函数(Loss)。接下来针对 m 个sample，我们来研究一下整体的代价函数 $J(w, b)$</strong></p><ul><li>从这里开始 由于使用编程语言的原因，将会对偏导符号进行简记，如 $\frac{\part L}{\part w_1}$ 就记为 dw1</li></ul><p>$J(w,b)&#x3D;\frac{1}{m}\sum^{m}_{i&#x3D;1}L(a^{(i)},y^{(i)})$ 注意此处的w和之前计算损失函数时的w就不一样了，它是所有的 w 的结合</p><blockquote><p>参数矩阵W：对第i个样本的第j个特征而言，其 $w^{(i)}_{j}$ 是作为一个实数存在的，它是矩阵中的一个元素</p><p>每增加一个样本，W就要增加一列。 每增加一种特征，W就要增加一行 （注意计算时W取转置）</p></blockquote><p>在一个sample两个feature的例子里，我们需要的是 $\frac{\part L}{\part w_1}$「dw1」$\frac{\part L}{\part w_2}$「dw2」$\frac{\part L}{\part b}$「db」 这三个参数，而现在出现了m个sample，每个sample都有2个feature，那么对于每一个sample(如第i个样例)，我们都需要求其Loss，并更新这个样例的三个参数：$dw_1^{(i)},dw_2^{(i)},db^{(i)}$, 也就是说一共出现了3*m个参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python3">J, dw1, dw2, db = 0, 0, 0, 0<br>for i in range(m):<br>  z_i = w*x_i + b<br>    a_i = sigma(z_i)  # 计算得到预测值a_i<br>    J += -(y_i*(ln(a_i)) + (1-y_i)*ln(1-a_i))  #对每个sample的loss求和<br>    dw1 += ___  #通过链式求导，计算dw1<br>    dw2 += ___  #...............dw2<br>    db += ___   #...............db<br>J, dw1, dw2, b /= m  # 最终的值就是所有的权重求平均<br><br># 接下来就可以通过梯度下降的方法，对参数进行更新了 (学习率为lr)<br>w1 = w1 - lr*dw1<br>w2 = w2 - lr*dw2<br>b = b - lr*db<br></code></pre></td></tr></table></figure><p>这种方法的弊端在于，对于m个参数，和n个特征，整个程序的时间复杂度将会来到O(m*n)，这样做的效率是很低的，且不适合扩展到更大的数据集上。因此我们就引入了 <code>矢量化(vectorization)</code>技术，来避免使用显式for循环</p><p>让我们从宏观的角度来解释一下逻辑回归问题，对于m个参数，n个特征，其结果矩阵 $Y_{pred}$</p><p>$Y_{pred} &#x3D; \sigma(W^T·X)+B$</p><h4 id="从第17个视频开始-再看一遍"><a href="#从第17个视频开始-再看一遍" class="headerlink" title="&#x3D;&#x3D;从第17个视频开始 再看一遍&#x3D;&#x3D;"></a>&#x3D;&#x3D;从第17个视频开始 再看一遍&#x3D;&#x3D;</h4><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>Input layer &#x3D;&gt; Hidden layer &#x3D;&gt; Output layer</p><ul><li>Hidden layer 的意思在于，训练时我们并不观察这些层的值，我们关系的是输入和输出层</li><li>Input layer是第0层(也就是说不算一层)</li></ul>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction to database</title>
    <link href="/1976/04/01/Introduction%20to%20Database/"/>
    <url>/1976/04/01/Introduction%20to%20Database/</url>
    
    <content type="html"><![CDATA[<h3 id="Chapter1-数据库系统概论"><a href="#Chapter1-数据库系统概论" class="headerlink" title="Chapter1 数据库系统概论"></a>Chapter1 数据库系统概论</h3><ul><li><p>什么是数据：计算机能够处理的信息</p></li><li><p>DBS &#x3D; DB + DBMS + 计算机系统</p></li><li><h4 id="数据库的三级模式-两级映像"><a href="#数据库的三级模式-两级映像" class="headerlink" title="数据库的三级模式&amp;两级映像"></a>数据库的三级模式&amp;两级映像</h4><ul><li>Internal Scheme：物理模式。描述数据的物理结构&#x2F;存储方式。 由DBMS提供，每个数据库只有一种，通常不需要客户来关心如何实现。</li><li>Scheme：逻辑模式。所有用户的公共数据视图，描述数据的逻辑结构。<ul><li>这里需要了解DBMS中的三种语言：DD^Definition^L, DM^Manipulation^L, DC^Control^L</li><li>其中DML 控制增删查改， DCL负责数据完整性和安全性</li><li>DDL描述逻辑模式，定义数据的各类label</li><li>是<strong>全体数据</strong>的逻辑结构，一个数据库只有一个模式。</li></ul></li><li>External Scheme：是<strong>模式的子集或者某种变形</strong>,依用户&#x2F;应用的要求而定。<ul><li>每个数据库可以有很多个外模式</li></ul></li><li><strong>两级映像</strong> 实现了三种模式的转换，保证数据库系统的逻辑独立和物理独立性<ul><li>以外模式&#x2F;模式映像为例，简单来说，当<code>模式</code>改变时，只需要改变<code>映像</code>即可, 而不需要改变外模式， 从而保证了数据的逻辑独立性。</li><li>同理，如果内模式改变(比如用了更先进的数据结构)，只需要修改模式&#x2F;内模式映像，就可以让模式适应新的内模式。</li></ul></li></ul></li><li><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><ul><li>UML Unified Modeling Language:  分为功能模型，对象模型和动态模型。<ul><li>UML定义一个 面向对象的软件密集型系统的方法</li></ul></li><li>数据模型 &#x3D; 数据结构 + 数据操作 + 数据完整性约束<ul><li><strong>关系模型</strong>  是关系数据库采用的模型，很多其他模型是用图解来说明的，而关系模型则是使用 <strong>二维表格</strong>来表达实体和它们间的关系，也是我们接下来主要研究的模型，其应用是最广泛的。</li></ul></li><li>概念模型的几大概念：  概念模型用来描述概念和它们之间的关系<ul><li>属性 &#x3D;&gt; 实体的某一特性； 域 &#x3D;&gt; 属性的取值范围；码(key) &#x3D;&gt; 可以<strong>唯一</strong>标识一个实体的属性</li><li>E-R图表示概念模型 其中矩形为实体，椭圆为属性，菱形为联系，用无向边+菱形联系起两个实体，并在无向边上标识 1:1 或是1:n 或是m:n。 在每个实体的码下面划一条横线</li></ul></li></ul></li></ul><hr><h3 id="Chapter2-关系运算理论"><a href="#Chapter2-关系运算理论" class="headerlink" title="Chapter2 关系运算理论"></a>Chapter2 关系运算理论</h3><ul><li>不同域之间的笛卡尔积<ul><li>比如D1 {计算机系，日语系}； D2 {1班，2班}； D3 {张三，李四，王五}</li><li>三者相互组合，形如 <code>(计算机系，1班，张三)</code> 被我们看作一个<code>元组</code>(在实际的表格里，这就是一行), 3个域的笛卡尔积能形成 2 * 2 * 3共 12个元组，整个笛卡尔积则是 3(3个域) * 12(12个元组) 的表格。 <strong>应当注意的是，实际上的关系，则是取整个笛卡尔积中有效的部分</strong></li></ul></li><li>关系的性质<ul><li>一行为一个元组，一列称为一个属性 </li><li><strong>码</strong>「唯一标识一个元组」 ： <ul><li>Candidate Key  候选码 : 可以唯一标识一个元组的属性 (比如 学号属性可以唯一标识出学生)</li><li>All Key   如果说所有的属性才可以唯一的标识一个元组(极端情况)，那么这些属性组 合起来称为全码</li><li>Primary Key 主码：和全码的意义差不多相反，如果有很多个属性都可以唯一的标识一个元组(也就是有多个候选码)，那么选定其中的一个属性作为主码。</li><li>外码:  如果F是R中的一个属性,但不是R的码,  但在另外一种关系中确是其码</li></ul></li><li>在关系数据库中，行(列)的次序是可以任意更换的， 并且每个分量都是不可分的数据项</li><li>关系完整性 「实体完整性、用户定义完整性、参照完整性」<ul><li>实际上就是对关系的某种约束</li><li>实体完整性&#x3D;&gt; 不可以出现主键相同或者空值</li><li>用户完整性&#x3D;&gt; 我们自己给关系设置约束，比如学生成绩在0～100之间</li><li>参照完整性&#x3D;&gt; 两个表互为参照的话，对一个表的修改要反映到另一张表里，你也不能在主表之外的值里取值</li></ul></li></ul></li><li>关系的五种基本操作 「选择 投影 并 差 笛卡尔积」</li></ul><hr><h3 id="Chapter3-结构化查询语言SQL-关系数据库标准语言"><a href="#Chapter3-结构化查询语言SQL-关系数据库标准语言" class="headerlink" title="Chapter3  结构化查询语言SQL(关系数据库标准语言)"></a>Chapter3  结构化查询语言SQL(关系数据库标准语言)</h3><p>其特性包括以下几条</p><ul><li>综合统一 「定义、操纵、查询、控制」 一种语言就可以完成数据库生命周期中的全部活动</li><li>高度非过程化   用户指出要做什么,但不必指出如何做.</li><li>面向集合操作   <ul><li>非关系数据模型是面向记录的操作方式, 而SQL语言可以一次操作很多个元组</li></ul></li><li>同一种语法结构提供两种使用方式     SQL是一种嵌入式语言, 可以嵌入其他高级语言中用</li><li></li></ul><hr><h4 id="几个概念："><a href="#几个概念：" class="headerlink" title="几个概念："></a>几个概念：</h4><ul><li><p>设计关系数据库时, 遵从不同规范要求以设计出合理的数据库, 这些要求被称为<code>范式</code>, 范式越高,数据库的冗余越小, 但可能提升计算的复杂度因此范式并不是越高越好  后续的范式必须先满足前面的范式.  去除冗余数据的过程, 就可称为规范化</p></li><li><h5 id="三个范式-：-属性唯一-记录唯一-表唯一"><a href="#三个范式-：-属性唯一-记录唯一-表唯一" class="headerlink" title="三个范式 ： 属性唯一, 记录唯一, 表唯一"></a><a href="https://blog.csdn.net/zymx14/article/details/69789326">三个范式</a> ： 属性唯一, 记录唯一, 表唯一</h5><ul><li>1NF: 确保每一列的原子性</li><li>2NF: 非键字段必须依赖于键字段, 相当于每个表只描述了一件事, 任何属性都最多只能和主键相关</li><li>3NF: 非主键之间也要消除依赖.   比如说学号和姓名 想满足3NF时 只能保留一个 (任何属性之间要无关)</li></ul></li><li><p>完整性约束</p><ul><li>完整性 &#x3D; 正确性 + 相容性(同一对象在不同关系表中的数据是符合逻辑的)</li></ul></li><li><p>索引查询是不是一定提高查询性能 ? </p><ul><li>通常来说 利用索引更快, 不过索引需要额外的空间,并且进行修改后 也有额外的维护成本</li></ul></li><li><p>什么是事物: 用户定义的一系列数据库操作, 它们要不全做, 要么全不做 有原子性</p></li><li><p>封锁协议(用来维护数据完整性)</p><ul><li>一级封锁 : 先🔒 后修改</li><li>二级封锁: 读时也🔒, 这样可以避免 读脏数据或者丢失修改</li><li>三级封锁: 读也不可并行, 不能重复读</li><li>两段锁协议: 任何数据进行读&#x2F;写前, 先获得锁, 在释放一个锁后, 事务不再申请和获得任何其他锁</li></ul></li></ul><hr><h4 id="数据库面试大纲"><a href="#数据库面试大纲" class="headerlink" title="数据库面试大纲"></a>数据库面试大纲</h4><p>第一章  数据库系统概述<br>1、四个概念：什么是数据?  什么是数据库? 什么是数据库管理系统（DBMS）？什么是数据库系统(DBS)？<br>2、熟记数据库系统的组成。<br>3、理解DBA是对数据库进行集中控制和管理的最重要人员。<br>4、实例和模式的对比（内容&#x2F;状态 vs 结构，变化 vs 稳定）<br>5、三级模式：物理模式（又称内模式、存储模式），逻辑模式（又称模式），和子模式（又称外模式）的含义是什么？一个数据库有几个物理模式，逻辑模式和子模式？ 三级模式间的两极映射，以及是由谁（DMBS）完成这种映射功能的？两级映射的作用（好处）是带来以下两种数据独立性——<br>6、两种数据独立性：什么是逻辑数据独立性？什么是物理数据独立性？用户或者应用程序面向的到底是哪一级数据库模式？<br>7、概念数据模型用于数据库设计，是对客观世界的第一层抽象。常见例子是E-R模型。</p><p>第二章 关系模型与关系运算<br>1、数据模型的三要素？关系模型的三要素？<br>2、关系的组成：什么是属性？什么是元组？什么是分量？ 度和基数。<br>3、理解关系有哪些性质？<br>4、理解关系的四种键及定义？数量（上限下限）？外部键的属性名可以和所对应的主键不同。外部键可以指向同一个关系的主键。例如：学生（学号，姓名，班长学号…）。外部键从E-R图的什么概念转化而来？<br>5、关系模式和关系实例的对比。<br>6、过程化和非过程化语言的区分和理解——看课件。<br>7、关系操作分为查询和更新操作。表示关系操作用某种查询语言：关系代数，关系演算（又分为元组关系演算和域关系演算）。关系代数是过程化的，关系演算是非过程化的。后面讲到的SQL是非过程化的。<br>8、掌握关系代数的各种运算（包括符号）。其中最基本的运算（不可替代）是哪些？<br>9、应用题型：用关系代数表达查询问题</p><p>第三章 关系数据库语言SQL<br>1、SQL的全名（中英文）。SQL是非过程化的语言。理解SQL的特点（基本功能特征）。<br>2、熟记SQL的四种功能。这些功能分别由哪些语句（动词）实现？<br>3、SQL对数据库三级模式的规定：每级模式由什么组成？<br>4、理解SQL中的系统数据类型，char&#x2F;varchar&#x2F;numeric等。<br>5、掌握SQL的各个数据定义语句（特别是新建表，建视图，修改表，删除表的语句）。<br>6、掌握SQL的Select数据查询语句。<br>7、掌握SQL的各个数据修改语句： Insert, Update, Delete。<br>8、空值的意义；掌握空值的运算规则（包括聚集函数忽略空值等），例如给出一个包含空值的式子，能计算最终结果。<br>9、理解视图的本质：命名的查询语句，只有这个才是真正存储在数据库里的；表象：虚拟表，与真正的表基本表相比有相同也有不同；动态变化）。<br>10、熟记视图的优点。<br>11、掌握定义视图的语句。理解对视图的查询以及对视图的更新系统在后台是怎样执行的（视图的查询：展开视图——替换视图为它所对应的查询。视图的修改：转化为对基本表的修改，这种转化可能因为缺少主键等原因失败，从而无法修改）。<br>12、嵌入式SQL不要求。<br>13、应用题型：用SQL表达数据查询(Select)和数据修改(Insert, Update, Delete)问题。用SQL建表(Create Table)，建视图(Create View)等数据定义操作。</p><p>第四章  关系数据库模式设计<br>1、熟记关系模式设计不当可能产生的四种问题：数据冗余和三种异常。<br>2、理解函数依赖的概念。三对特殊类型的函数依赖：平凡&#x2F;非平凡，部分&#x2F;完全，传递&#x2F;非传递。根据定义去理解和判定它们。<br>3、用函数依赖判断一个属性集是否超键，或者是否候选键的方法。<br>4、掌握计算属性集闭包的算法。以及由此判定一个函数依赖是否成立的方法。<br>5、掌握1NF、2NF、3NF、BCNF。并能够进行判定。<br>6、掌握规范化到1NF，3NF，BCNF的相关方法。关系模式应该至少规范化到3NF。规范化到3NF和规范化到BCNF相比，后者得到的关系模式属于更高级别，但是可能会丢失函数依赖。<br>7、应用题型：给出关系和函数依赖<br>a)寻找全部（可能不只一个）候选键，并给出判定证明。<br>b)判断某个函数依赖是否成立？<br>c)判断关系所属的最高范式，并给出证明。<br>d)将关系规范化到3NF，或者BCNF<br>e)判定一个分解（比如规范化后的结果）是否无损连接分解。</p><p>第五章 数据库设计<br>1、理解E-R模型的三要素：实体、属性和联系。以及在E-R图中的表示。<br>2、能判断二元联系的类型：一对一，一对多，多对多。以及在E-R图中的表示。<br>3、能将E-R图转化为关系模型。注意：多值属性的处理；1对1，1对多，多对1，多对多，三元以上联系各自的转化方式——不要张冠李戴。<br>4、熟记数据库设计的基本过程，包括在各个阶段分别要做的工作？<br>5、应用题型1：画E-R图（概念设计）。<br>6、应用题型2：将E-R图转化为关系模型（逻辑设计）。</p><p>第六章  数据库安全性与完整性<br>1、安全性是防止非法用户进入数据库，以及合法用户进入数据库后做了（未授权的）非法操作。完整性是防止非法数据进入数据库，即使是合法用户使用合法操作产生的。<br>2、掌握用SQL授予权限和回收、禁止权限的语句(grant, revoke, deny)。with grant option子句的作用。<br>3、理解常见权限的含义。（例如 insert on table S, update on view A等)<br>4、理解完整性的含义：正确、有效、相容。完整性约束（规则）是数据为保证完整性所必须满足的条件。<br>5、熟记关系模型中的三类完整性规则。各有什么要求？理解哪些（修改）操作会破坏这些规则？<br>6、掌握用SQL定义主键约束、外键约束、非空(not null)约束、唯一(unique)约束、域约束、检查(check)约束的语句？以及这些约束的含义、作用。<br>7、在定义外部键约束时，有哪几种参照动作？代表什么意义？<br>8、触发器是一种ECA规则，构成：Event事件，Condition条件，Action动作。触发器的事件主要有三类：INSERT,UPDATE,DELETE。</p><p>第七章 数据库事务管理。<br>1、深刻理解事务的概念。熟记事务的ACID性质（包括英文单词、解释、实现机制）。<br>2、掌握事务控制的多个SQL语句。两种结束方式（提交或回滚）的含义及区别。<br>3、熟记并发引起的三类数据不一致问题，它们是如何发生的（过程？）。产生不一致问题的根本原因是事务在并发执行（调度）时，没有保证隔离性。<br>4、并发执行（调度）的正确性准则：可串行化——效果等价于一个串行调度。<br>5、并发控制的任务：保证事务的并发执行（调度）是（尽量）正确的，避免不一致问题的产生。常见的一种实现方法是封锁。<br>6、封锁的基本类型：排他锁（写锁、X锁）、共享锁（读锁、S锁）。它们的相容关系？<br>7、有哪几种封锁协议？规则是什么？可分别解决哪些数据不一致性问题？两段封锁协议是可串行化调度的充分非必要条件。<br>8、数据库恢复技术的基本原理：冗余。建立冗余的两种方法：数据备份和登记日志文件。<br>9、静态备份 vs 动态备份（有否一致性；数据库是否可用，即是否允许用户运行事务来操作数据库）。完全备份 vs 增量备份（优缺点对比）。<br>10、日志文件：是用来记录事务对数据库进行修改操作的文件<br>11、日志文件的基本内容（事务开始一条；事务结束一条；事务若干次更新若干条）。在登记修改操作的日志记录时，修改前后的旧值与新值都要保存到日志记录中。<br>12、什么是运行记录优先（先写日志）原则？<br>13、熟记不同类型的数据库故障，包括它们的定义，故障的起因（例如死锁引起事务故障，停电引起系统故障，硬盘坏道引起介质故障等等…），影响范围（事务本身？DBMS系统？内存中的数据？磁盘上的数据？）、恢复策略（方法过程），每种故障类型的恢复过程，及由谁完成（系统自动 or 用户干预？）<br>14、理解检查点机制的原理（写检查点做了什么工作？按相对检查点的位置，把事务分成几类，哪些需要REDO&#x2F;UNDO，哪些不需要？）。检查点的作用（在恢复系统故障时，大大缩短需要扫描的日志文件的范围，这个范围是从哪里到哪里…）<br>15、熟记引入检查点后，系统故障的恢复过程，并与之前没有检查点时的恢复过程作对比</p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>Computation tech</tag>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction to Machine Learning</title>
    <link href="/1976/04/01/Introduction%20to%20Machine%20Learning/"/>
    <url>/1976/04/01/Introduction%20to%20Machine%20Learning/</url>
    
    <content type="html"><![CDATA[<p><a href="https://cloud.baidu.com/">百度智能云</a><br><a href="https://www.paddlepaddle.org.cn/tutorials/projectdetail/2496128">飞桨平台</a></p><h3 id="机器学习的常见算法"><a href="#机器学习的常见算法" class="headerlink" title="机器学习的常见算法"></a>机器学习的常见算法</h3><ul><li>supervised learning &amp; unsupervised learning 「main」</li><li>Reinforcement learning，recommender systems</li></ul><h3 id="机器学习的三大问题"><a href="#机器学习的三大问题" class="headerlink" title="机器学习的三大问题"></a>机器学习的三大问题</h3><h4 id="regression-problem-回归问题"><a href="#regression-problem-回归问题" class="headerlink" title="regression problem 回归问题"></a>regression problem 回归问题</h4><ul><li>样本由离散的点构成，我们需要利用模型来拟合它，从而对连续的每个值都给出预测</li><li>常见情况下 模型分为：linear model 和 polynomial model 两种</li><li><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tvo59jrfj215c0eggmi.jpg"></li></ul><h4 id="classification-problem-分类问题"><a href="#classification-problem-分类问题" class="headerlink" title="classification problem 分类问题"></a>classification problem 分类问题</h4><ul><li>和回归问题不同的地方在于 其产出是离散的 常见情况是 下判断</li></ul><h4 id="Clustering-problem-聚类问题"><a href="#Clustering-problem-聚类问题" class="headerlink" title="Clustering problem 聚类问题"></a>Clustering problem 聚类问题</h4><h3 id="Three-Basic-Mechine-Learning-method"><a href="#Three-Basic-Mechine-Learning-method" class="headerlink" title="Three Basic Mechine Learning method"></a>Three Basic Mechine Learning method</h3><p>Supervised Learning 「给出正确的答案，算法的目的是产生更多正确答案」</p><ul><li><p>a data set with right answers given,  the task of the algorithm is to <strong>produce more of these right answers.</strong> </p></li><li><p>由监督学习引出的两种问题是 <strong>分类问题和回归问题</strong>(两者的区别在连续和离散)</p></li><li><p>监督学习的集中算法</p><ul><li>线性回归、逻辑回归、决策树、神经网络、卷积神经网络、循环神经网络</li></ul></li><li><p>强监督和弱监督  如果你对每组数据都给出完整、正确的标签，那么就是强监督学习 </p><ul><li>弱监督学习分为三类： 「周志华老师  A brief Introduction to Weakly Supervised Learning」   这三类并非我们人为选择，而是在实际操作中可能会同时发生的。<ul><li><p>Incomplete su 不完全监督： 只对一部分数据给出label</p><ul><li>解决方案： <ul><li>Active L 主动学习 &#x3D;&gt; 先训练标注过的数据，剩下的自动查询。 有人工干预</li><li>Semi-su L半监督学习 &#x3D;&gt; 观察未被标注的数据分布，比如说在一个positive和一个negative中间的，如果他附近的样本点很多为正，那么可以认为它大概率为正</li></ul></li></ul></li><li><p>Inexact su 不确切监督：给出的标签是粗粒度的，一个包里的示例只给了一个标签</p><ul><li>解决方案：<ul><li>Multi-instance L 多实例学习 &#x3D;&gt; 实际上几乎所有机器学习算法都有其多实例对等体，这个的应用非常广泛</li></ul></li></ul></li><li><p>Inaccurate su不精确监督： 给出的标签可能有错误</p><ul><li>解决方案：<ul><li>L with label noise 带噪学习 &#x3D;&gt; 基本思想是 识别潜在的误分类样本然后修正。在系统中建立相邻关系表，如果某个点和其相邻的点不同，它就可能被判定为可疑点，系统可能会将其删除或重新标记</li></ul></li></ul></li></ul></li></ul></li></ul><p>Unsupervised Learning 「数据不含标签，算法的目的是找到数据中的结构 我们不知道正确答案」</p><ul><li>a data set with no labels, the task of the algorithm is to find some structure in the data, the key is we don’t know how to divide the data in advance.<ul><li>cluster algorithm (organize computing clusters or social network analysis)</li><li>cocktail party problem</li></ul></li><li>由非监督学习引出的问题则是 聚类问题，将训练数据分成几个类，自己去寻找结构</li></ul><p>Reinforcement learning  RL</p><p>强调探索和利用的平衡，通过某种奖惩机制刺激，逐步产生获得最大利益的习惯性行为。</p><hr><h2 id="AI必知必会基础"><a href="#AI必知必会基础" class="headerlink" title="AI必知必会基础"></a>AI必知必会基础</h2><h3 id="人工智能概论"><a href="#人工智能概论" class="headerlink" title="人工智能概论"></a>人工智能概论</h3><h4 id="人工智能的描述"><a href="#人工智能的描述" class="headerlink" title="人工智能的描述"></a>人工智能的描述</h4><ul><li><p>可以感知“环境”，并且根据环境变化做出决策或者行动，从而达成目标的程序。(AI 的所谓学习，可以被解释成一种 优化)</p><ul><li>机器学习 指的就是 特征提取构建模型 + 大量数据进行训练，从而达到对新样本的预测、识别</li></ul></li><li><p><code>为什么不能用编程解决机器学习问题？</code>：比如在猫狗识别中，改变拍摄角度或者动物形态，可能就改变了我们用编程判断时的关键特征。</p></li><li><p><code>为什么GPU为机器学习提供了支撑？</code>： GPU一开始被设计成方便图形开发，在渲染图形时候需要大量浮点运算，并且GPU可以大量并行的进行浮点运算</p></li></ul><h4 id="弱、强、超人工智能的含义"><a href="#弱、强、超人工智能的含义" class="headerlink" title="弱、强、超人工智能的含义"></a>弱、强、超人工智能的含义</h4><ul><li>弱人工智能 指的是专注于且只能解决特定问题的AI， AlphaGo、Siri这种也只能叫弱人工智能</li><li>强人工智能 又叫完全人工智能，可以胜任人类所有工作的人工智能，目前还无法实现。<ul><li>在我看来，一方面是由于人工智能的<strong>复杂决策和对不确定因素的推理能力</strong>还不成熟，另一方面，人工智能伦理问题也难以解决。</li></ul></li><li>超人工智能 比人类社会最聪明的人还要更逆天的存在</li><li>人工智能与岗位的关系：不可避免的替代掉一部分人的工作，但在历史上也有先例，会产生更好的工作 解放人类生产力。  决策信息量小，过程简单的重复性工作，可能会被替代。</li></ul><h4 id="人工智能几个基本概念"><a href="#人工智能几个基本概念" class="headerlink" title="人工智能几个基本概念"></a>人工智能几个基本概念</h4><ul><li><p>向量 &#x3D;&gt; 二维    平面 &#x3D;&gt; 矩阵   多维 &#x3D;&gt; 张量(tensor)</p></li><li><h5 id="训练集、验证集-训练好之后用来调整参数-、测试集-用来评估"><a href="#训练集、验证集-训练好之后用来调整参数-、测试集-用来评估" class="headerlink" title="训练集、验证集(训练好之后用来调整参数)、测试集(用来评估)"></a>训练集、验证集(训练好之后用来调整参数)、测试集(用来评估)</h5><ul><li>验证集是什么：在跑测试之前，防止自己的模型过拟合，想要获得更好的泛化能力来进行的小测试</li><li>注意，三者其实都是数据集的划分而已，并不是独立的，一般的分配比例是 6 2 2(小型系统)<ul><li>每一个数据看作一个 包， 每个包里可以有多个instance.</li></ul></li></ul></li><li><p>随机梯度下降法 Stochastic Gradient Descent</p></li></ul><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>机器学习7大步骤</p><p>收集数据 $\rightarrow$ 数据准备 $\rightarrow$ 选择模型 $\rightarrow$ 训练 $\rightarrow$ 评估 $\rightarrow$ 参数调整 $\rightarrow$ 预估</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2tvp1ne2yj214a0863zg.jpg"></p><p><strong>宏观上说，还是将现实问题抽象为数学问题，并利用计算机建立模型解决，最后评估模型的合理性。从过程上说，通过训练集，不断识别和提取特征，不断完善模型，最终形成有效模型的过程，就可以称为机器学习。</strong></p><h4 id="机器学习的评估指标-以男女预测为例"><a href="#机器学习的评估指标-以男女预测为例" class="headerlink" title="机器学习的评估指标 (以男女预测为例)"></a>机器学习的评估指标 (以男女预测为例)</h4><ul><li>Accuracy<ul><li>正确数&#x2F;总预测数    问题在于样本不平衡时(比如9成样本结果一样，那么即使全预测一样的结果仍然可能取得9成的准确率)</li></ul></li><li>Precision<ul><li>以男女预测为例，这个指的是，比如预测为男的结果里，实际上确实为男的比率，而Accuracy 指的是，所有的预测结果里，预测正确的比率。</li></ul></li><li>Recall  召回率&#x2F;查全率<ul><li>实际为男的样本，确实被预测为男的概率</li><li>为什么需要这个指标：有些系统必须找出全部含有某种特征的点, 比如必须找到所有欠债的人，至于有的人没欠债却被认为欠了，没关系。</li></ul></li><li>PR曲线 &#x2F; F1分数  「将精准率和召回率做出二维曲线」<ul><li>P和R 并不能都同时达到高位，因此综合两者的表现，出现了F1分数 &#x3D; (2 x p x r) &#x2F; (p + r)</li></ul></li><li>ROC 曲线 「TP率 和 FP率 真正率 &#x2F; 假正率」<ul><li>我觉得这个不是很好懂，姑且记住 <strong>ROC曲线越陡说明模型的性能越好</strong></li></ul></li><li>AUC 曲线下面积</li></ul><h4 id="假设函数-损失函数和它们的优化"><a href="#假设函数-损失函数和它们的优化" class="headerlink" title="假设函数&amp;损失函数和它们的优化"></a>假设函数&amp;损失函数和它们的优化</h4><ul><li>Hypothesis Function: 也就是模型本身。 </li><li>Loss Function: L(x) 其中x是假设函数的预测结果，L(x)越小，与实际值的偏差越小 </li><li>优化方法：本质上，就是优化假设函数以使损失函数最小的过程。 优化方法 就是我们常听说的，如 梯度下降法、共轭梯度法 等等。<ul><li>经验误差(训练集数据的误差) </li><li>泛化误差(测试集数据的误差)</li></ul></li></ul><h4 id="拟合-fitting"><a href="#拟合-fitting" class="headerlink" title="拟合 fitting"></a>拟合 fitting</h4><p>拟合就是把平面坐标系中散落的点，用光滑的曲线连接起来，利用模型对数据进行拟合，就是机器学习的基本问题。 对训练集以外样本的预测能力，就是机器学习的泛化能力。</p><ul><li>过拟合，模型在训练样本中表现优越(从几何上看，模型曲线几乎包含了所有的样本点)，但泛化能力差。 产生的原因是 特征太多和训练样本过少</li><li>欠拟合(underfitting)， 模型曲线不能很好的拟合数据，在训练和测试的时候表现都不好。 比如尝试用直线去拟合符合对数特征的样本点</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>Computation tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Data Structure Note</title>
    <link href="/1976/04/01/Leetcode%20Data%20Structure%20Note/"/>
    <url>/1976/04/01/Leetcode%20Data%20Structure%20Note/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter1-Stack"><a href="#Chapter1-Stack" class="headerlink" title="Chapter1 Stack"></a>Chapter1 Stack</h1><h3 id="84-柱状图中最大的矩形「Hard」"><a href="#84-柱状图中最大的矩形「Hard」" class="headerlink" title="84. 柱状图中最大的矩形「Hard」"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形「Hard」</a></h3><p>给定 <code>n</code> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 <code>1</code> 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png" alt="picture"></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" alt="pictture"></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p><p><strong>示例:</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入: [2,1,5,6,2,3]<br>输出: 10<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><p>枚举「宽」的暴力法这里就不再过多赘述了。</p><p>我们对枚举「高」来做一些分析以及优化。</p><p>对枚举「高」的暴力法就是对每一条「高」进行中心扩展：</p><ul><li>首先我们枚举某一根柱子 $i$ 作为高 $h&#x3D;height[i]$.</li><li>随后我们需要进行向左右两边扩展，使得扩展到的柱子的高度均不小于 $h$，也就是说，我们需要找到<strong>左右两侧最近的高度小于 $h$ 的柱子</strong>，这两根柱子之间的所有柱子的高度均不小于 $h$，这就是 $i$ 能扩展的最远范围.</li></ul><p>对于上述分析我们可知，我们可以使用<strong>单调栈</strong>来维护左边和右边的高度依赖关系。由分析可知，我们需要查找的是距离 $i$ 最近比 $h$ 低的柱子，所以我们可以维护一个单调递增的栈，每次只需要查找对比栈顶元素与当前的柱子高度，进行 $pop$ 操作和 $push$ 操作即可。</p><p>单调栈的算法如下：</p><ul><li>当我们枚举到第 $i$ 根柱子时，我们从栈顶不断移除 $height[j]&gt;height[i]$ 的 $j$ 值。在移除完毕后，栈顶元素的 $j$ 值就一定满足 $height[j]&lt;height[i]$，此时 $j$ 就是 $i$ 左侧且最近的小于其高度的柱子。</li><li>这里会有一种特殊情况。如果我们移除了栈中所有的 $j$ 值，说明 $i$ 左侧所有柱子的高度都大于 $height[i]$，那么我们可以认为 $i$ 左侧且最近的小于其高度的柱子在位置 $j&#x3D;-1$，它是一根「虚拟」的、高度无限低的柱子。这样的定义不会对我们的答案产生任何的影响，我们也称这根「虚拟」的柱子为「哨兵」。</li><li>最后我们将 $i$ 这根柱子入栈。</li></ul><p>Details：</p><p>我们在栈中存放的是柱子的下标而非柱子高度。</p><p>最后求面积为 <code>maxArea = max(maxArea, (right[i] - left[i] - 1) * heights[i])</code>，具体下标的长度需要注意。</p><p>本题还能进行常数优化 $\Rightarrow$ 一次遍历，这里就不提了</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxArea = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>)heights.<span class="hljs-built_in">size</span>();<br>        stack&lt;<span class="hljs-type">int</span>&gt; min_stack;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(n)</span>, <span class="hljs-title">right</span><span class="hljs-params">(n)</span></span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!min_stack.<span class="hljs-built_in">empty</span>() <span class="hljs-keyword">and</span> heights[i] &lt;= heights[min_stack.<span class="hljs-built_in">top</span>()]) &#123;<br>                min_stack.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            left[i] = min_stack.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : min_stack.<span class="hljs-built_in">top</span>();<br>            min_stack.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <br>        min_stack = <span class="hljs-built_in">stack</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">while</span> (!min_stack.<span class="hljs-built_in">empty</span>() <span class="hljs-keyword">and</span> heights[i] &lt;= heights[min_stack.<span class="hljs-built_in">top</span>()]) &#123;<br>                min_stack.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            right[i] = min_stack.<span class="hljs-built_in">empty</span>() ? n : min_stack.<span class="hljs-built_in">top</span>();<br>            min_stack.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            maxArea = <span class="hljs-built_in">max</span>(maxArea, (right[i] - left[i] - <span class="hljs-number">1</span>) * heights[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="503-下一个更大元素-II「Medium」"><a href="#503-下一个更大元素-II「Medium」" class="headerlink" title="503. 下一个更大元素 II「Medium」"></a><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II「Medium」</a></h3><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 $x$ 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 $-1$.</p><p><strong>示例 1:</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入: [1,2,1]<br>输出: [2,-1,2]<br>解释: 第一个 1 的下一个更大的数是 2；<br>数字 2 找不到下一个更大的数； <br>第二个 1 的下一个最大的数需要循环搜索，结果也是 2。<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><p>我们可以使用单调栈解决本题。单调栈中保存的是下标，从栈底到栈顶的下标在数组 $nums$ 中对应的值是单调不升的。</p><p>每次我们移动到数组中的一个新的位置 $i$，我们就将当前单调栈中所有对应值小于 $nums[i]$ 的下标弹出单调栈，这些值的下一个更大元素即为 $nums[i]$，随后我们将位置 $i$ 入栈.</p><p>但是注意到只遍历一次序列是不够的，例如序列 $[2,3,1]$，最后单调栈中将剩余 $[3,1]$，其中元素 $[1]$ 的下一个更大元素还是不知道的</p><p>一个朴素的思想是，我们可以把这个循环数组「拉直」，即复制该序列的前 $n-1$ 个元素拼接在原序列的后面。这样我们就可以将这个新序列当作普通序列，用上文的方法来处理。</p><p>而在本题中，我们不需要显性地将该循环数组「拉直」，而只需要在处理时对下标取模即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[stk.<span class="hljs-built_in">top</span>()] &lt; nums[i % n]) &#123;<br>                ret[stk.<span class="hljs-built_in">top</span>()] = nums[i % n];<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            stk.<span class="hljs-built_in">push</span>(i % n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224. 基本计算器"></a><a href="https://leetcode-cn.com/problems/basic-calculator/%E3%80%8CHard%E3%80%8D">224. 基本计算器</a></h3><p>实现一个基本的计算器来计算一个简单的字符串表达式 <code>s</code> 的值。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;(1+(4+5+2)-3)+(6+8)&quot;<br>输出：23<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> 由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和 <code>&#39; &#39;</code> 组成</li><li><code>s</code> 表示一个有效的表达式</li></ul><blockquote><p>算法分析：</p><p>方法：括号展开 + 栈</p><p>由于字符串除了数字与括号外，只有加号和减号两种运算符。因此，如果展开表达式中所有的括号，则得到的新表达式中，数字本身不会发生变化，只是每个数字前面的符号会发生变化。</p><p>因此，我们考虑使用一个取值为 {-1, 1} 的整数 $sign$ 代表「当前」的符号。根据括号表达式的性质，它的取值：</p><ul><li>与字符串中当前位置的运算符有关；</li><li>如果当前位置处于一系列括号之内，则也与这些括号前面的运算符有关：每当遇到一个以 -− 号开头的括号，则意味着此后的符号都要被「翻转」。</li></ul><p>考虑到第二点，我们需要维护一个栈 $ops$，其中栈顶元素记录了当前位置所处的每个括号所「共同形成」的符号。例如，对于字符串 $1+2+(3-(4+5))$：</p><ul><li><p>扫描到 $1+2$ 时，由于当前位置没有被任何括号所包含，则栈顶元素为初始值 $+1$.</p></li><li><p>扫描到 $1+2+(3$ 时，当前位置被一个括号所包含，该括号前面的符号为 $+$ 号，因此栈顶元素依然 $+1$.</p></li><li><p>扫描到 $1+2+(3-(4$ 时，当前位置被两个括号所包含，分别对应着 $+$ 号和 $-$ 号，由于 $+$ 号和 $-$ 号合并的结果为 $-$ 号，因此栈顶元素变为 $-1$.</p><p>  在得到栈 $ops$ 之后，$sign$ 的取值就能够确定了：如果当前遇到了 $+$ 号，则更新 $sign\leftarrow ops.top()$ ；如果遇到了遇到了 $-$ 号，则更新 $sign\leftarrow -ops.top()$.</p></li></ul><p>然后，每当遇到 $($ 时，都要将当前的 $sign$ 取值压入栈中；每当遇到 $)$ 时，都从栈中弹出一个元素。这样，我们能够在扫描字符串的时候，即时地更新 $ops$ 中的元素.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(s)<br>ans := <span class="hljs-number">0</span><br>ops := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>&#125;<br>sign := <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; &#123;<br><span class="hljs-keyword">switch</span> s[i] &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27; &#x27;</span>:<br>i++<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>sign = -ops[<span class="hljs-built_in">len</span>(ops)<span class="hljs-number">-1</span>]<br>i++<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>sign = ops[<span class="hljs-built_in">len</span>(ops)<span class="hljs-number">-1</span>]<br>i++<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>ops = <span class="hljs-built_in">append</span>(ops, sign)<br>i++<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<br>ops = ops[:<span class="hljs-built_in">len</span>(ops)<span class="hljs-number">-1</span>]<br>i++<br><span class="hljs-keyword">default</span>:<br>num := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> ; i &lt; n &amp;&amp; <span class="hljs-string">&#x27;0&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; i++ &#123;<br>num = num*<span class="hljs-number">10</span> + (<span class="hljs-type">int</span>)(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)<br>&#125;<br>ans += sign * num<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="331-验证二叉树的前序序列化「Medium」"><a href="#331-验证二叉树的前序序列化「Medium」" class="headerlink" title="331. 验证二叉树的前序序列化「Medium」"></a><a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/">331. 验证二叉树的前序序列化「Medium」</a></h3><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">     <span class="hljs-built_in">_</span>9<span class="hljs-built_in">_</span><br>    /   <span class="hljs-keyword">\</span><br><span class="hljs-keyword"></span>   3     2<br>  / <span class="hljs-keyword">\ </span>  / <span class="hljs-keyword">\</span><br><span class="hljs-keyword"></span> 4   1  <span class="hljs-params">#</span>  6<br>/ <span class="hljs-keyword">\ </span>/ <span class="hljs-keyword">\ </span>  / <span class="hljs-keyword">\</span><br><span class="hljs-keyword"></span><span class="hljs-params">#</span> <span class="hljs-params">#</span> <span class="hljs-params">#</span> <span class="hljs-params">#</span>   <span class="hljs-params">#</span> <span class="hljs-params">#</span><br></code></pre></td></tr></table></figure><p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 <code>#</code> 代表一个空节点。</p><p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p><p>每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的 <code>&#39;#&#39;</code> 。</p><p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入: &quot;9,3,4,<span class="hljs-params">#</span>,<span class="hljs-params">#</span>,1,<span class="hljs-params">#</span>,<span class="hljs-params">#</span>,2,<span class="hljs-params">#</span>,6,<span class="hljs-params">#</span>,<span class="hljs-params">#</span>&quot;<br>输出: true<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入: &quot;1,<span class="hljs-params">#</span>&quot;<br>输出: false<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><p><strong>方法一：栈</strong><br>我们可以定义一个概念，叫做槽位。一个槽位可以被看作「当前二叉树中正在等待被节点填充」的那些位置。</p><p>二叉树的建立也伴随着槽位数量的变化。每当遇到一个节点时：</p><p>如果遇到了空节点，则要消耗一个槽位；</p><p>如果遇到了非空节点，则除了消耗一个槽位外，还要再补充两个槽位。</p><p>此外，还需要将根节点作为特殊情况处理。</p><p><img src="https://assets.leetcode-cn.com/solution-static/331/1.png" alt="p"></p><p>我们使用栈来维护槽位的变化。栈中的每个元素，代表了对应节点处<strong>剩余槽位的数量</strong>，而栈顶元素就对应着下一步可用的槽位数量。当遇到空节点时，仅将栈顶元素减 $1$；当遇到非空节点时，将栈顶元素减 $1$ 后，再向栈中压入一个 $2$。无论何时，如果栈顶元素变为 $0$，就立刻将栈顶弹出。 </p><p>历结束后，若栈为空，说明没有待填充的槽位，因此是一个合法序列；否则若栈不为空，则序列不合法。此外，在遍历的过程中，若槽位数量不足，则序列不合法。</p><ul><li>时间复杂度：$O(n)$.</li><li>空间复杂度：$O(n)$.</li></ul><p><strong>方法二：计数</strong></p><p>回顾方法一的逻辑，如果把栈中元素看成一个整体，即所有剩余槽位的数量，也能维护槽位的变化。</p><p>因此，我们可以只维护一个计数器，代表栈中所有元素之和，其余的操作逻辑均可以保持不变</p><ul><li>时间复杂度：$O(n)$.</li><li>空间复杂度：$O(1)$.</li></ul></blockquote><p>方法一：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidSerialization</span><span class="hljs-params">(preorder <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(preorder)<br>    stk := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stk) == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> preorder[i] == <span class="hljs-string">&#x27;,&#x27;</span> &#123;<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> preorder[i] == <span class="hljs-string">&#x27;#&#x27;</span> &#123;<br>            stk[<span class="hljs-built_in">len</span>(stk)<span class="hljs-number">-1</span>]--<br>            <span class="hljs-keyword">if</span> stk[<span class="hljs-built_in">len</span>(stk)<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span> &#123;<br>                stk = stk[:<span class="hljs-built_in">len</span>(stk)<span class="hljs-number">-1</span>]<br>            &#125;<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 读一个数字</span><br>            <span class="hljs-keyword">for</span> i &lt; n &amp;&amp; preorder[i] != <span class="hljs-string">&#x27;,&#x27;</span> &#123;<br>                i++<br>            &#125;<br>            stk[<span class="hljs-built_in">len</span>(stk)<span class="hljs-number">-1</span>]--<br>            <span class="hljs-keyword">if</span> stk[<span class="hljs-built_in">len</span>(stk)<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span> &#123;<br>                stk = stk[:<span class="hljs-built_in">len</span>(stk)<span class="hljs-number">-1</span>]<br>            &#125;<br>            stk = <span class="hljs-built_in">append</span>(stk, <span class="hljs-number">2</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stk) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidSerialization</span><span class="hljs-params">(preorder <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(preorder)<br>    slots := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; &#123;<br>        <span class="hljs-keyword">if</span> slots == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> preorder[i] == <span class="hljs-string">&#x27;,&#x27;</span> &#123;<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> preorder[i] == <span class="hljs-string">&#x27;#&#x27;</span> &#123;<br>            slots--<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 读一个数字</span><br>            <span class="hljs-keyword">for</span> i &lt; n &amp;&amp; preorder[i] != <span class="hljs-string">&#x27;,&#x27;</span> &#123;<br>                i++<br>            &#125;<br>            slots++ <span class="hljs-comment">// slots = slots - 1 + 2</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slots == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="456-132-模式「Medium」"><a href="#456-132-模式「Medium」" class="headerlink" title="456. 132 模式「Medium」"></a><a href="https://leetcode-cn.com/problems/132-pattern/">456. 132 模式「Medium」</a></h3><p>给你一个整数数组 <code>nums</code> ，数组中共有 <code>n</code> 个整数。</p><p><strong>132 模式的子序列</strong> 由三个整数 <code>nums[i], nums[j]</code> 和 <code>nums[k]</code> 组成</p><p>并同时满足：<code>i &lt; j &lt; k</code> 和 <code>nums[i] &lt; nums[k] &lt; nums[j]</code></p><p>如果 <code>nums</code> 中存在 <strong>132 模式的子序列</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> </p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [1,2,3,4]<br>输出：false<br>解释：序列中不存在 132 模式的子序列。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [3,1,4,2]<br>输出：true<br>解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><p>我们首先可以考虑枚举 <code>132</code> 模式中的 <code>3</code></p><ul><li><p>由于 <code>1</code> 是模式中的最小值，因此我们在枚举 <code>j</code> 的同时，维护数组 <code>num[0, j - 1]</code> 中的最小值，因为只有 <code>a[i] &lt; a[j]</code> 时，我们才可以选择 <code>a[i]</code> 作为 <code>1</code>.</p></li><li><p>由于 <code>2</code> 是模式中的次小值，因此我们可以使用一个有序集合（例如平衡树）维护数组中右侧元素</p><p> <code>nums[j + 1, n - 1]</code> 中的所有值。当我们确定了 <code>a[i]</code> 和 <code>a[j]</code> 时，我们就可以在有序集合中查询严格比 <code>a[i]</code> 大的那个最小元素，即为 <code>a[k]</code>.</p></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find132pattern</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 左侧最小值</span><br>        <span class="hljs-type">int</span> left_min = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 右侧所有元素</span><br>        multiset&lt;<span class="hljs-type">int</span>&gt; right_all;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>; k &lt; n; ++k) &#123;<br>            right_all.<span class="hljs-built_in">insert</span>(nums[k]);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">1</span>; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (left_min &lt; nums[j]) &#123;<br>                <span class="hljs-keyword">auto</span> it = right_all.<span class="hljs-built_in">upper_bound</span>(left_min);<br>                <span class="hljs-keyword">if</span> (it != right_all.<span class="hljs-built_in">end</span>() &amp;&amp; *it &lt; nums[j]) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            left_min = <span class="hljs-built_in">min</span>(left_min, nums[j]);<br>            right_all.<span class="hljs-built_in">erase</span>(right_all.<span class="hljs-built_in">find</span>(nums[j + <span class="hljs-number">1</span>]));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="Chapter2-Tree"><a href="#Chapter2-Tree" class="headerlink" title="Chapter2 Tree"></a>Chapter2 Tree</h1><blockquote><p>树的解决我们一般使用递归方法，递归概述如下：</p><ul><li>将问题转化为规模更小的子问题，直至边界情况</li><li>递归方程 + 边界条件</li><li>借助于计算机的程序栈，利用函数自身调用来实现</li></ul></blockquote><h3 id="124-二叉树中的最大路径和「Hard」"><a href="#124-二叉树中的最大路径和「Hard」" class="headerlink" title="124. 二叉树中的最大路径和「Hard」"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和「Hard」</a></h3><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 最大路径和 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="picture"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：root = [1,2,3]<br>输出：6<br>解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="picture"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：root = [-10,9,20,null,null,15,7]<br>输出：42<br>解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><p>首先，考虑实现一个简化的函数 <code>maxGain(node)</code>，该函数计算二叉树中的一个节点的最大贡献值，具体而言，就是在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。</p><p>具体而言，该函数的计算如下：</p><ul><li>空节点的最大贡献值等于 $0$.</li><li>非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和 ( 对于叶节点而言，最大贡献值等于节点值 )</li></ul><p>例如，考虑如下二叉树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-number">-10</span><br> / \<br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  \<br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>叶节点 <code>9、15、7</code> 的最大贡献值分别为 <code>9、15、7</code>。</p><p>得到叶节点的最大贡献值之后，再计算非叶节点的最大贡献值。</p><p>节点 20 的最大贡献值等于 <code>20 + max(15, 7) =  35</code>.</p><p>节点 -10 的最大贡献值等于 <code>-10 + max(35, 9) = 25</code>.</p><p>上述计算过程是递归的过程，因此，对根节点调用函数 <code>maxGain</code>，即可得到每个节点的最大贡献值。</p><p>根据函数 <code>maxGain</code> 得到每个节点的最大贡献值之后，如何得到二叉树的最大路径和？对于二叉树中的一个节点，该节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值，如果子节点的最大贡献值为正，则计入该节点的最大路径和，否则不计入该节点的最大路径和。维护一个全局变量 <code>maxSum</code> 存储最大路径和，在递归过程中更新 <code>maxSum</code> 的值，最后得到的 <code>maxSum</code> 的值即为二叉树中的最大路径和。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> maxSum = INT_MIN;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxGain</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 递归计算左右子节点的最大贡献值</span><br>        <span class="hljs-comment">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span><br>        <span class="hljs-type">int</span> leftGain = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxGain</span>(root-&gt;left), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> rightGain = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxGain</span>(root-&gt;right), <span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-comment">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span><br>        <span class="hljs-type">int</span> priceNewpath = root-&gt;val + leftGain + rightGain;<br>        <br>        <span class="hljs-comment">// 更新答案</span><br>        maxSum = <span class="hljs-built_in">max</span>(maxSum, priceNewpath);<br>        <br>        <span class="hljs-comment">// 返回节点的最大贡献值</span><br>        <span class="hljs-keyword">return</span> root-&gt;val + <span class="hljs-built_in">max</span>(leftGain, rightGain);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">maxGain</span>(root);<br>        <span class="hljs-keyword">return</span> maxSum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-26-树的子结构「Medium」"><a href="#剑指-Offer-26-树的子结构「Medium」" class="headerlink" title="剑指 Offer 26. 树的子结构「Medium」"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构「Medium」</a></h3><p>输入两棵二叉树<code>A</code>和<code>B</code>，判断<code>B</code>是不是<code>A</code>的子结构。(约定空树不是任意一个树的子结构)</p><p><code>B</code>是<code>A</code>的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 <code>A</code>:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">    3<br>   / <span class="hljs-keyword">\</span><br><span class="hljs-keyword"></span>  4   5<br> / <span class="hljs-keyword">\</span><br><span class="hljs-keyword"></span>1   2<br></code></pre></td></tr></table></figure><p>给定的树 <code>B</code>：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">  4 <br> /<br>1<br></code></pre></td></tr></table></figure><p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：A = [1,2,3], B = [3,1]<br>输出：false<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><ol><li>双重递归第一重，<code>isSubStructure</code><ul><li>判断 <code>pRoot2</code> 是否为 <code>pRoot1</code> 的子结构 (约定空树,不为任何一棵树的子结构)</li><li>约定空树不是任意一个树的子结构. 所以 A 不可为空树,且 B 不可为空树。</li><li>B 是以 “<strong>A 为根节点</strong>“ 的子结构,或者 B 是 “<strong>A 的左子树</strong>“ 的子结构,或者B是 “<strong>A 的右子树</strong>“ 的子结构。注意三者为 <strong>或</strong> 的关系</li><li>相当于对 A 进行了前序遍历: 根-&gt;左-&gt;右</li></ul></li><li>双重递归第二重，<code>isInclude</code><ul><li>判断 <code>pRoot1</code> 是否包含 <code>pRoot2</code> (从集合关系分析,空集属于任何集合的子集)</li><li><code>pRoot2</code> 为空,则 <code>pRoot1</code> 包含 <code>pRoot2</code></li><li><code>pRoot1</code> 为空,则 <code>pRoot1</code> 不包含 <code>pRoot2</code></li><li><code>pRoot1</code>，<code>pRoot2</code> 都不为空, 但节点值不同，则 <code>pRoot1</code> 不包含 <code>pRoot2</code>，即不具备包含关系</li><li>如果值相同，则判断他们的左右节点是否也是包含关系（必须都是包含关系才行）</li><li>递归判断 A 的左节点和 B 的左节点是否相等, 递归判断 A 的右节点和 B 的右节点是否相等</li></ul></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (B == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isInclude</span>(A, B) <span class="hljs-keyword">or</span> <span class="hljs-built_in">isSubStructure</span>(A-&gt;left, B) <span class="hljs-keyword">or</span> <span class="hljs-built_in">isSubStructure</span>(A-&gt;right, B);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isInclude</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pRoot2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (pRoot1 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (pRoot1-&gt;val != pRoot2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isInclude</span>(pRoot1-&gt;left, pRoot2-&gt;left) <span class="hljs-keyword">and</span> <br>           <span class="hljs-built_in">isInclude</span>(pRoot1-&gt;right, pRoot2-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes</title>
    <link href="/1976/04/01/LeetcodeNotes/"/>
    <url>/1976/04/01/LeetcodeNotes/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/bigbigwanglei/Algorithm/blob/master/Sort.md">资料库</a></p><h1 id="leetcode-1370-上下字符串"><a href="#leetcode-1370-上下字符串" class="headerlink" title="leetcode 1370 上下字符串"></a>leetcode 1370 上下字符串</h1><p>index 从后往前遍历的时候 千万要注意 删除操作 对于index的位移</p><hr><h3 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290. 单词规律"></a><a href="https://leetcode-cn.com/problems/word-pattern/">290. 单词规律</a></h3><p><code>如果我们有 两个对象 他们必须一一对应 我们最好创建两个哈希表</code></p><p>实现这种一一对应的关系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">    <span class="hljs-comment">//assume A is char and B is int | C is char too</span><br>    <span class="hljs-comment">//simulate A =&gt; B and C also =&gt; B</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; dict;<br>    <span class="hljs-type">char</span> A = <span class="hljs-string">&#x27;A&#x27;</span>, C = <span class="hljs-string">&#x27;C&#x27;</span>;<br>    <span class="hljs-type">int</span> B = <span class="hljs-number">17</span>;<br>    dict[B] = A;<br>    dict[B] = C;     <span class="hljs-comment">//只有 hash key是被保护的对象 被保护对象不可以重复</span><br><span class="hljs-comment">// 如果两者都是被保护对象 那只能建立两个hash table</span><br></code></pre></td></tr></table></figure><hr><ul><li><h3 id="我们将环岛划分为-n-个结点，要走过所有的结点，会漏下一段，想要求最短行进距离，只要漏下的最长即可"><a href="#我们将环岛划分为-n-个结点，要走过所有的结点，会漏下一段，想要求最短行进距离，只要漏下的最长即可" class="headerlink" title="我们将环岛划分为 n 个结点，要走过所有的结点，会漏下一段，想要求最短行进距离，只要漏下的最长即可"></a>我们将环岛划分为 n 个结点，要走过所有的结点，会漏下一段，想要求最短行进距离，只要漏下的最长即可</h3></li></ul><hr><h2 id="leetcode-387-找到第一个唯一字符"><a href="#leetcode-387-找到第一个唯一字符" class="headerlink" title="leetcode 387 找到第一个唯一字符"></a>leetcode 387 找到第一个唯一字符</h2><p>如题 我们要在一个字符串里找到<strong>第一个</strong> 不和后面任何字符重复的唯一出现一次的字符</p><ul><li>队列 + 延迟删除(每次检测到出现重复字符都会触发一个循环删除操作(当然 这其实挺慢的))</li></ul><p>由于队列的 FIFO属性 如果想找到第一个符合要求的元素 使用队列是方便的</p><hr><h3 id="2021-2-7｜665-非递减序列"><a href="#2021-2-7｜665-非递减序列" class="headerlink" title="2021. 2. 7｜665 非递减序列"></a><a href="https://leetcode-cn.com/problems/non-decreasing-array/">2021. 2. 7｜665 非递减序列</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 4 2 5</span><br><span class="hljs-comment">// 1 4 2 5</span><br><span class="hljs-comment">// 3 4 2 5  3种情况</span><br><span class="hljs-comment">// 当我们发现nums[i] &lt; nums[i-1] 时 应该优先调整num[i-1]的值 因为nums[i]变大会影响之后的判断</span><br><span class="hljs-comment">// 所以我们只需要知道 nums[i-1]最小能变到多小 显然，就是nums[i-2]的大小。</span><br><span class="hljs-comment">// 但如果nums[i]比nums[i-2]更小， 这意味着我们不得不调整nums[i]的值使得它和nums[i-1]一样。</span><br></code></pre></td></tr></table></figure><h3 id="2-7｜5674-构造字典序最大的合并字符串"><a href="#2-7｜5674-构造字典序最大的合并字符串" class="headerlink" title="2.7｜5674 构造字典序最大的合并字符串"></a><a href="https://leetcode-cn.com/problems/largest-merge-of-two-strings/">2.7｜5674 构造字典序最大的合并字符串</a></h3><blockquote><h3 id="总之两边每次都拿最大的那个，问题在于-如果说两个字符串的头都一样大，应当拿的是子字符串最大的那个-「使用-substr-i-」"><a href="#总之两边每次都拿最大的那个，问题在于-如果说两个字符串的头都一样大，应当拿的是子字符串最大的那个-「使用-substr-i-」" class="headerlink" title="总之两边每次都拿最大的那个，问题在于 如果说两个字符串的头都一样大，应当拿的是子字符串最大的那个 「使用 substr(i)」"></a>总之两边每次都拿最大的那个，问题在于 如果说两个字符串的头都一样大，应当拿的是子字符串最大的那个 「使用 substr(i)」</h3></blockquote><hr><h3 id="2-8｜978最长湍流子数组-和交替子序列比起来，这个是要求连续最长的-需要进行互相继承-优化了dp"><a href="#2-8｜978最长湍流子数组-和交替子序列比起来，这个是要求连续最长的-需要进行互相继承-优化了dp" class="headerlink" title="2.8｜978最长湍流子数组  和交替子序列比起来，这个是要求连续最长的 需要进行互相继承 优化了dp"></a>2.8｜978最长湍流子数组  和<code>交替子序列</code>比起来，这个是要求连续最长的 需要进行互相继承 优化了dp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxTurbulenceSize</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-comment">// 摆动上升记为up，摆动下降记为down  这个其实是动态规划的优化版本</span><br>        <span class="hljs-type">int</span> up = <span class="hljs-number">1</span>, down = <span class="hljs-number">1</span>, n = arr.<span class="hljs-built_in">size</span>(), res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-comment">// 我们应当注意的是 虽然up好像被清零了，但实际上它的值被继承到了down里，它们两个是交替继承到</span><br>            <span class="hljs-comment">// 建议先完全理解动态规划方法解决这个问题</span><br>            <span class="hljs-keyword">if</span> (arr[i] == arr[i<span class="hljs-number">-1</span>]) &#123;<br>                up = <span class="hljs-number">1</span>;<br>                down = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i<span class="hljs-number">-1</span>]) &#123;<br>                up = down + <span class="hljs-number">1</span>;<br>                down = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                down = up + <span class="hljs-number">1</span>;<br>                up = <span class="hljs-number">1</span>;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">max</span>(up, down));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-11｜703-数据流中的第K大元素-「不断的添加数据到一个数组中，我们每次都要第k大的元素」"><a href="#2-11｜703-数据流中的第K大元素-「不断的添加数据到一个数组中，我们每次都要第k大的元素」" class="headerlink" title="2.11｜703 数据流中的第K大元素  「不断的添加数据到一个数组中，我们每次都要第k大的元素」"></a>2.11｜<a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/">703 数据流中的第K大元素  「不断的添加数据到一个数组中，我们每次都要第k大的元素」</a></h3><blockquote><h3 id="只关注前K大，我们用数组中-前k大的元素组成一个最小堆，并且维持堆的大小为K-堆顶的就是目前第k大的元素-。"><a href="#只关注前K大，我们用数组中-前k大的元素组成一个最小堆，并且维持堆的大小为K-堆顶的就是目前第k大的元素-。" class="headerlink" title="只关注前K大，我们用数组中&#x3D;&#x3D;前k大的元素组成一个最小堆，并且维持堆的大小为K&#x3D;&#x3D;(堆顶的就是目前第k大的元素)。"></a>只关注前K大，我们用数组中&#x3D;&#x3D;前k大的元素组成一个最小堆，并且维持堆的大小为K&#x3D;&#x3D;(堆顶的就是目前第k大的元素)。</h3><h3 id="之后每次添加元素val，如果val比目前的堆顶小，那么它将被pop掉，如果它比堆顶要大，那么堆顶将被pop掉，第K大元素将会发生变更。"><a href="#之后每次添加元素val，如果val比目前的堆顶小，那么它将被pop掉，如果它比堆顶要大，那么堆顶将被pop掉，第K大元素将会发生变更。" class="headerlink" title="之后每次添加元素val，如果val比目前的堆顶小，那么它将被pop掉，如果它比堆顶要大，那么堆顶将被pop掉，第K大元素将会发生变更。"></a>之后每次添加元素val，如果val比目前的堆顶小，那么它将被pop掉，如果它比堆顶要大，那么堆顶将被pop掉，第K大元素将会发生变更。</h3><h5 id="初始数据-4-5-8-2-｜-第3大"><a href="#初始数据-4-5-8-2-｜-第3大" class="headerlink" title="初始数据 4 5 8 2  ｜ 第3大"></a>初始数据 4 5 8 2  ｜ 第3大</h5><h4 id="我们的堆中存有-4-5-8-，add-3的时候，3比4还小，所以它不会影响到第K大元素，-它会被放在堆顶，直接被pop掉"><a href="#我们的堆中存有-4-5-8-，add-3的时候，3比4还小，所以它不会影响到第K大元素，-它会被放在堆顶，直接被pop掉" class="headerlink" title="我们的堆中存有 4 5 8  ，add 3的时候，3比4还小，所以它不会影响到第K大元素， 它会被放在堆顶，直接被pop掉"></a>我们的堆中存有 4 5 8  ，add 3的时候，3比4还小，所以它不会影响到第K大元素， 它会被放在堆顶，直接被pop掉</h4><h4 id="如果add-的是5，-那么4会在堆顶，它现在已经不是第3大的元素了，4被pop掉。"><a href="#如果add-的是5，-那么4会在堆顶，它现在已经不是第3大的元素了，4被pop掉。" class="headerlink" title="如果add 的是5， 那么4会在堆顶，它现在已经不是第3大的元素了，4被pop掉。"></a>如果add 的是5， 那么4会在堆顶，它现在已经不是第3大的元素了，4被pop掉。</h4></blockquote><hr><h3 id="2-13｜448-找到1-n之中所有消失的数字"><a href="#2-13｜448-找到1-n之中所有消失的数字" class="headerlink" title="2.13｜448 找到1-n之中所有消失的数字"></a>2.13｜<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">448 找到1-n之中所有消失的数字</a></h3><h4 id="题：数组大小为n，它理应包含从1-n的连续不同的数字。"><a href="#题：数组大小为n，它理应包含从1-n的连续不同的数字。" class="headerlink" title="题：数组大小为n，它理应包含从1-n的连续不同的数字。"></a>题：数组大小为n，它理应包含从1-n的连续不同的数字。</h4><h4 id="但是有一些数字出现了多次，我们现在需要用一个数组返回数组中缺失的-范围在1-n之间的数字"><a href="#但是有一些数字出现了多次，我们现在需要用一个数组返回数组中缺失的-范围在1-n之间的数字" class="headerlink" title="但是有一些数字出现了多次，我们现在需要用一个数组返回数组中缺失的 范围在1-n之间的数字"></a>但是有一些数字出现了多次，我们现在需要用一个数组返回数组中缺失的 范围在1-n之间的数字</h4><blockquote><h3 id="关键在于-数的范围和下标的范围差不多-构建的直接就是下标对应的联系"><a href="#关键在于-数的范围和下标的范围差不多-构建的直接就是下标对应的联系" class="headerlink" title="关键在于 &#x3D;&#x3D;数的范围和下标的范围差不多 构建的直接就是下标对应的联系&#x3D;&#x3D;"></a>关键在于 &#x3D;&#x3D;数的范围和下标的范围差不多 构建的直接就是下标对应的联系&#x3D;&#x3D;</h3><h4 id="nums-i-的出现-直接将-nums-nums-i-1-n-n-可以把-n去掉，可能本来就已经加上了"><a href="#nums-i-的出现-直接将-nums-nums-i-1-n-n-可以把-n去掉，可能本来就已经加上了" class="headerlink" title="nums[i] 的出现 直接将 nums[nums[i]-1] + n (%n 可以把+n去掉，可能本来就已经加上了)"></a>nums[i] 的出现 直接将 nums[nums[i]-1] + n (%n 可以把+n去掉，可能本来就已经加上了)</h4></blockquote><hr><h3 id="3-2-304-二维区域和检索-矩阵不可变"><a href="#3-2-304-二维区域和检索-矩阵不可变" class="headerlink" title="3.2 | 304. 二维区域和检索 - 矩阵不可变"></a>3.2 | <a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></h3><blockquote><p>多次调用了矩阵的前缀和,我们可以一开始就全给他算出来,改成前缀模式 这样比较省时间.</p></blockquote><h2 id="3-4-1438-绝对差不超过限制的最长连续子数组"><a href="#3-4-1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="3.4 | 1438. 绝对差不超过限制的最长连续子数组"></a>3.4 | <a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a></h2><h3 id="「想要每次都拿出最大值和最小值-可以使用multiset」"><a href="#「想要每次都拿出最大值和最小值-可以使用multiset」" class="headerlink" title="「想要每次都拿出最大值和最小值 可以使用multiset」"></a>「想要每次都拿出最大值和最小值 可以使用multiset」</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ⚠️ 要求的子数组里 任意两个元素 的差 不能超过limit!! 不是相邻元素</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>        multiset&lt;<span class="hljs-type">int</span>&gt; count;   <span class="hljs-comment">// 为什么使用 multiset ? 因为我们需要保证有序 而且同时需要最大和最小元素 「这意味着堆(priority_queue 是基于队列实现的 所以不支持拿最后尾元素)的不可使用」</span><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>(), left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            count.<span class="hljs-built_in">insert</span>(nums[right]); <span class="hljs-comment">//默认是从小到大排序</span><br>            <span class="hljs-keyword">while</span> (*count.<span class="hljs-built_in">rbegin</span>() - *count.<span class="hljs-built_in">begin</span>() &gt; limit) &#123;<br>                count.<span class="hljs-built_in">erase</span>(count.<span class="hljs-built_in">find</span>(nums[left++]));    <span class="hljs-comment">// multiset -&gt; erase </span><br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(right-left<span class="hljs-number">+1</span>, res);<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="3-6-503-下一个更大元素-II"><a href="#3-6-503-下一个更大元素-II" class="headerlink" title="3.6 | 503. 下一个更大元素 II"></a>3.6 | <a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h3><h3 id="1-单调栈"><a href="#1-单调栈" class="headerlink" title="1. 单调栈"></a>1. 单调栈</h3><h4 id="对于每个数都需要找到下一个比它大的元素-栈中存储的相当于一个降序的序列-只要出现一个更大的-栈中所有元素对应的下一个更大-都是它"><a href="#对于每个数都需要找到下一个比它大的元素-栈中存储的相当于一个降序的序列-只要出现一个更大的-栈中所有元素对应的下一个更大-都是它" class="headerlink" title="对于每个数都需要找到下一个比它大的元素, 栈中存储的相当于一个降序的序列 只要出现一个更大的 栈中所有元素对应的下一个更大 都是它"></a>对于每个数都需要找到下一个比它大的元素, 栈中存储的相当于一个降序的序列 只要出现一个更大的 栈中所有元素对应的下一个更大 都是它</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        stack&lt;<span class="hljs-type">int</span>&gt; tedious;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!tedious.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i % n] &gt; nums[tedious.<span class="hljs-built_in">top</span>()]) &#123;<br>                res[tedious.<span class="hljs-built_in">top</span>()] = nums[i % n];<br>                tedious.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            tedious.<span class="hljs-built_in">push</span>(i % n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="⚠️-可以通过「-capacity」-来实现对于数组的逻辑拉长-「⚠️-i-2-n-1-是省了一次-不是越界」"><a href="#⚠️-可以通过「-capacity」-来实现对于数组的逻辑拉长-「⚠️-i-2-n-1-是省了一次-不是越界」" class="headerlink" title="&#x3D;&#x3D;⚠️ 可以通过「 % capacity」 来实现对于数组的逻辑拉长 「⚠️ i  &lt; 2*n-1  是省了一次 不是越界」&#x3D;&#x3D;"></a>&#x3D;&#x3D;⚠️ 可以通过「 % capacity」 来实现对于数组的逻辑拉长 「⚠️ i  &lt; 2*n-1  是省了一次 不是越界」&#x3D;&#x3D;</h3><h3 id="3-6-快速幂-本质上讲-是利用了递归的-栈逻辑-x-n-x-n-2-x-n-2-…"><a href="#3-6-快速幂-本质上讲-是利用了递归的-栈逻辑-x-n-x-n-2-x-n-2-…" class="headerlink" title="3.6 | 快速幂   本质上讲 是利用了递归的 栈逻辑  x^n &#x3D; x ^ n&#x2F;2 * x ^ n&#x2F;2 …"></a>3.6 | 快速幂   本质上讲 是利用了递归的 栈逻辑  x^n &#x3D; x ^ n&#x2F;2 * x ^ n&#x2F;2 …</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> N = n;<br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">quickMulit</span>(x, N) : <span class="hljs-number">1.0</span>/<span class="hljs-built_in">quickMulit</span>(x, -N);<br>    &#125;  <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">quickMulit</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">long</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-type">double</span> y = <span class="hljs-built_in">quickMulit</span>(x, n / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//为奇数</span><br>            <span class="hljs-keyword">return</span> x * y * y;<br>        &#125;<br>        <span class="hljs-keyword">return</span> y * y;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-9-1047-删除字符串中的所有相邻重复项"><a href="#3-9-1047-删除字符串中的所有相邻重复项" class="headerlink" title="3.9 | 1047. 删除字符串中的所有相邻重复项"></a>3.9 | <a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h3><blockquote><h3 id="利用栈的性质解题-但注意的是-string-支持-pop-back-和-back-操作-我们可以直接将其理解为一个栈来做-「同样的道理-在a-b-hard中-我们也可以这样来用string-替代掉stack」"><a href="#利用栈的性质解题-但注意的是-string-支持-pop-back-和-back-操作-我们可以直接将其理解为一个栈来做-「同样的道理-在a-b-hard中-我们也可以这样来用string-替代掉stack」" class="headerlink" title="利用栈的性质解题 但注意的是 string 支持 pop_back() 和 back()操作  我们可以直接将其理解为一个栈来做 「同样的道理, 在a+b hard中, 我们也可以这样来用string 替代掉stack」"></a>利用栈的性质解题 但注意的是 string 支持 pop_back() 和 back()操作  我们可以直接将其理解为一个栈来做 「同样的道理, 在a+b hard中, 我们也可以这样来用string 替代掉stack」</h3></blockquote><h3 id="3-9-283-移动零-「把数组中某一特定值-此处是0-的元素-全部拿到队伍的末尾去」"><a href="#3-9-283-移动零-「把数组中某一特定值-此处是0-的元素-全部拿到队伍的末尾去」" class="headerlink" title="3.9 | 283 移动零 「把数组中某一特定值(此处是0)的元素 全部拿到队伍的末尾去」"></a>3.9 | 283 移动零 「把数组中某一特定值(此处是0)的元素 全部拿到队伍的末尾去」</h3><h2 id="「快慢指针」right指针一直前进-而left指针则停留在最后一个一定需要交换来解决问题的元素上-⚠️-在left-和right-都满足的时候-两者就都自加"><a href="#「快慢指针」right指针一直前进-而left指针则停留在最后一个一定需要交换来解决问题的元素上-⚠️-在left-和right-都满足的时候-两者就都自加" class="headerlink" title="「快慢指针」right指针一直前进,而left指针则停留在最后一个一定需要交换来解决问题的元素上 (⚠️ 在left 和right 都满足的时候, 两者就都自加)"></a>「快慢指针」right指针一直前进,而left指针则停留在最后一个一定需要交换来解决问题的元素上 (⚠️ 在left 和right 都满足的时候, 两者就都自加)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZero</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums )</span> </span>&#123;<br>  <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (right &lt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>      <span class="hljs-keyword">if</span> (nums[right]) <span class="hljs-built_in">swap</span>(nums[right], nums[left ++]);<br>      ++ right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-15-54-螺旋矩阵-螺旋输出一个矩阵"><a href="#3-15-54-螺旋矩阵-螺旋输出一个矩阵" class="headerlink" title="3.15 54. 螺旋矩阵 螺旋输出一个矩阵"></a>3.15 <a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a> 螺旋输出一个矩阵</h3><h3 id="考虑矩阵的四个角-「top-right-left-bottom-」-用这四个变量标记它们"><a href="#考虑矩阵的四个角-「top-right-left-bottom-」-用这四个变量标记它们" class="headerlink" title="考虑矩阵的四个角 「top right left bottom 」 用这四个变量标记它们"></a>考虑矩阵的四个角 「top right left bottom 」 用这四个变量标记它们</h3><ul><li><h3 id="此题由于输出的总数已经知道-我们应该设置一个恒定的标记-让它减少到0来判断是否应该结束循环-而不是加入超多的判断语句"><a href="#此题由于输出的总数已经知道-我们应该设置一个恒定的标记-让它减少到0来判断是否应该结束循环-而不是加入超多的判断语句" class="headerlink" title="此题由于输出的总数已经知道,我们应该设置一个恒定的标记 让它减少到0来判断是否应该结束循环,而不是加入超多的判断语句."></a>此题由于输出的总数已经知道,我们应该设置一个恒定的标记 让它减少到0来判断是否应该结束循环,而不是加入超多的判断语句.</h3></li></ul><hr><h3 id="3-14-检查5张牌是否为顺子-「排序后-看最大和最小-差距大于等于5-就不行啦」"><a href="#3-14-检查5张牌是否为顺子-「排序后-看最大和最小-差距大于等于5-就不行啦」" class="headerlink" title="3.14  检查5张牌是否为顺子 「排序后,看最大和最小 差距大于等于5 就不行啦」"></a>3.14  检查5张牌是否为顺子 「排序后,看最大和最小 差距大于等于5 就不行啦」</h3><h4 id="3-17-层序遍历-分层输出"><a href="#3-17-层序遍历-分层输出" class="headerlink" title="3.17  层序遍历,分层输出"></a>3.17  层序遍历,分层输出</h4><h4 id="分层的要点在于-我们在原有的while循环里加入一个for循环-对于原本就在队列中的n个结点-这个循环的目标就是把它们的孩子都加入队列-同时把它们都pop出去"><a href="#分层的要点在于-我们在原有的while循环里加入一个for循环-对于原本就在队列中的n个结点-这个循环的目标就是把它们的孩子都加入队列-同时把它们都pop出去" class="headerlink" title="分层的要点在于, 我们在原有的while循环里加入一个for循环, 对于原本就在队列中的n个结点,这个循环的目标就是把它们的孩子都加入队列, 同时把它们都pop出去."></a>分层的要点在于, 我们在原有的while循环里加入一个for循环, 对于原本就在队列中的n个结点,这个循环的目标就是把它们的孩子都加入队列, 同时把它们都pop出去.</h4><h4 id="3-17-股票的最大利润-「只可以买卖一次」「实际上就是求数组最大的元素差-其中大的元素一定要在小的后面」"><a href="#3-17-股票的最大利润-「只可以买卖一次」「实际上就是求数组最大的元素差-其中大的元素一定要在小的后面」" class="headerlink" title="3.17 股票的最大利润 「只可以买卖一次」「实际上就是求数组最大的元素差,其中大的元素一定要在小的后面」"></a>3.17 股票的最大利润 「只可以买卖一次」「实际上就是求数组最大的元素差,其中大的元素一定要在小的后面」</h4><p><code>minprice 保证了在位于 price处 时候, minprice一定是当前最小的那个值了.  而maxprice 则利用了这一点</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> price: nums) &#123;<br>      maxprofit = <span class="hljs-built_in">max</span>(maxprofit, price - minprice);<br>      minprice = <span class="hljs-built_in">min</span>(price, minprice);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-20-150-逆波兰表达式求值"><a href="#3-20-150-逆波兰表达式求值" class="headerlink" title="3.20 | 150. 逆波兰表达式求值"></a>3.20 | <a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h3><h4 id="逆波兰表达式的解法很简单-数字直接入栈-见运算符就把两个拿出来计算之后push回去-⚠️-isdigit-是对字符生效的函数-以及-stoi-字符串转int-函数-值的注意的是-没有itos-哦"><a href="#逆波兰表达式的解法很简单-数字直接入栈-见运算符就把两个拿出来计算之后push回去-⚠️-isdigit-是对字符生效的函数-以及-stoi-字符串转int-函数-值的注意的是-没有itos-哦" class="headerlink" title="逆波兰表达式的解法很简单, 数字直接入栈, 见运算符就把两个拿出来计算之后push回去.  ⚠️ isdigit 是对字符生效的函数, 以及 stoi  字符串转int 函数.  值的注意的是 没有itos 哦!"></a>逆波兰表达式的解法很简单, 数字直接入栈, 见运算符就把两个拿出来计算之后push回去.  ⚠️ isdigit 是对字符生效的函数, 以及 stoi  字符串转int 函数.  值的注意的是 没有itos 哦!</h4><hr><h4 id="3-22-爬楼梯"><a href="#3-22-爬楼梯" class="headerlink" title="3.22 | 爬楼梯"></a>3.22 | 爬楼梯</h4><h4 id="456-132-模式-「看数组里-是否有这样的三个元素-i-j-k-它们满足-i-j-k-同时-nums-i-nums-k-nums-j-」"><a href="#456-132-模式-「看数组里-是否有这样的三个元素-i-j-k-它们满足-i-j-k-同时-nums-i-nums-k-nums-j-」" class="headerlink" title="456. 132 模式  「看数组里 是否有这样的三个元素 i j k 它们满足 i &lt; j &lt; k, 同时 nums[i] &lt; nums[k] &lt; nums[j]」"></a><a href="https://leetcode-cn.com/problems/132-pattern/">456. 132 模式</a>  「看数组里 是否有这样的三个元素 i j k 它们满足 i &lt; j &lt; k, 同时 nums[i] &lt; nums[k] &lt; nums[j]」</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// i &lt; j &lt; k || nums[i] &lt; nums[k] &lt; nums[j]</span><br>    <span class="hljs-comment">// 这个题的问题在于 我们只需要知道有没有即可, 我们是不需要提供下标的!</span><br>    <span class="hljs-comment">// 不可以使用priorityqueue来存储k的所有可能性 想想为什么</span><br>   <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find132pattern</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left_min = nums[<span class="hljs-number">0</span>], j = <span class="hljs-number">1</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        multiset&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) s.<span class="hljs-built_in">insert</span>(nums[i]);<br>        <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (left_min &lt; nums[j]) &#123;<br>                <span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">begin</span>();<br>                <span class="hljs-keyword">while</span> (it != s.<span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-keyword">if</span> (*it &lt; nums[j] &amp;&amp; *it &gt; left_min) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    ++it;<br>                &#125;<br>            &#125;<br>            s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">find</span>(nums[j<span class="hljs-number">+1</span>])); <span class="hljs-comment">//这里使用erase 会一次删除掉所有值为val的元素,</span><br>            <span class="hljs-comment">// for (auto it = s.begin(); it != s.end(); ++it) &#123;</span><br>            <span class="hljs-comment">//     if (*it == nums[j+1]) &#123;</span><br>            <span class="hljs-comment">//         *it = 1e9+1;    </span><br>            <span class="hljs-comment">//     &#125;</span><br>            <span class="hljs-comment">// &#125;</span><br>            left_min = <span class="hljs-built_in">min</span>(left_min, nums[j++]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="⚠️-1-erase-如果里面直接给出元素-会直接删除所有的该元素-也可以使用find-这样只会删除第一个遇见的-2-迭代器只是遍历工具-我们是不能通过迭代器来修改容器内的值的"><a href="#⚠️-1-erase-如果里面直接给出元素-会直接删除所有的该元素-也可以使用find-这样只会删除第一个遇见的-2-迭代器只是遍历工具-我们是不能通过迭代器来修改容器内的值的" class="headerlink" title="&#x3D;&#x3D;⚠️ 1. erase 如果里面直接给出元素, 会直接删除所有的该元素,  也可以使用find 这样只会删除第一个遇见的. 2.迭代器只是遍历工具, 我们是不能通过迭代器来修改容器内的值的!&#x3D;&#x3D;"></a>&#x3D;&#x3D;⚠️ 1. erase 如果里面直接给出元素, 会直接删除所有的该元素,  也可以使用find 这样只会删除第一个遇见的. 2.迭代器只是遍历工具, 我们是不能通过迭代器来修改容器内的值的!&#x3D;&#x3D;</h4><h3 id="4-12-179-最大数-「一个数组-把里面的数字拼成一个-字典序最大的字符串」"><a href="#4-12-179-最大数-「一个数组-把里面的数字拼成一个-字典序最大的字符串」" class="headerlink" title="4.12 179. 最大数 「一个数组 把里面的数字拼成一个 字典序最大的字符串」"></a>4.12 <a href="https://leetcode-cn.com/problems/largest-number/">179. 最大数</a> 「一个数组 把里面的数字拼成一个 字典序最大的字符串」</h3><blockquote><p>很容易想到在匿名函数里转字符串比较字典序. </p><h4 id="但我们可以直接利用整数来尝试拼接"><a href="#但我们可以直接利用整数来尝试拼接" class="headerlink" title="但我们可以直接利用整数来尝试拼接."></a>但我们可以直接利用整数来尝试拼接.</h4></blockquote><hr><h3 id="1738-找出第K大的异或坐标值「要注意前缀和从0开始」-https-leetcode-cn-com-problems-find-kth-largest-xor-coordinate-value"><a href="#1738-找出第K大的异或坐标值「要注意前缀和从0开始」-https-leetcode-cn-com-problems-find-kth-largest-xor-coordinate-value" class="headerlink" title="[1738. 找出第K大的异或坐标值「要注意前缀和从0开始」][https://leetcode- cn.com&#x2F;problems&#x2F;find-kth-largest-xor-coordinate-value&#x2F;]"></a>[1738. 找出第K大的异或坐标值「要注意前缀和从0开始」][<a href="https://leetcode-/">https://leetcode-</a> cn.com&#x2F;problems&#x2F;find-kth-largest-xor-coordinate-value&#x2F;]</h3><p>关于二维前缀和的解释如下: </p><p>所以 <code>prefix[i][j] = prefix[i][j-1]^prefix[i-1][j]^prefix[i-1][j-1]^matrix[i-1][j-1]</code></p><hr><h3 id="在342-4的幂"><a href="#在342-4的幂" class="headerlink" title="在342. 4的幂"></a>在<a href="https://leetcode-cn.com/problems/power-of-four/">342. 4的幂</a></h3><h5 id="1-偶数位上是1的32位整形-0xaaaaaaaa"><a href="#1-偶数位上是1的32位整形-0xaaaaaaaa" class="headerlink" title="1. 偶数位上是1的32位整形, 0xaaaaaaaa"></a>1. 偶数位上是1的32位整形, 0xaaaaaaaa</h5><hr><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><ul><li><h4 id="accumulate-函数，到nums-begin-k，是不包括下标k的！并且-accmulate-所需要的时间是很短的-使用accumulate来检测数组中是否只有0是一个可行的选择。"><a href="#accumulate-函数，到nums-begin-k，是不包括下标k的！并且-accmulate-所需要的时间是很短的-使用accumulate来检测数组中是否只有0是一个可行的选择。" class="headerlink" title="accumulate 函数，到nums.begin()+k，是不包括下标k的！并且 accmulate 所需要的时间是很短的  使用accumulate来检测数组中是否只有0是一个可行的选择。"></a>accumulate 函数，到nums.begin()+k，是不包括下标k的！并且 accmulate 所需要的时间是很短的  使用accumulate来检测数组中是否只有0是一个可行的选择。</h4></li><li><p>index 从后往前遍历的时候 千万要注意 删除操作 对于index的位移</p></li><li><h3 id="如何用队列实现栈-「一个队列-每次push-都把队列转个圈」-如何用栈实现队列-「两个栈-in-out-push全部进入输入栈-每次执行pop或者top操作时如果输出栈为空就把输入栈的元素全部push进输出栈」"><a href="#如何用队列实现栈-「一个队列-每次push-都把队列转个圈」-如何用栈实现队列-「两个栈-in-out-push全部进入输入栈-每次执行pop或者top操作时如果输出栈为空就把输入栈的元素全部push进输出栈」" class="headerlink" title="如何用队列实现栈?  「一个队列 每次push 都把队列转个圈」 如何用栈实现队列? 「两个栈(in &#x2F; out) push全部进入输入栈, 每次执行pop或者top操作时如果输出栈为空就把输入栈的元素全部push进输出栈」"></a>如何用队列实现栈?  「一个队列 每次push 都把队列转个圈」 如何用栈实现队列? 「两个栈(in &#x2F; out) push全部进入输入栈, 每次执行pop或者top操作时如果输出栈为空就把输入栈的元素全部push进输出栈」</h3></li><li><h3 id="c-17-添加了新的特性-对于一个hashtable-dist-「for-auto-y-x-dist」-顺序和原来相同"><a href="#c-17-添加了新的特性-对于一个hashtable-dist-「for-auto-y-x-dist」-顺序和原来相同" class="headerlink" title="c++ 17 添加了新的特性 对于一个hashtable dist  「for (auto &amp;[y, x] : dist」&#x2F;&#x2F; 顺序和原来相同"></a>c++ 17 添加了新的特性 对于一个hashtable dist  「for (auto &amp;[y, x] : dist」&#x2F;&#x2F; 顺序和原来相同</h3></li><li><h2 id="两个变量交换"><a href="#两个变量交换" class="headerlink" title="两个变量交换"></a>两个变量交换</h2><blockquote><p>a &#x3D; a - b; b &#x3D; b - a; a &#x3D; a + b; &#x2F;&#x2F;法1</p><h3 id="a-a-b-b-a-b-a-a-b-法2"><a href="#a-a-b-b-a-b-a-a-b-法2" class="headerlink" title="a &#x3D; a ^ b ; b &#x3D; a ^ b; a &#x3D; a ^ b;  &#x2F;&#x2F; 法2"></a>a &#x3D; a ^ b ; b &#x3D; a ^ b; a &#x3D; a ^ b;  &#x2F;&#x2F; 法2</h3></blockquote></li></ul><h4 id="·想要返回正确的double值，把被除数转成double型，而不是把结果转为double"><a href="#·想要返回正确的double值，把被除数转成double型，而不是把结果转为double" class="headerlink" title="·想要返回正确的double值，把被除数转成double型，而不是把结果转为double"></a>·想要返回正确的double值，把被除数转成double型，而不是把结果转为double</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> <span class="hljs-built_in">double</span>(<span class="hljs-number">3</span>/<span class="hljs-number">2</span>) =&gt; <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">double</span>(<span class="hljs-number">3</span>)/<span class="hljs-number">2</span> =&gt; <span class="hljs-number">1.5</span><br></code></pre></td></tr></table></figure><ul><li><p>字符与int之间的转化是简单的,  只需要加减<code>&#39;0&#39; </code> 就可以了,   字符串则可以通过 stoi 和 to_string 函数来实现! </p></li><li><p>斐波那契数列 在n特别大时 采取矩阵快速幂的方法 能够求解 (滚动都太慢了)</p></li><li><h2 id="操作符-和-操作符的区别-「-左边是指针-左边是实体」-p-a-p是指针-p-a-p是实体"><a href="#操作符-和-操作符的区别-「-左边是指针-左边是实体」-p-a-p是指针-p-a-p是实体" class="headerlink" title="-&gt; 操作符 和 . 操作符的区别 「-&gt; 左边是指针  . 左边是实体」 (p -&gt; a()  p是指针,  p.a()  p是实体)"></a><code>-&gt;</code> 操作符 和 <code>.</code> 操作符的区别 「-&gt; 左边是指针  . 左边是实体」 <code>(p -&gt; a()  p是指针,  p.a()  p是实体)</code></h2></li><li></li><li><p><code>nth_element(res.begin(), res.begin() + k, res.end(), greater&lt;int&gt;()). </code> 寻找res中第k大的元素, 并将它放在第k个位置(默认是第k小)  「处理完之后,  K之前的全都比他大, K之后的全部比它小(比排序快上一点)」</p></li><li><p>STL copy </p><p>std::copy(start, end, container.begin());    &#x2F;&#x2F; container 是复制到的那个容器的第一个元素， 因为复制到这个已有元素后更加高效</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Algorithm Notes</title>
    <link href="/1976/04/01/Leetcode%20Algorithm%20Notes/"/>
    <url>/1976/04/01/Leetcode%20Algorithm%20Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter1-Sliding-Window"><a href="#Chapter1-Sliding-Window" class="headerlink" title="Chapter1 Sliding Window"></a>Chapter1 Sliding Window</h1><h3 id="424-替换后的最长重复字符「Medium」"><a href="#424-替换后的最长重复字符「Medium」" class="headerlink" title="424. 替换后的最长重复字符「Medium」"></a><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符「Medium」</a></h3><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 <em>k</em> 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><p><strong>注意：</strong>字符串长度 和 <em>k</em> 不会超过 $10^4$。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;ABAB&quot;, k = 2<br>输出：4<br>解释：用两个&#x27;A&#x27;替换为两个&#x27;B&#x27;,反之亦然。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;AABABBA&quot;, k = 1<br>输出：4<br>解释：<br>将中间的一个&#x27;A&#x27;替换为&#x27;B&#x27;,字符串变为 &quot;AABBBBA&quot;。<br>子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><p>​我们可以枚举字符串中的每一个位置作为右端点，然后找到其最远的左端点的位置，满足该区间内除了出现次数最多的那一类字符之外，剩余的字符（即非最长重复字符）数量不超过 $k$ 个。</p><p>​这样我们可以想到使用双指针维护这些区间，每次右指针右移，如果区间仍然满足条件，那么左指针不移动，否则左指针至多右移一格，保证区间长度不减小。</p><p>​虽然这样的操作会导致部分区间不符合条件，即该区间内非最长重复字符超过了 $k$ 个。但是这样的区间也同样不可能对答案产生贡献。当我们右指针移动到尽头，左右指针对应的区间的长度必然对应一个长度最大的符合条件的区间。</p><p>​实际代码中，由于字符串中仅包含大写字母，我们可以使用一个长度为 $26$ 的数组维护每一个字符的出现次数。每次区间右移，我们更新右移位置的字符出现的次数，然后尝试用它<strong>更新重复字符出现次数的历史最大值</strong>，最后我们使用该最大值计算出区间内非最长重复字符的数量，以此判断左指针是否需要右移即可。</p></blockquote><p>变式「Medium 简单版」：<a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">characterReplacement</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> maxn = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            num[s[right] - <span class="hljs-string">&#x27;A&#x27;</span>]++;<br>            maxn = <span class="hljs-built_in">max</span>(maxn, num[s[right] - <span class="hljs-string">&#x27;A&#x27;</span>]);<br>            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> - maxn &gt; k) &#123;<br>                num[s[left] - <span class="hljs-string">&#x27;A&#x27;</span>]--;<br>                left++;<br>            &#125;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right - left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1423-可获得的最大点数「Medium」"><a href="#1423-可获得的最大点数「Medium」" class="headerlink" title="1423. 可获得的最大点数「Medium」"></a><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/">1423. 可获得的最大点数「Medium」</a></h3><p>几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。</p><p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。</p><p>你的点数就是你拿到手中的所有卡牌的点数之和。</p><p>给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。</p><p><strong>示例 1：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">输入：cardPoints = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">12</span><br>解释：第一次行动，不管拿哪张牌，你的点数总是 <span class="hljs-number">1</span> 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 <span class="hljs-number">1</span> + <span class="hljs-number">6</span> + <span class="hljs-number">5</span> = <span class="hljs-number">12</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">输入：cardPoints = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">4</span><br>解释：无论你拿起哪两张卡牌，可获得的点数总是 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">输入：cardPoints = [<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>], k = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">55</span><br>解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">输入：cardPoints = [<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br>解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 <span class="hljs-number">1</span> 。 <br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><p>我们考虑到每次拿牌都是从首尾拿一张，总共拿 <code>k</code> 张，与其去想拿首或者尾的一张，那么不妨逆向思维一下，拿走 <code>k</code> 张之后还剩下 <code>n - k</code> 张，我们只需要保证剩下的 <code>n - k</code> 张牌的点数之和<strong>最小</strong>，这样就可以保证拿走的牌的点数之和最大，这样，我们就可以维护一个滑动窗口来求剩下点数的最小值。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(cardPoints []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(cardPoints)<br>    sum := <span class="hljs-number">0</span><br>    windowSize := n - k<br>    <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> cardPoints[:windowSize] &#123;<br>        sum += val<br>    &#125;<br>    minSum := sum<br>    <span class="hljs-keyword">for</span> i := windowSize; i &lt; n; i++ &#123;<br>        sum += cardPoints[i] - cardPoints[i - windowSize]<br>        minSum = min(minSum, sum)<br>    &#125;<br>    total := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> cardPoints &#123;<br>        total += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> total - minSum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="42-接雨水「Hard」"><a href="#42-接雨水「Hard」" class="headerlink" title="42. 接雨水「Hard」"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水「Hard」</a></h3><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="picture"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：height = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><ol><li>我们维护两个指针分别指向首尾两端 $\Rightarrow$ $left&#x3D;0,~right&#x3D;n-1$ 以及两个变量维护左边和右边的最大高度 $\Rightarrow$ $left_most$ 和 $right_most$.</li><li>此时我们依次遍历，可以分两种情况讨论：<ul><li>当 $left_most&lt;right_most$ 时，当前位置能存储的水的最大高度取决于 $left_most$，无论中间的柱子情况如何，我们此时一定可以存储 $left_most-nums[i]$ 高度的水，直至在左边遇到高度大于 $left_most$ 的柱子，然后更新 $left_most$ 的值。</li><li>当 $left_most&gt;&#x3D;right_most$ 时，当前位置能存储的水的最大高度取决于 $right_most$，无论中间的柱子情况如何，我们此时一定可以存储 $right_most-nums[i]$ 高度的水，直至在右边遇到高度大于  $right_most$ 的柱子，然后更新 $right_most$ 的值。</li></ul></li><li>运行至 $left&#x3D;right$ 结束。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> left_most = <span class="hljs-number">0</span>, right_most = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>                height[left] &gt;= left_most ? left_most = height[left] : count += left_most - height[left];<br>                ++left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                height[right] &gt;= right_most ? right_most = height[right] : count += right_most - height[right];<br>                --right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="76-最小覆盖子串「Hard」"><a href="#76-最小覆盖子串「Hard」" class="headerlink" title="76. 最小覆盖子串「Hard」"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串「Hard」</a></h3><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 “” 。</p><p>注意：如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;<br>输出：&quot;BANC&quot;<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><p>本问题要求我们返回字符串 <code>s</code> 中包含字符串 <code>t</code> 的全部字符的<strong>最小</strong>窗口。我们称包含 <code>t</code> 的全部字母的窗口为「可行」窗口。</p><p>我们考虑使用滑动窗口来解决此问题，维护两个指针 $left$ 和 $right$，其中 <em><strong>$right$ 用来「延展」窗口，$left$ 用来 「收缩」窗口</strong></em>。</p><p>我们的遍历在字符串 <code>s</code> 中进行，会出现以下几种情况：</p><ul><li>首先，不断右移 $right$ 指针，直至目前的子串完全包含 <code>t</code> 中的所有字符.</li><li>其次，我们开始收缩 $left$ 指针，直至 $[left,~right]$ 区间内<strong>不完全</strong>包含 <code>t</code> 中所有字符，其中我们使用变量 <code>begin</code> 保存答案字符串的开头位置，<code>len</code> 表示符合条件字符串的长度.</li><li>当 $right$ 指针遍历至 <code>s</code> 的末尾，遍历结束.</li></ul><p>Details：</p><p>我们使用两个哈希表 <code>SFreq</code> 和 <code>TFreq</code> 来存储各个出现字符的次数，<code>check()</code> 函数用于判断这两个哈希表之间是否具有<strong>包含关系</strong>.</p><p><strong>算法缺陷</strong>：</p><p>每次左指针 $left$ 移动我们都需要判断两个哈希表之间的差异，造成了时间上的浪费，因此我们可以做一些优化.</p><p><em><strong>优化算法</strong></em>：</p><p>我们使用一个变量 <code>distant</code> 来维护目前滑动窗口中出现了与 <code>t</code> 字符串中的匹配数目，当 <code>distant = tlen</code> 的时候，我们此时就可以移动 $left$ 指针了，移动的过程中更新答案字符串的开头和长度，直至 $[left,~right]$ 区间内<strong>不完全</strong>包含 <code>t</code> 中所有字符.</p><p>Details：</p><p>要清楚答案字符串的长度是 $right - left+1$ 还是 $right-left$，这个长度取决于 $right$ 的自加过程是在「收缩」阶段的前面或者后面，具体细节自己体会.</p><p><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a> 是本题的简单版，可以作为练习加深印象.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; SFreq, TFreq;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;p: TFreq) &#123;<br>            <span class="hljs-keyword">if</span> (SFreq[p.first] &lt; p.second) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; c : t) &#123;<br>            ++TFreq[c];<br>        &#125;<br>        <span class="hljs-type">int</span> begin = <span class="hljs-number">-1</span>, slen = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> len = INT_MAX;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; slen) &#123;<br>           <span class="hljs-keyword">if</span> (TFreq.<span class="hljs-built_in">count</span>(s[++right])) &#123;<br>                ++SFreq[s[right]];<br>            &#125;<br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">check</span>() <span class="hljs-keyword">and</span> left &lt;= right) &#123;<br>                <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &lt; len) &#123;<br>                    len = right - left + <span class="hljs-number">1</span>;<br>                    begin = left;<br>                &#125;<br>               <span class="hljs-keyword">if</span> (TFreq.<span class="hljs-built_in">count</span>(s[left])) &#123;<br>                    --SFreq[s[left]];<br>                &#125;<br>                ++left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> begin *** <span class="hljs-number">-1</span> ? <span class="hljs-built_in">string</span>() : s.<span class="hljs-built_in">substr</span>(begin, len);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>优化代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; SFreq, TFreq;<br>        <span class="hljs-type">int</span> slen = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">size</span>(), tlen = (<span class="hljs-type">int</span>)t.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (slen *** <span class="hljs-number">0</span> || tlen *** <span class="hljs-number">0</span> || slen &lt; tlen) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; c : t) &#123;<br>            ++TFreq[c];<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> distant = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> len = slen + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> begin = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// [left, right)</span><br>        <span class="hljs-keyword">while</span> (right &lt; slen) &#123;<br>            <span class="hljs-keyword">if</span> (TFreq[s[right]] *** <span class="hljs-number">0</span>) &#123;<br>                ++right;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (SFreq[s[right]] &lt; TFreq[s[right]]) &#123;<br>                distant++;<br>            &#125;<br>            <br>            SFreq[s[right]]++;<br>            right++;<br>            <br>            <span class="hljs-keyword">while</span> (distant *** tlen) &#123;<br>                <span class="hljs-keyword">if</span> (right - left &lt; len) &#123;<br>                    len = right - left;<br>                    begin = left;<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span> (TFreq[s[left]] *** <span class="hljs-number">0</span>) &#123;<br>                    ++left;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span> (SFreq[s[left]] *** TFreq[s[left]]) &#123;<br>                    distant--;<br>                &#125;<br>                <br>                SFreq[s[left]]--;<br>                left++;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> len *** slen + <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;&quot;</span> : s.<span class="hljs-built_in">substr</span>(begin, len);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="992-K-个不同整数的子数组「Hard」"><a href="#992-K-个不同整数的子数组「Hard」" class="headerlink" title="992. K 个不同整数的子数组「Hard」"></a><a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/">992. K 个不同整数的子数组「Hard」</a></h3><p>给定一个正整数数组 <code>A</code>，如果 <code>A</code> 的某个子数组中不同整数的个数恰好为 <code>K</code>，则称 <code>A</code> 的这个连续、不一定独立的子数组为<em>好子数组</em>。</p><p>( 例如，<code>[1,2,3,1,2]</code> 中有 <code>3</code> 个不同的整数：<code>1</code>，<code>2</code>，以及 <code>3</code>。)</p><p>返回 <code>A</code> 中<em>好子数组</em>的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：A = [1,2,1,2,3], K = 2<br>输出：7<br>解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：A = [1,2,1,3,4], K = 3<br>输出：3<br>解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= A.length &lt;= 20000</code></li><li><code>1 &lt;= A[i] &lt;= A.length</code></li><li><code>1 &lt;= K &lt;= A.length</code></li></ul><blockquote><p>算法分析：</p><p>滑动窗口的<em><strong>思维定势</strong></em>：</p><p>我们一般考虑滑动窗口的时候都是每轮循环使 $right$ 向右移动一位，然后固定 $right$，然后「收缩」$left$，但是考虑本题，$right$ 指针其实并不固定：</p><p>对于一个固定的左边界来说，满足「恰好存在 <code>K</code> 个不同整数的子区间」的右边界 <strong>不唯一</strong>，且形成区间。</p><p>示例：左边界固定的时候，恰好存在 $2$ 个不同整数的子区间为 <code>[1, 2], [1, 2, 1], [1, 2, 1, 2]</code>，总数为 $3$。</p><img src="https://pic.leetcode-cn.com/1612775858-VWbhYR-image.png" alt="picture" style="zoom:67%;" /><p>但是本题是<em><strong>「恰好存在 <code>K</code> 个不同整数的子区间」</strong></em>，所以我们需要找到左边界固定的情况下，满足「恰好存在 <code>K</code> 个不同整数的子区间」最小右边界和最大右边界。</p><p>对比以前我们做过的，使用「滑动窗口」解决的问题的问法基本都会出现「最小」、「最大」这样的字眼。那么这题如何解决呢？对此，我们可以进行一定的转换：</p><p>把「<strong>恰好</strong>」改成「<strong>最多</strong>」就可以使用双指针一前一后交替向右的方法完成，这是因为 <strong>对于每一个确定的左边界，最多包含</strong> $K$ <strong>种不同整数的右边界是唯一确定的</strong>，并且在左边界向右移动的过程中，右边界或者在原来的地方，或者在原来地方的右边。</p><p>而「最多存在 $K$ 个不同整数的子区间的个数」与「恰好存在 <code>K</code> 个不同整数的子区间的个数」的差恰好等于「最多存在 $K-1$ 个不同整数的子区间的个数」。</p><p><img src="https://pic.leetcode-cn.com/1612776085-sZFGqE-image.png" alt="picture"></p><p>因此原问题就可以转换为求解「最多存在 $K$ 个不同整数的子区间的个数」和 「最多存在 $K-1$ 个不同整数的子区间的个数」。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 主求解函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subarraysWithKDistinct</span><span class="hljs-params">(A []<span class="hljs-type">int</span>, K <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> atMostKDistinct(A, K) - atMostKDistinct(A, K - <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">atMostKDistinct</span><span class="hljs-params">(A []<span class="hljs-type">int</span>, K <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(A)<br>    <span class="hljs-comment">// count 代表 [left, right) 里不同整数的个数</span><br>    res, count, left, right := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    freq := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-comment">// [left, right) 包含不同整数的个数小于等于 K</span><br>    <span class="hljs-keyword">for</span> right &lt; n &#123;<br>        <span class="hljs-keyword">if</span> freq[A[right]] *** <span class="hljs-number">0</span> &#123;<br>            count++<br>        &#125;<br>        <br>        freq[A[right]]++<br>        right++<br>        <br>        <span class="hljs-keyword">for</span> count &gt; K &#123;<br>            freq[A[left]]--<br>            <span class="hljs-keyword">if</span> freq[A[left]] *** <span class="hljs-number">0</span> &#123;<br>                count--<br>            &#125;<br>            left++<br>        &#125;<br>        <br>        <span class="hljs-comment">// [left, right) 区间的长度就是对结果的贡献</span><br>        res += right - left<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="995-K-连续位的最小翻转次数「Hard」"><a href="#995-K-连续位的最小翻转次数「Hard」" class="headerlink" title="995. K 连续位的最小翻转次数「Hard」"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/">995. K 连续位的最小翻转次数「Hard」</a></h3><p>在仅包含 <code>0</code> 和 <code>1</code> 的数组 <code>A</code> 中，一次 <code>K</code> 位翻转包括选择一个长度为 <code>K</code> 的（连续）子数组，同时将子数组中的每个 <code>0</code> 更改为 <code>1</code>，而每个 <code>1</code> 更改为 <code>0</code>。</p><p>返回所需的 <code>K</code> 位翻转的最小次数，以便数组没有值为 <code>0</code> 的元素。如果不可能，返回 <code>-1</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：A = [0,1,0], K = 1<br>输出：2<br>解释：先翻转 A[0]，然后翻转 A[2]。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：A = [0,0,0,1,0,1,1,0], K = 3<br>输出：3<br>解释：<br>翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]<br>翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]<br>翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 30000</code></li><li><code>1 &lt;= K &lt;= A.length</code></li></ol><blockquote><p>算法分析：</p><p><em><strong><strong>方法一：差分数组</strong></strong></em></p><p>由于对同一个子数组执行两次翻转操作不会改变该子数组，所以对每个长度为 $K$ 的子数组，应至多执行一次翻转操作。</p><p>对于若干个 $K$ 位翻转操作，改变先后顺序并不影响最终翻转的结果。不妨从 $A[0]$ 开始考虑，若 $A[0]&#x3D;0$，则必定要翻转从位置 $0$ 开始的子数组；若 $A[0]&#x3D;1$，则不翻转从位置 $0$ 开始的子数组。</p><p>按照这一策略，我们从左到右地执行这些翻转操作。由于翻转操作是唯一的，若最终数组元素均为 $1$，则执行的翻转次数就是最小的。</p><p>若直接模拟上述过程，复杂度将会是 $O(NK)$ 的。考虑优化问题：</p><p>考虑不去翻转数字，而是统计每个数字需要翻转的次数。对于一次翻转操作，相当于把子数组中所有数字的翻转次数加 $1$.</p><p>这启发我们用<strong>差分数组</strong>的思想来计算当前数字需要翻转的次数。我们可以维护一个差分数组 $diff$，其中 $diff[i]$ 表示两个相邻元素 $A[i-1]$ 和 $A[i]$ 的翻转次数的差，对于区间 $[l,r]$，将其元素全部加 $1$，只会影响到 $l$ 和 $r+1$ 处的差分值，故 <code>diff[l]++ &amp;&amp; diff[r + 1]--</code>.</p><p>通过累加差分数组可以得到当前位置需要翻转的次数，我们用变量 $revCnt$ 来表示这一累加值。</p><p>遍历到 $A[i]$ 时，<em><strong>若 $A[i]+revCnt$ 是偶数，则说明当前元素的实际值为 $0$，需要翻转区间 $[i,i+K-1]$</strong></em> ，我们可以直接将 $revCnt$ 增加 $1$，$diff[i+K]$ 减少 $1$.</p><p>注意到若 $i+K&gt;n$ 则无法执行翻转操作，此时应返回 $-1$.</p><p><em><strong><strong>方法二：滑动窗口</strong></strong></em></p><p>我们考虑能否将空间复杂度简化为 $O(1)$ ?</p><p>回顾方法一的代码，当遍历到位置 $i$ 时，若能知道位置 $i-K$ 上发生了翻转操作，便可以直接修改 $revCnt$ 从而去掉 $diff$ 数组。</p><p>注意到 $0≤A[i]≤1$，我们可以<em><strong>用 $A[i]$ 范围</strong>之外</em><em>的数来表达「是否翻转过」的含义</em>**。</p><p>具体来说，若要翻转从位置 $i$ 开始的子数组，可以将 $A[i]$ 加 $2$，这样当遍历到位置 $i’$ 时，若有 $A[i’-K]&gt;1$，则说明在位置 $i’-K$ 上发生了翻转操作。</p></blockquote><p>方法一：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minKBitFlips</span><span class="hljs-params">(A []<span class="hljs-type">int</span>, K <span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    n := <span class="hljs-built_in">len</span>(A)<br>    diff := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    revCnt := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> A &#123;<br>        revCnt += diff[i]<br>        <span class="hljs-keyword">if</span> (v + revCnt) % <span class="hljs-number">2</span> *** <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> i + K &gt; n &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>            &#125;<br>            ans++<br>            revCnt++<br>            diff[i + K]--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于模 $2$ 意义下的加减法与异或等价，我们也可以用异或改写上面的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minKBitFlips</span><span class="hljs-params">(A []<span class="hljs-type">int</span>, K <span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    n := <span class="hljs-built_in">len</span>(A)<br>    diff := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    revCnt := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> A &#123;<br>        revCnt ^= diff[i]<br>        <span class="hljs-keyword">if</span> v *** revCnt &#123; <span class="hljs-comment">// v ^ revCnt *** 0</span><br>            <span class="hljs-keyword">if</span> i + K &gt; n &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>            &#125;<br>            ans++<br>            revCnt ^= <span class="hljs-number">1</span><br>            diff[i + K] ^= <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minKBitFlips</span><span class="hljs-params">(A []<span class="hljs-type">int</span>, K <span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    n := <span class="hljs-built_in">len</span>(A)<br>    revCnt := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> A &#123;<br>        <span class="hljs-keyword">if</span> i &gt;= K &amp;&amp; A[i - K] &gt; <span class="hljs-number">1</span> &#123;<br>            revCnt ^= <span class="hljs-number">1</span><br>            A[i - K] -= <span class="hljs-number">2</span> <span class="hljs-comment">// 复原数组元素，若允许修改数组 A，则可以省略</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> v *** revCnt &#123;<br>            <span class="hljs-keyword">if</span> i + K &gt; n &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>            &#125;<br>            ans++<br>            revCnt ^= <span class="hljs-number">1</span><br>            A[i] += <span class="hljs-number">2</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="220-存在重复元素-III「Medium」"><a href="#220-存在重复元素-III「Medium」" class="headerlink" title="220. 存在重复元素 III「Medium」"></a><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/">220. 存在重复元素 III「Medium」</a></h3><p>给你一个整数数组 <code>nums</code> 和两个整数 <code>k</code> 和 <code>t</code> 。请你判断是否存在 <strong>两个不同下标</strong> <code>i</code> 和 <code>j</code>，使得 <code>abs(nums[i] - nums[j]) &lt;= t</code> ，同时又满足 <code>abs(i - j) &lt;= k</code>.</p><p>如果存在则返回 <code>true</code>，不存在返回 <code>false</code>.</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [1,2,3,1], k = 3, t = 0<br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [1,0,1,1], k = 1, t = 2<br>输出：true<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><p><em><strong>方法一：滑动窗口 &amp; 有序集合</strong></em></p><p>根据题意，对于任意一个位置 $i$ ( 假设其值为 $u$ )，我们其实是希望在下标范围为 $[max(0,~i-k),i]$ 内找到值范围在 $[u-t,u+t]$ 的数.</p><p>因此我们可以使用一个「有序集合」去维护长度为 $k$ 的滑动窗口内的数.</p><p>每次都在「有序集合」中应用「二分查找」，找到「小于等于 $u$ 的最大值」和「大于等于 $u$ 的最小值」，即「有序集合」中的最接近 $u$ 的数。然后判断两值是否落在 $[u-t,u+t]$ 范围内.</p><p>由于我们希望对「有序集合」应用「二分」，找到最接近 $u$ 的数，因此我们需要使用 $TreeSet$ 数据结构（基于红黑树，因此查找和插入都具有折半的效率），并且由于 $nums$ 中的数较大，会存在 $int$ 溢出问题，我们需要使用 $long$ 来存储.</p><ul><li>时间复杂度： $TreeSet$ 基于红黑树，查找和插入都是 $O(\log k)$ 复杂度。整体复杂度为 $O(n\log k)$.</li><li>空间复杂度：$O(k)$.</li></ul><p><em><strong>方法二：桶排序</strong></em></p><p>上述解法无法做到线性的原因是：我们需要在大小为 $k$ 的滑动窗口所在的「有序集合」中找到与 $u$ 接近的数.</p><p>如果我们能够将 $k$ 个数字分到 $k$ 个桶的话，那么我们就能 $O(1)$ 的复杂度确定是否有 $[u-t,u+t]$ 的数字 ( 检查目标桶是否有元素 ).</p><p>具体的做法为：令桶的大小为 $size &#x3D; t+1$，根据 $u$ 计算所在桶编号：</p><ul><li>如果已经存在该桶，说明前面已有 $[u-t,u+t]$ 的数字，返回 $true$.</li><li>如果不存在该桶，则检查相邻两个桶的元素是有 $[u-t,u+t]$ 的数字，如有返回 $true$.</li><li>建立目标桶，并删除下标范围不在 $[max(0,~i-k),i]$ 内的桶</li></ul></blockquote><p>方法一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>        set&lt;<span class="hljs-type">long</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">auto</span> lb = st.<span class="hljs-built_in">lower_bound</span>((<span class="hljs-type">long</span>)nums[i] - t);<br>            <span class="hljs-keyword">if</span> (lb != st.<span class="hljs-built_in">end</span>() <span class="hljs-keyword">and</span> *lb &lt;= (<span class="hljs-type">long</span>)nums[i] + t) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            st.<span class="hljs-built_in">insert</span>(nums[i]);<br>            <span class="hljs-keyword">if</span> (i &gt;= k) &#123;<br>                st.<span class="hljs-built_in">erase</span>(nums[i - k]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">long</span> size;<br>  <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(vector &lt;<span class="hljs-type">int</span>&gt; &amp; nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        map&lt;<span class="hljs-type">long</span>, <span class="hljs-type">long</span>&gt; m;<br>        size = t + <span class="hljs-number">1L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">long</span> u = nums[i] * <span class="hljs-number">1L</span>;<br>            <span class="hljs-type">long</span> idx = <span class="hljs-built_in">getIdx</span>(u);<br>            <span class="hljs-comment">// 目标桶已存在（桶不为空），说明前面已有 [u - t, u + t] 范围的数字</span><br>            <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">find</span>(idx) != m.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 检查相邻的桶</span><br>            <span class="hljs-type">long</span> l = idx - <span class="hljs-number">1</span>, r = idx + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">find</span>(l) != m.<span class="hljs-built_in">end</span>() &amp;&amp; <span class="hljs-built_in">abs</span>(u - m[l]) &lt;= t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">find</span>(r) != m.<span class="hljs-built_in">end</span>() &amp;&amp; <span class="hljs-built_in">abs</span>(u - m[r]) &lt;= t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 建立目标桶</span><br>            m.<span class="hljs-built_in">insert</span>(&#123;idx, u&#125;);<br>            <span class="hljs-comment">// 移除下标范围不在 [max(0, i - k), i) 内的桶</span><br>            <span class="hljs-keyword">if</span> (i &gt;= k) m.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">getIdx</span>(nums[i - k]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">getIdx</span><span class="hljs-params">(<span class="hljs-type">long</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> u &gt;= <span class="hljs-number">0</span> ? u / size : (u + <span class="hljs-number">1</span>) / size - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="Chapter2-Dynamic-Programming"><a href="#Chapter2-Dynamic-Programming" class="headerlink" title="Chapter2 Dynamic Programming"></a>Chapter2 Dynamic Programming</h1><h3 id="5-最长回文子串「Medium」"><a href="#5-最长回文子串「Medium」" class="headerlink" title="5. 最长回文子串「Medium」"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串「Medium」</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">optimize</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; dp, string&amp; s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        dp[i][i] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; len; j++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; j; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] *** s[j]) &#123;<br>                <span class="hljs-keyword">if</span> (j - i &lt; <span class="hljs-number">3</span>) dp[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="72-编辑距离「Hard」"><a href="#72-编辑距离「Hard」" class="headerlink" title="72. 编辑距离「Hard」"></a><a href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离「Hard」</a></h3><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;<br>输出：3<br>解释：<br>horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)<br>rorse -&gt; rose (删除 &#x27;r&#x27;)<br>rose -&gt; ros (删除 &#x27;e&#x27;)<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;<br>输出：5<br>解释：<br>intention -&gt; inention (删除 &#x27;t&#x27;)<br>inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)<br>enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)<br>exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)<br>exection -&gt; execution (插入 &#x27;u&#x27;)<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><ol><li><p>状态：<code>dp[i][j]</code> 表示 <code>word1</code> 的前 <code>i</code> 个字母和 <code>word2</code> 的前 <code>j</code> 个字母之间的编辑距离。</p></li><li><p>状态转移方程：</p><ul><li>当 <em><strong><code>word1[i - 1] *** word2[j - 1]</code></strong></em> 时，不需要转换，编辑距离为 <em><strong><code>dp[i] [j] = dp[i - 1] [j - 1]</code></strong></em>.</li><li>当 <em><strong><code>word1[i - 1] != word2[j - 1]</code></strong></em> 时，分三种情况讨论：<ul><li>插入一个字符，***<code>dp[i] [j - 1]</code>***：为 <code>A</code> 的前 <code>i</code> 个字符和 <code>B</code> 的前 <code>j - 1</code> 个字符编辑距离的子问题。即对于 <code>B</code> 的第 <code>j</code> 个字符，我们在 <code>A</code> 的末尾添加了一个相同的字符</li><li>删除一个字符，***<code>dp[i - 1] [j]</code>***：为 <code>A</code> 的前 <code>i - 1</code> 个字符和 <code>B</code> 的前 <code>j</code> 个字符编辑距离的子问题。即对于 <code>A</code> 的第 <code>i</code> 个字符，我们在 <code>B</code> 的末尾添加了一个相同的字符</li><li>替换一个字符，***<code>dp[i - 1] [j - 1]</code>***：为 <code>A</code> 前 <code>i - 1</code> 个字符和 <code>B</code> 的前 <code>j - 1</code> 个字符编辑距离的子问题。即对于 <code>B</code> 的第 <code>j</code> 个字符，我们修改 <code>A</code> 的第 <code>i</code> 个字符使它们相同</li></ul></li><li>对于这三种情况，我们去其中编辑距离的最小值再加一，即 <em><strong><code>dp[i][j] = min(dp[i - 1] [j - 1], dp[i - 1] [j], dp[i] [j - 1]) + 1</code></strong></em>.</li></ul></li><li><p>边界条件：</p><img src="/Users/wanglei/Library/Application Support/typora-user-images/image-20210206201135253.png" alt="image-20210206201135253" style="zoom:50%;" /></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        <span class="hljs-comment">// dp[i][j] 表示 word1 的前 i 个字母和 word2 的前 j 个字母之间的编辑距离。</span><br>        <span class="hljs-type">int</span> len1 = (<span class="hljs-type">int</span>)word<span class="hljs-number">1.l</span>ength(), len2 = (<span class="hljs-type">int</span>)word<span class="hljs-number">2.l</span>ength();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len1 + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2 + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1 + <span class="hljs-number">1</span>; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len2 + <span class="hljs-number">1</span>; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len1 + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; len2 + <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] *** word2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//dp[i-1][j-1] 表示替换操作，dp[i-1][j] 表示删除操作，dp[i][j-1] 表示插入操作</span><br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len1][len2];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="338-比特位计数「Medium」"><a href="#338-比特位计数「Medium」" class="headerlink" title="338. 比特位计数「Medium」"></a><a href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数「Medium」</a></h3><p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p><p><strong>示例 1:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入: <span class="hljs-number">2</span><br>输出: [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入: 5<br>输出: [0,1,1,2,1,2]<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><ol><li>状态：<code>bit[i]</code> 表示 <code>i</code> 的「比特数」</li><li>状态转移方程：对于正整数 $x$，如果可以知道最大的正整数 $y$ 使得 $y≤x$ 且 $y$ 是 $2$ 的整数次幂，则 $y$ 的二进制表示中只有最高位是 $1$，其余都是 $0$，此时称 $y$ 为 $x$ 的「最高有效位」。也就是说 <code>bit[x] = bit[y - x] + 1</code></li><li>边界条件：判断「最高有效位」看上题，<code>(i &amp; (i - 1)) *** 0</code>.</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">bits</span><span class="hljs-params">(num + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> highBit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;<br>            <span class="hljs-keyword">if</span> ((i &amp; (i - <span class="hljs-number">1</span>)) *** <span class="hljs-number">0</span>) &#123;<br>                highBit = i;<br>            &#125;<br>            bits[i] = bits[i - highBit] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bits;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="132-分割回文串-II「Hard」"><a href="#132-分割回文串-II「Hard」" class="headerlink" title="132. 分割回文串 II「Hard」"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">132. 分割回文串 II「Hard」</a></h3><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。</p><p>返回符合要求的 <strong>最少分割次数</strong> </p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;aab&quot;<br>输出：1<br>解释：只需一次分割就可将 s 分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><p>Step1：定义状态</p><p>设 $f[i]$ 表示字符串的前缀 $s[0…i]$ 的<strong>最少</strong>分割次数。</p><p>Step2：状态转移方程</p><p>要想得出 $f[i]$ 的值，我们可以考虑枚举 $s[0…i]$ 分割出的最后一个回文串，这样我们就可以写出状态转移方程：</p><p>$f[i]&#x3D;min_{0≤j&lt;i}(f[j])+1$，其中 $s[j+1,i]$ 是一个回文串.</p><p>即我们枚举最后一个回文串的起始位置 $j+1$，保证 $s[j+1,i]$ 是一个回文串，那么 $f[i]$ 就可以从 $f[j]$ 转移而来，附加 $1$ 次额外的分割次数。</p><p>Step3：边界情况</p><p>注意到上面的状态转移方程中，我们还少考虑了一种情况，即 $s[0…i]$ 本身就是一个回文串。此时其不需要进行任何分割，即：$f[i]&#x3D;0$.</p><p>那么我们如何知道 $s[j+1,i]$ or  $s[0…i]$ 是否为回文串呢？我们可以使用 $dp$ 的预处理解决.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">optimize</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; dp, string&amp; s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            dp[i][i] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; len; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; j; i++) &#123;<br>                <span class="hljs-keyword">if</span> (s[i] *** s[j]) &#123;<br>                    <span class="hljs-keyword">if</span> (j - i &lt; <span class="hljs-number">3</span>) dp[i][j] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">else</span> dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCut</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n));<br>        <span class="hljs-built_in">optimize</span>(dp, s);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n, n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (dp[<span class="hljs-number">0</span>][i]) f[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (dp[j + <span class="hljs-number">1</span>][i]) &#123;<br>                        f[i] = <span class="hljs-built_in">min</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="115-不同的子序列「Hard」"><a href="#115-不同的子序列「Hard」" class="headerlink" title="115. 不同的子序列「Hard」"></a><a href="https://leetcode-cn.com/problems/distinct-subsequences/">115. 不同的子序列「Hard」</a></h3><p>给定一个字符串 <code>s</code> 和一个字符串 <code>t</code> ，计算在 <code>s</code> 的子序列中 <code>t</code> 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串.</p><p>( 例如，<code>&quot;ACE&quot;</code> 是 <code>&quot;ABCDE&quot;</code> 的一个子序列，而 <code>&quot;AEC&quot;</code> 不是 )</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;<br>输出：3<br>解释：<br>如下图所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。<br>(上箭头符号 <span class="hljs-built_in">^</span> 表示选取的字母)<br>rabbbit<br>^^^<span class="hljs-built_in">^</span> ^^<br>rabbbit<br>^^ ^^^<span class="hljs-built_in">^</span><br>rabbbit<br>^^^ ^^^<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;babgbag&quot;, t = &quot;bag&quot;<br>输出：5<br>解释：<br>如下图所示, 有 5 种可以从 s 中得到 &quot;bag&quot; 的方案。 <br>(上箭头符号 <span class="hljs-built_in">^</span> 表示选取的字母)<br>babgbag<br>^^ <span class="hljs-built_in">^</span><br>babgbag<br>^^    <span class="hljs-built_in">^</span><br>babgbag<br><span class="hljs-built_in">^</span>    ^^<br>babgbag<br>  <span class="hljs-built_in">^</span>  ^^<br>babgbag<br>    ^^^<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><p>Preface：</p><p>假设字符串 <code>s</code> 和 <code>t</code> 的长度分别为 <code>m</code> 和 <code>n</code>，只有当 <code>m ≥ n</code> 的时候才有意义，当 <code>m &lt; n</code> 时返回 <code>0</code>.</p><ol><li><p>定义状态</p><p>创建二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示 <code>s[i:]</code> 的子序列中 <code>t[j:]</code> 出现的个数.</p></li><li><p>状态转移方程</p><p>当 <code>i &lt; m</code> 且 <code>j &lt; n</code> 时， 我们考虑 <code>dp[i][j]</code> 的计算.</p><ul><li><p>当 <code>s[i] = t[j]</code> 时，<code>dp[i][j]</code> 由两部分组成：</p><ul><li><p>如果 <code>s[i]</code> 和 <code>t[j]</code> 匹配，则考虑 <code>t[j + 1:]</code> 作为 <code>s[i + 1:]</code> 的子序列，</p><p>子序列数为 <code>dp[i + 1][j + 1]</code>.</p></li><li><p>如果 <code>s[i]</code> 不和 <code>t[j]</code> 匹配，则考虑 <code>t[j:]</code> 作为 <code>s[i + 1:]</code> 的子序列，</p><p>子序列数为 <code>dp[i + 1][j]</code>.</p></li></ul><p>因此当 <code>s[i] = t[j]</code> 时，有 <code>dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j]</code>.</p></li><li><p>当 <code>s[i] ≠ t[j]</code> 时，<code>s[i]</code> 不和 <code>t[j]</code> 匹配，因此只考虑 <code>t[j:]</code> 作为 <code>s[i + 1:]</code> 的子序列，</p><p>子序列数为 <code>dp[i + 1][j]</code>.</p><p>因此当 <code>s[i] ≠ t[j]</code> 时，<code>dp[i][j] = dp[i + 1][j]</code>.</p></li></ul><p>最终计算得到 <code>dp[0][0]</code> 即为在 <code>s</code> 的子序列中 <code>t</code> 出现的个数.</p></li><li><p>边界情况</p><ul><li>当 <code>j = n</code> 时，<code>t[j:]</code> 为空字符串，由于空字符串是任何字符串的子序列，因此对任意 <code>0 ≤ i ≤ m</code>，有 <code>dp[i][n] = 1</code>.</li><li>当 <code>i = m</code> 且 <code>j &lt; n</code> 时，<code>s[i:]</code> 为空字符串，<code>t[j:]</code> 为非空字符串，由于非空字符串不是空字符串的子序列，因此对任意 <code>0 ≤ j &lt; n</code>，有 <code>dp[m][j] = 0</code>.</li></ul></li></ol></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(s, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(t)<br>    <span class="hljs-keyword">if</span> m &lt; n &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>        dp[i][n] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br>            <span class="hljs-keyword">if</span> s[i] *** t[j] &#123;<br>                dp[i][j] = dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + dp[i + <span class="hljs-number">1</span>][j]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = dp[i + <span class="hljs-number">1</span>][j]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="53-最大子序和「Easy」"><a href="#53-最大子序和「Easy」" class="headerlink" title="53. 最大子序和「Easy」"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和「Easy」</a></h3><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p> <strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><ol><li><p>定义状态</p><p>我们令 $f(i)$ 为以第 $i$ 个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：$max_{0≤i&lt;n}f(i)$.</p></li><li><p>状态转移方程</p><p>$f(i)&#x3D;max(f(i-1)+nums[i],nums[i])$.</p></li><li><p>无边界情况</p></li></ol><p>$DP$ 算法优化：</p><p>​每一次的状态只与前一次的状态有关，所以可以利用「滚动数组」思想优化空间，设置一个变量 $pre$ 表示前一个解的值.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    pre, maxn := <span class="hljs-number">0</span>, nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> nums &#123;<br>        pre = max(pre + v, v)<br>        maxn = max(maxn, pre)<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxn<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="198-打家劫舍「Medium」"><a href="#198-打家劫舍「Medium」" class="headerlink" title="198. 打家劫舍「Medium」"></a><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍「Medium」</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><ol><li><p>定义状态：</p><p>由于当前考虑的房屋有两种选择：「偷」和「不偷」。我们用 <code>0</code> 表示「不偷」，用 <code>1</code> 表示「偷」，即：</p><ul><li><code>dp[i][0]</code> 表示：考虑区间 <code>[0..i]</code> ，并且下标为 <code>i</code> 的这个房间不偷，能够偷窃到的最高金额；</li><li><code>dp[i][1]</code> 表示：考虑区间 <code>[0..i]</code> ，并且下标为 <code>i</code> 的这个房间偷，能够偷窃到的最高金额。</li></ul></li><li><p>状态转移方程：</p><ul><li>不偷：<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][i])</code></li><li>偷：<code>dp[i][1] = dp[i - 1][0] + nums[i]</code></li></ul></li><li><p>边界情况：</p><ul><li><code>dp[0][0] = 0</code></li><li><code>dp[0][1] = nums[0]</code></li></ul></li></ol><p>算法优化：</p><p>每层算法只与其上一层的状态有关，所以可以使用「滚动数组」来节省空间.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (len *** <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (len *** <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> norob = <span class="hljs-number">0</span>, rob = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-type">int</span> temp = norob;<br>            norob = <span class="hljs-built_in">max</span>(norob, rob);<br>            rob = temp + nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(norob, rob);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h2><p>有 <code>n</code> 种物品，物品 <code>i</code> 的体积为 $v_i$ ，价值为 $w_i$，有一个体积限制 $V$，<strong>每种物品只有 1 个，只有选或者不选</strong>，而没有选几个的问题，此问题称为 01 背包问题。</p><blockquote><ol><li><p>状态：</p><p><code>dp[i][j]</code> :&#x3D; 考虑了 <code>[0..i]</code>  里的物品，占用了 <code>j</code> 空间，所能取得的最大价值.</p></li><li><p>状态转移方程：</p><p>转移方式有两种，一种是放入，一种是不放入。</p><p>如果放，则区间 <code>[0...i-1]</code> 只能占 <code>j - v[i]</code> 空间；</p><p>如果不放，则区间 <code>[0...i-1]</code> 的物品还是占了 <code>j</code> 空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] 当前物品不选<br>           dp[i - <span class="hljs-number">1</span>][j - v[i]] + w[i] 当前物品选，j - v[i] 要大于等于 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>边界情况：</p><p>初始化时将所有状态置为 $0$ 即可.</p></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ZeroOnePack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; weights, vector&lt;<span class="hljs-type">int</span>&gt;&amp; values, <span class="hljs-type">int</span> capacity)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>)weights.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(capacity + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= capacity; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (i *** <span class="hljs-number">0</span>) &#123;<br>                dp[i][j] = j &lt; weights[i] ? <span class="hljs-number">0</span> : values[i];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &lt; weights[i]) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weights[i]] + values[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">back</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="32-最长有效括号「Hard」"><a href="#32-最长有效括号「Hard」" class="headerlink" title="32. 最长有效括号「Hard」"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号「Hard」</a></h3><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;(()&quot;<br>输出：2<br>解释：最长有效括号子串是 &quot;()&quot;<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;)()())&quot;<br>输出：4<br>解释：最长有效括号子串是 &quot;()()&quot;<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><ol><li><p>状态：</p><p><code>dp[i]</code> 表示以下标 <code>i</code> 为字符结尾的最长有效字符串的长度.</p></li><li><p>状态转移方程：</p><ul><li><p>以 <code>(</code> 结尾的子字符串不考虑，因为不可能构成合法括号</p></li><li><p><code>if s[i] *** &#39;)&#39;</code></p><ul><li><p><code>s[i - 1] *** &#39;(&#39;</code>，也就是字符串形如 <code>“……()”</code>，我们可以推出：<code>dp[i] = dp[i − 2] + 2</code>.</p></li><li><p><code>s[i - 1] *** &#39;)&#39;</code>，也就是字符串形如 <code>“.......))”</code>，我们可以推出：</p><p><code>if s[i - dp[i - 1] - 1] *** &#39;(&#39;</code>，<code>dp[i] = dp[i − 1] + dp[i − dp[i − 1] − 2] + 2</code></p><p>因为如果倒数第二个 <code>)</code>是一个有效子字符串的一部分（记为<code>subs</code>），我们此时需要判断 <code>subs</code> 前面一个符号是不是 <code>(</code> ，如果恰好是<code>(</code>，我们就用 <code>subs</code> 的长度( <code>dp[i - 1]</code> ) 加上 2 去更新<code>dp[i]</code>。除此以外，我们也会把子字符串 <code>subs</code> 前面的有效字符串的长度加上，也就是 <code>dp[i − dp[i − 1] − 2]</code>.</p></li></ul></li></ul></li><li><p>边界情况：</p><ul><li><code>i - 2</code> 有可能小于零越界了，这种情况下就是只有 <code>()</code> ，前面记为 0 就好了.</li><li><code>i - dp[i - 1] - 1</code> 和 <code>i - dp[i - 1] - 2</code> 都可能越界，越界了当成 0 来计算就可以了.</li></ul></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.length())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] *** <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] *** <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>] *** <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = (i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> ? dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br>            maxLen = <span class="hljs-built_in">fmax</span>(dp[i], maxLen);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1143-最长公共子序列「Medium」"><a href="#1143-最长公共子序列「Medium」" class="headerlink" title="1143. 最长公共子序列「Medium」"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列「Medium」</a></h3><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> </p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; <br>输出：3  <br>解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。<br></code></pre></td></tr></table></figure><blockquote><p>注：本题过于经典，算法比较简单，不多赘述了.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(text1 <span class="hljs-type">string</span>, text2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(text1), <span class="hljs-built_in">len</span>(text2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m + <span class="hljs-number">1</span>)x2<br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> text1[i - <span class="hljs-number">1</span>] *** text2[j - <span class="hljs-number">1</span>] &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])<br>            &#125; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="91-解码方法「Medium」"><a href="#91-解码方法「Medium」" class="headerlink" title="91. 解码方法「Medium」"></a><a href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法「Medium」</a></h3><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">&#x27;A&#x27; -&gt; 1<br>&#x27;B&#x27; -&gt; 2<br>...<br>&#x27;Z&#x27; -&gt; 26<br></code></pre></td></tr></table></figure><p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li></ul><p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p><p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p><ul><li><code>s</code> 只包含数字，并且可能包含前导零。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;12&quot;<br>输出：2<br>解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;226&quot;<br>输出：3<br>解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><ol><li><p>状态：</p><p>$dp[i]$ 表示字符串的前 $i$ 个字符可能的组合数.</p></li><li><p>状态转移方程：</p><p>对于当前位 $i≠0$，则可以对前一项进行转移：<code>dp[i] += dp[i - 1]</code>.</p><p>考虑 $i$ 和 $i - 1$ 能否组成合法数字，如果可以的话也可以转移：<code>dp[i] += dp[i - 2]</code>.</p></li><li><p>边界情况：</p><p>第 $i - 1$ 位的时候要考虑是否字符 <code>&#39;0&#39;</code>，若是，则此项不进行转移；同理，第 $i - 2$ 位的时候亦是如此.</p><p>细节点：我们如何判断不合法的字符到最后一定是 $0$ 呢？</p><p>若是当前字符为 <code>&#39;0&#39;</code>，我们就不会考虑前一项了，若是前一项与当前项组成的数字也是不合法的，我们也不会做加法，因此迭代下去则会一直是零.</p></li><li><p>优化：</p><p>使用变量来代替迭代元素</p></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                dp[i] += dp[i - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> s[i - <span class="hljs-number">2</span>] != <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-built_in">and</span> ((s[i - <span class="hljs-number">2</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span> &lt;= <span class="hljs-number">26</span>)) &#123;<br>                dp[i] += dp[i - <span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// a = dp[i - 2], b = dp[i - 1], c = dp[i]</span><br>        <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, c;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            c = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                c += b;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span> &amp;&amp; s[i - <span class="hljs-number">2</span>] != <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ((s[i - <span class="hljs-number">2</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) &lt;= <span class="hljs-number">26</span>)) &#123;<br>                c += a;<br>            &#125;<br>            <span class="hljs-built_in">tie</span>(a, b) = &#123;b, c&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="Chapter3-Binary-Search"><a href="#Chapter3-Binary-Search" class="headerlink" title="Chapter3 Binary Search"></a>Chapter3 Binary Search</h1><h3 id="33-搜索旋转排序数组「Medium」"><a href="#33-搜索旋转排序数组「Medium」" class="headerlink" title="33. 搜索旋转排序数组「Medium」"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组「Medium」</a></h3><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，</p><p>使数组变为 <code>[nums[k], nums[k + 1], ..., nums[n - 1], nums[0], nums[1], ...,nums[k - 1]]</code>（下标 <strong>从 0 开始</strong> 计数）</p><p>例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [4,5,6,7,0,1,2], target = 0<br>输出：4<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [4,5,6,7,0,1,2], target = 3<br>输出：-1<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><p>对于有序数组，可以使用二分查找的方法查找元素。</p><p>但是这道题中，数组本身不是有序的，进行旋转后只保证了数组的局部是有序的，这还能进行二分查找吗？答案是可以的。</p><p>可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从 <code>6</code> 这个位置分开以后数组变成了 <code>[4, 5, 6]</code> 和 <code>[7, 0, 1, 2]</code> 两个部分，其中左边 <code>[4, 5, 6]</code> 这个部分的数组是有序的，其他也是如此。</p><p>这启示我们可以在常规二分查找的时候查看当前 <code>mid</code> 为分割位置分割出来的两个部分 <code>[l, mid]</code> 和 <code>[mid + 1, r]</code> 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 <code>target</code> 在不在这个部分：</p><ul><li>如果 <code>[l, mid - 1]</code> 是有序数组，且 <code>target</code> 的大小满足 <code>[nums[l], nums[mid])</code> 则我们应该将搜索范围缩小至 <code>[l, mid - 1]</code>，否则在 <code>[mid + 1, r]</code> 中寻找。</li><li>如果 <code>[mid, r]</code> 是有序数组，且 <code>target</code> 的大小满足 <code>(nums[mid], nums[r]]</code> 则我们应该将搜索范围缩小至 <code>[mid + 1, r]</code>，否则在 <code>[l, mid - 1]</code> 中寻找。</li></ul><p><img src="https://assets.leetcode-cn.com/solution-static/33/33_fig1.png" alt="picture"></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-keyword">if</span> (!numsSize) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (numsSize *** <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] *** target ? <span class="hljs-number">0</span> : <span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = numsSize - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// 本题的二分是只在有序数组那一边的范围里找 target</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (nums[mid] *** target) <span class="hljs-keyword">return</span> mid;<br>        <br>        <span class="hljs-keyword">if</span> (nums[left] &lt;= nums[mid]) &#123; <span class="hljs-comment">// 左边为升序排序数组</span><br>            <span class="hljs-keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 右边为升序数组</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>变式：</strong> 数组中的值可以重复</p><blockquote><p>算法分析：</p><p>对于数组中有重复元素的情况，二分查找时可能会有 <code>nums[l] = nums[mid] = nums[right] </code> 此时无法判断区间 <code>[left, mid]</code> 和区间 <code>[mid + 1, right]</code> 哪个是有序的。</p><p>对于这种情况，我们只能将当前二分区间的左边界加一，右边界减一，然后在新区间上继续二分查找。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-keyword">if</span> (!numsSize) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (numsSize *** <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] *** target ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = numsSize - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (nums[mid] *** target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (nums[left] *** nums[mid] &amp;&amp; nums[mid] *** nums[right]) &#123;<br>            ++left;<br>            --right;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[left] &lt;= nums[mid]) &#123; <br>            <span class="hljs-keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="153-寻找旋转排序数组中的最小值「Medium」"><a href="#153-寻找旋转排序数组中的最小值「Medium」" class="headerlink" title="153. 寻找旋转排序数组中的最小值「Medium」"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值「Medium」</a></h3><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> </p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [3,4,5,1,2]<br>输出：1<br>解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><p>一个不包含重复元素的升序数组在经过旋转之后，可以得到下面可视化的折线图：</p><p><img src="https://assets.leetcode-cn.com/solution-static/153/1.png" alt="picture"></p><p>其中横轴表示数组元素的下标，纵轴表示数组元素的值。图中标出了最小值的位置，是我们需要查找的目标.</p><pre><code class="hljs">我们考虑**数组中的最后一个元素** $x$：在最小值右侧的元素 ( 不包括最后一个元素本身 )，它们的值一定都严格小于 $x$ 而在最小值左侧的元素，它们的值一定都严格大于 $x$. 因此，我们可以根据这一条性质，通过二分查找的方法找出最小值.在二分查找的每一步中，左边界为 $low$，右边界为 $high$，区间的中点为 $pivot$，最小值就在该区间内. 我们将中轴元素 $nums[pivot]$ 与右边界元素 $nums[high]$ 进行比较，可能会有以下的三种情况：第一种情况是 $nums[pivot]&lt;nums[high]$. 如下图所示，这说明 $nums[pivot]$ 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分.</code></pre><p><img src="https://assets.leetcode-cn.com/solution-static/153/2.png" alt="picture"></p><pre><code class="hljs">第二种情况是 $nums[pivot]&gt;nums[high]$. 如下图所示，这说明 $nums[pivot]$ 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分.</code></pre><p><img src="https://assets.leetcode-cn.com/solution-static/153/3.png" alt="picture"></p><p>由于数组不包含重复元素，并且只要当前的区间长度不为 $1$，$pivot$ 就不会与 $high$ 重合；而如果当前的区间长度为 $1$ ，这说明我们已经可以结束二分查找了。因此不会存在 $nums[pivot]&#x3D;nums[high]$ 的情况.</p><p>当二分查找结束时，我们就得到了最小值所在的位置.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">findMin</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span> &#123;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = numsSize - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> pivot = low + (high - low) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[pivot] &lt; nums[high]) &#123;<br>            high = pivot;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            low = pivot + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[low];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Chapter5-Greedy-Algorithm"><a href="#Chapter5-Greedy-Algorithm" class="headerlink" title="Chapter5 Greedy Algorithm"></a>Chapter5 Greedy Algorithm</h1><h3 id="1749-任意子数组和的绝对值的最大值「Medium」"><a href="#1749-任意子数组和的绝对值的最大值「Medium」" class="headerlink" title="1749. 任意子数组和的绝对值的最大值「Medium」"></a><a href="https://leetcode-cn.com/problems/maximum-absolute-sum-of-any-subarray/">1749. 任意子数组和的绝对值的最大值「Medium」</a></h3><p>给你一个整数数组 nums 。一个子数组 $[nums_l, nums_{l+1}\cdots,nums_{r-1},nums_r]$ 的 <strong>和的绝对值</strong> 为 $abs(nums_l+nums_{l+1}+\cdots+nums_{r-1}+nums_r)$.</p><p>请你找出 nums 中 <strong>和的绝对值</strong> 最大的任意子数组（<strong>可能为空</strong>），并返回该 <strong>最大值</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [1,-3,2,3,-4]<br>输出：5<br>解释：子数组 [2,3] 和的绝对值最大，为 abs(2+3) = abs(5) = 5 。<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><p>我们使用一个 $sum$ 数组来保存前缀和，然后<em><strong>使用 $maxn$ 和 $minn$ 来保存遍历过程中前缀和的最大值和最小值</strong></em>，这样相当于丢弃 $maxn$ 或 $minn$ 前面的子数组，可以使得目前的 $sum[i]-maxn$ 可能得到一个较大的负值 ( 也许是正值 )，$sum[i] - minn$ 可能得到一个较大的正值 ( 也许是负值 )，然后更新答案变量即可.</p><p>值得注意的细节：</p><p>前缀和数组 $sum$ 我们申请多一个空间，这样就不需要单独判断 $0$ 这个可能溢出的点了，<em><strong>子区间 $[i,j]$ 的和为 $sum[j + 1]-sum[i]$</strong></em>.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAbsoluteSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>) nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            sum[i] = sum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, maxn = <span class="hljs-number">0</span>, minn = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">abs</span>(sum[i] - maxn));<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">abs</span>(sum[i] - minn));<br>            maxn = <span class="hljs-built_in">max</span>(maxn, sum[i]);<br>            minn = <span class="hljs-built_in">min</span>(minn, sum[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a><a href="https://leetcode-cn.com/problems/largest-number/">179. 最大数</a></h3><p>给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p><p><strong>注意：</strong>输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [10,2]<br>输出：&quot;210&quot;<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [3,30,34,5,9]<br>输出：&quot;9534330&quot;<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><p>由题意，我们可以知道，开头位越大的数字拼接起来越大，我们可以使用排序来解决此问题.</p><p>字符串拼接容易理解，但是题目中给出的是 int 型的数据类型，这样就涉及一个基础的问题了，如何实现整数拼接？</p><p>我们可以将两个数的位数分别拉长，再将对方的数加上，最后再比大小.</p><p>举个例子： $(x&#x3D;442,<del>y&#x3D;4)</del>\Rightarrow~~ (x&#x3D;4420,<del>y&#x3D;4000)</del>\Rightarrow<del>(x&#x3D;4424,</del>y&#x3D;4442)$.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">largestNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;y) &#123;<br>            <span class="hljs-type">long</span> sx = <span class="hljs-number">10</span>, sy = <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">while</span> (sx &lt;= x) &#123;<br>                sx *= <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (sy &lt;= y) &#123;<br>                sy *= <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> sy * x + y &gt; sx * y + x;<br>        &#125;);<br>        <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] *** <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>        string ret;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;x : nums) &#123;<br>            ret += <span class="hljs-built_in">to_string</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="Chapter6-Bit-Manipulation"><a href="#Chapter6-Bit-Manipulation" class="headerlink" title="Chapter6 Bit Manipulation"></a>Chapter6 Bit Manipulation</h1><h3 id="1680-连接连续二进制数字「Medium」"><a href="#1680-连接连续二进制数字「Medium」" class="headerlink" title="1680. 连接连续二进制数字「Medium」"></a><a href="https://leetcode-cn.com/problems/concatenation-of-consecutive-binary-numbers/">1680. 连接连续二进制数字「Medium」</a></h3><p>给你一个整数 <code>n</code> ，请你将 <code>1</code> 到 <code>n</code> 的二进制表示连接起来，并返回连接结果对应的 <strong>十进制</strong> 数字对 <code>10^9 + 7</code> 取余的结果。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：n = 1<br>输出：1<br>解释：二进制的 &quot;1&quot; 对应着十进制的 1 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：n = 3<br>输出：27<br>解释：二进制下，1，2 和 3 分别对应 &quot;1&quot; ，&quot;10&quot; 和 &quot;11&quot; 。<br>将它们依次连接，我们得到 &quot;11011&quot; ，对应着十进制的 27 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：n = 12<br>输出：505379714<br>解释：连接结果为 &quot;1101110010111011110001001101010111100&quot; 。<br>对应的十进制数字为 118505380540 。<br>对 109 + 7 取余后，结果为 505379714 。<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><p>由于我们需要将「十进制转换成二进制」「进行运算」「将结果转换回十进制」这三个步骤，因此我们不妨直接将整个问题在十进制的角度下进行考虑。</p><p>假设我们当前处理到了数字 $i$，并且前面 $[1,i-1]$ 的二进制连接起来对应的<strong>十进制数</strong>为 $x$，那么我们如何将数字 $i$ 进行连接呢？</p><p>观察二进制连接的过程，我们可以将这一步运算抽象为两个步骤：</p><ol><li>将之前 $[1,i-1]$ 的二进制数<strong>左移</strong>若干位，这个位数就是 $i$ 的二进制表示的位数；</li><li>将 $i$ 通过<strong>加法运算</strong>与左移的结果进行相加。</li></ol><p>这样，我们可以得到 $x$ 的递推式：$x&#x3D;x\times2^{len(i)}+i$.</p><p>我们可以知道 $len(i)$ 和 $len(i-1)$ 要么相等，要么相差 $1$.</p><p>$x$ 是 $(100\cdots)_2$ 的形式存储，而 $x-1$ 是以 $(111\cdots)_2$ 的形式存在，所以当一个数 $x$ 为 $2$ 的倍数次的时候，那么它比 $x-1$ 多一位，因此***当 <code>x &amp; (x - 1) *** 0</code> 的时候，移位的位数就需要加 $1$***，答案就显而易见了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">concatenatedBinary</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> times = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((i &amp; (i - <span class="hljs-number">1</span>)) *** <span class="hljs-number">0</span>) ++times;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; times; ++j) &#123;<br>                ans &lt;&lt;= <span class="hljs-number">1</span>;<br>                ans %= mod;<br>            &#125;<br>            ans += i;<br>            ans %= mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-56-I-数组中数字出现的次数「Medium」"><a href="#剑指-Offer-56-I-数组中数字出现的次数「Medium」" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数「Medium」"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数「Medium」</a></h3><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是 $O(n)$，空间复杂度是 $O(1)$.</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [4,1,4,6]<br>输出：[1,6] 或 [6,1]<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><p>设两个只出现一次的数字为 $x,y$，由于 $x≠y$，则 $x$ 和 $y$ 二进制至少有一位不同（即分别为 $0$ 和 $1$ ），根据此位可以将 $nums$ 拆分为分别包含 $x$ 和 $y$ 的两个子数组。</p><p>易知两子数组都满足 「除一个数字之外，其他数字都出现了两次」。因此，仿照以上简化问题的思路，分别对两子数组遍历执行异或操作，即可得到两个只出现一次的数字 $x,y$.</p><p>算法流程：</p><ol><li><p>遍历 $nums$ 执行异或：</p><ul><li>设整型数组 $nums&#x3D;[a,a,b,b\cdots,x,y]$，对 $nums$ 中所有数字进行异或，得到的结果为 $x\bigoplus y$.</li></ul></li><li><p>循环左移计算 m:</p><ul><li><p>根据异或运算定义，若整数 $x\bigoplus y$ 某二进制位为 $1$，则 $x$ 和 $y$ 的此二进制位一定不同。换言之，找到  $x\bigoplus y$ 某位为 $1$ 的二进制位，即可将数组 $nums$ 拆分为上述的两个子数组。根据与运算特点，可知对于任意整数 $a$ 有：</p><ul><li>若 $a$ &amp; $0001&#x3D;1$，则 $a$ 的第一位为 $1$ ；</li><li>若 $a$ &amp; $0010&#x3D;1$，则 $a$ 的第二位为 $1$ ；</li><li>以此类推…</li></ul></li><li><p>因此，初始化一个辅助变量 $m&#x3D;1$，通过与运算从右向左循环判断，可 <strong>获取整数</strong> $x\bigoplus y$ <strong>首位</strong> $1$，记录于 $m$ 中，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(z &amp; m *** <span class="hljs-number">0</span>) <span class="hljs-comment">// m 循环左移一位，直到 z &amp; m ！= 0</span><br>    m &lt;&lt;= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>拆分</strong> $nums$ <strong>为两个子数组</strong>；</p></li><li><p><strong>分别遍历两个子数组执行异或</strong>；</p><ul><li>通过遍历判断 $nums$ 中各数字和 $m$ 做与运算的结果，可将数组拆分为两个子数组，并分别对两个子数组遍历求异或，则可得到两个只出现一次的数字</li></ul></li></ol><p><img src="https://pic.leetcode-cn.com/1611415418-aCzGJI-Picture2.png" alt="picture"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">singleNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>, m = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)         <span class="hljs-comment">// 1. 遍历异或</span><br>            n ^= num;<br>        <span class="hljs-keyword">while</span>((n &amp; m) *** <span class="hljs-number">0</span>)         <span class="hljs-comment">// 2. 循环左移，计算 m</span><br>            m &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums) &#123;       <span class="hljs-comment">// 3. 遍历 nums 分组</span><br>            <span class="hljs-keyword">if</span>(num &amp; m) x ^= num;   <span class="hljs-comment">// 4. 当 num &amp; m != 0</span><br>            <span class="hljs-keyword">else</span> y ^= num;          <span class="hljs-comment">// 4. 当 num &amp; m *** 0</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123;x, y&#125;;  <span class="hljs-comment">// 5. 返回出现一次的数字</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-56-II-数组中数字出现的次数-II「Medium」"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II「Medium」" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II「Medium」"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II「Medium」</a></h3><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [3,4,3,3]<br>输出：4<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><p>方法一：有限状态自动机</p><p>各二进制位的 位运算规则相同 ，因此只需考虑一位即可。如下图所示，对于所有数字中的某二进制位 $1$ 的个数，存在 $3$ 种状态，即对 $3$ 余数为 $0, 1, 2$.</p><ul><li>若输入二进制位 $1$，则状态按照 $0\rightarrow1\rightarrow2\rightarrow0\rightarrow\cdots$ 顺序转换；</li><li>若输入二进制位 $0$，则状态不变.</li></ul><p><img src="https://pic.leetcode-cn.com/1603022900-GNKGMP-Picture2.png" alt="picture"></p><p>如下图所示，由于二进制只能表示 $0,1$，因此需要使用两个二进制位来表示 $3$ 个状态。设此两位分别为 $two,one$，则状态转换变为：$00\rightarrow01\rightarrow10\rightarrow00\rightarrow\cdots$ </p><p>![image-20210304232713519](&#x2F;Users&#x2F;wanglei&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210304232713519.png)</p><p>接下来，需要通过<strong>状态转换表</strong>导出<strong>状态转换的计算公式</strong>。首先回忆一下位运算特点，对于任意二进制位 $x$，有：</p><ul><li>异或运算：<code>x ^ 0 = x</code> ， <code>x ^ 1 = ~x</code> </li><li>与运算：<code>x &amp; 0 = 0</code> ， <code>x &amp; 1 = x</code></li></ul><p><em><strong>计算 $one$ 方法</strong></em>：</p><p>设当前状态为 $two,one$，此时输入二进制位 $n$。如下图所示，通过对状态表的情况拆分，可推出 $one$ 的计算方法为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> two *** <span class="hljs-number">0</span>:<br>  <span class="hljs-keyword">if</span> n *** <span class="hljs-number">0</span>:<br>    one = one<br>  <span class="hljs-keyword">if</span> n *** <span class="hljs-number">1</span>:<br>    one = ~one<br><span class="hljs-keyword">if</span> two *** <span class="hljs-number">1</span>:<br>    one = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>引入 <strong>异或运算</strong> ，可将以上拆分简化为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> two *** <span class="hljs-number">0</span>:<br>    one = one ^ n<br><span class="hljs-keyword">if</span> two *** <span class="hljs-number">1</span>:<br>    one = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>引入 <strong>与运算</strong> ，可继续简化为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">one = one ^ n &amp; ~two<br></code></pre></td></tr></table></figure><p><img src="https://pic.leetcode-cn.com/1603022900-qIFpAR-Picture4.png" alt="p"></p><p><em><strong>计算 $two$ 方法</strong></em>：</p><p>由于是先计算 $one$ ，因此应在新 $one$ 的基础上计算 $two$.</p><p>如下图所示，修改为新 $one$ 后，得到了新的状态图。观察发现，可以使用同样的方法计算 $two$，即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">two = two ^ n &amp; ~one<br></code></pre></td></tr></table></figure><p><img src="https://pic.leetcode-cn.com/1603022900-hnUxBz-Picture5.png" alt="picture"></p><p><em><strong><strong>返回值</strong></strong></em>：</p><p>以上是对数字的二进制中 “一位” 的分析，而 <code>int</code> 类型的其他 $31$ 位具有相同的运算规则，因此可将以上公式直接套用在 $32$ 位数上。</p><p>遍历完所有数字后，各二进制位都处于状态 $00$ 和状态 $01$ ( 取决于 “只出现一次的数字” 的各二进制位是 $0$ 还是 $1$ )，而此两状态是由 $one$ 来记录的 ( 此两状态下 $twos$ 恒为 $0$ )，因此返回 $ones$ 即可.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ones = <span class="hljs-number">0</span>, twos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;num : nums)&#123;<br>            ones = ones ^ num &amp; ~twos;<br>            twos = twos ^ num &amp; ~ones;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ones;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-65-不用加减乘除做加法「Easy」"><a href="#剑指-Offer-65-不用加减乘除做加法「Easy」" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法「Easy」"></a><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">剑指 Offer 65. 不用加减乘除做加法「Easy」</a></h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“&#x2F;” 四则运算符号。</p><p><strong>示例:</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入: a = 1, b = 1<br>输出: 2<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>a</code>, <code>b</code> 均可能是负数或 $0$</li><li>结果不会溢出 $32$ 位整数</li></ul><blockquote><p>算法分析：</p><p>观察发现，<strong>无进位和</strong> 与 <strong>异或运算</strong> 规律相同，<strong>进位</strong> 和 <strong>与运算</strong> 规律相同 ( 并需左移一位 ) 。因此，无进位和 $n$ 与进位 $c$ 的计算公式如下：<br>$$<br>\left{<br>\begin{aligned}<br>&amp;n&#x3D;a\bigoplus b &amp; 非进位和：异或运算\<br>&amp;c&#x3D;a<del>&amp;</del>b~&lt;&lt;1 &amp; 进位：与运算+左移一位\<br>\end{aligned}<br>\right.<br>$$<br>和 ( $s$ ）&#x3D;（非进位和 $n$ ）+（进位 $c$ ）。即可将 $s&#x3D;a+b$ 转化为：$s&#x3D;a+b\Rightarrow s&#x3D;n+c$.</p><p>循环求 $n$ 和 $c$，直至进位 $c&#x3D;0$；此时 $s&#x3D;n$，返回 $n$ 即可.</p><p><img src="https://pic.leetcode-cn.com/9716b1a1ead21824b8216c7d54910bee4d838c011581f4e3d82a14f71cb392a1-Picture1.png" alt="picture"></p></blockquote><blockquote><p>Q ： 若数字 $a$ 和 $b$ 中有负数，则变成了减法，如何处理？<br>A ： 在计算机系统中，数值一律用 补码 来表示和存储。补码的优势： 加法、减法可以统一处理（CPU只有加法器）。因此，以上方法 同时适用于正数和负数的加法 。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 当进位为 0 时跳出</span><br>            <span class="hljs-type">int</span> c = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// c = 进位</span><br>            a ^= b; <span class="hljs-comment">// a = 非进位和</span><br>            b = c; <span class="hljs-comment">// b = 进位</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="Chapter7-BackTrack"><a href="#Chapter7-BackTrack" class="headerlink" title="Chapter7 BackTrack"></a>Chapter7 BackTrack</h1><h3 id="51-N-皇后「Hard」"><a href="#51-N-皇后「Hard」" class="headerlink" title="51. N 皇后「Hard」"></a><a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后「Hard」</a></h3><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。皇后彼此不能相互攻击，也就是说：<em><strong>任何两个皇后都不能处于同一条横行、纵行或斜线上</strong></em>。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="picture"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：n = 4<br>输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]<br>解释：如上图所示，4 皇后问题存在两个不同的解法。<br></code></pre></td></tr></table></figure><blockquote><p>算法分析：</p><p><strong>方法一：基于集合的回溯</strong></p><p>为了判断一个位置所在的列和两条斜线上是否已经有皇后，使用三个集合 $columns,<del>diagonals1,</del>diagonals2$ 分别记录每一列以及两个方向的每条斜线上是否有皇后。</p><p>列的表示法很直观，一共有 $N$ 列，每一列的下标范围从 $0$ 到 $N-1$，使用列的下标即可明确表示每一列。</p><p>如何表示两个方向的斜线呢？对于每个方向的斜线，需要找到斜线上的每个位置的行下标与列下标之间的关系。</p><p>方向一的斜线为从左上到右下方向，同一条斜线上的每个位置满足<strong>行下标与列下标之差相等</strong>，例如 $(0,0)$ 和 $(3,3)$ 在同一条方向一的斜线上。因此使用行下标与列下标之差即可明确表示每一条方向一的斜线。</p><p><img src="https://assets.leetcode-cn.com/solution-static/51/1.png" alt="picture"></p><p>方向二的斜线为从右上到左下方向，同一条斜线上的每个位置满足<strong>行下标与列下标之和相等</strong>，例如 $(3,0)$ 和 $(1,2)$ 在同一条方向二的斜线上。因此使用行下标与列下标之和即可明确表示每一条方向二的斜线。</p><p><img src="https://assets.leetcode-cn.com/solution-static/51/2.png" alt="picture"></p><p>每次放置皇后时，对于每个位置判断其是否在三个集合中，如果三个集合都不包含当前位置，则当前位置是可以放置皇后的位置。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-keyword">auto</span> solutions = vector&lt;vector&lt;string&gt;&gt;();<br>        <span class="hljs-keyword">auto</span> queens = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">auto</span> columns = <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-keyword">auto</span> diagonals1 = <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-keyword">auto</span> diagonals2 = <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-built_in">backtrack</span>(solutions, queens, n, <span class="hljs-number">0</span>, columns, diagonals1, diagonals2);<br>        <span class="hljs-keyword">return</span> solutions;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt; &amp;solutions, vector&lt;<span class="hljs-type">int</span>&gt; &amp;queens, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, unordered_set&lt;<span class="hljs-type">int</span>&gt; &amp;columns, unordered_set&lt;<span class="hljs-type">int</span>&gt; &amp;diagonals1, unordered_set&lt;<span class="hljs-type">int</span>&gt; &amp;diagonals2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (row *** n) &#123;<br>            vector&lt;string&gt; board = <span class="hljs-built_in">generateBoard</span>(queens, n);<br>            solutions.<span class="hljs-built_in">push_back</span>(board);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (columns.<span class="hljs-built_in">find</span>(i) != columns.<span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> diagonal1 = row - i;<br>                <span class="hljs-keyword">if</span> (diagonals<span class="hljs-number">1.f</span>ind(diagonal1) != diagonals<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> diagonal2 = row + i;<br>                <span class="hljs-keyword">if</span> (diagonals<span class="hljs-number">2.f</span>ind(diagonal2) != diagonals<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                queens[row] = i;<br>                columns.<span class="hljs-built_in">insert</span>(i);<br>                diagonals<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(diagonal1);<br>                diagonals<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(diagonal2);<br>                <span class="hljs-built_in">backtrack</span>(solutions, queens, n, row + <span class="hljs-number">1</span>, columns, diagonals1, diagonals2);<br>                queens[row] = <span class="hljs-number">-1</span>;<br>                columns.<span class="hljs-built_in">erase</span>(i);<br>                diagonals<span class="hljs-number">1.</span><span class="hljs-built_in">erase</span>(diagonal1);<br>                diagonals<span class="hljs-number">2.</span><span class="hljs-built_in">erase</span>(diagonal2);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateBoard</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;queens, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> board = <span class="hljs-built_in">vector</span>&lt;string&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            string row = <span class="hljs-built_in">string</span>(n, <span class="hljs-string">&#x27;.&#x27;</span>);<br>            row[queens[i]] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            board.<span class="hljs-built_in">push_back</span>(row);<br>        &#125;<br>        <span class="hljs-keyword">return</span> board;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="90-子集-II「Hard」"><a href="#90-子集-II「Hard」" class="headerlink" title="90. 子集 II「Hard」"></a><a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II「Hard」</a></h3><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [1,2,2]<br>输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [0]<br>输出：[[],[0]]<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; t;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">bool</span> choosePre, <span class="hljs-type">int</span> cur, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur *** nums.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(t);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-literal">false</span>, cur + <span class="hljs-number">1</span>, nums);<br>        <span class="hljs-keyword">if</span> (!choosePre &amp;&amp; cur &gt; <span class="hljs-number">0</span> &amp;&amp; nums[cur - <span class="hljs-number">1</span>] *** nums[cur]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        t.<span class="hljs-built_in">push_back</span>(nums[cur]);<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-literal">true</span>, cur + <span class="hljs-number">1</span>, nums);<br>        t.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode Debug</title>
    <link href="/1976/04/01/VSCode%20Debug/"/>
    <url>/1976/04/01/VSCode%20Debug/</url>
    
    <content type="html"><![CDATA[<h1 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h1><ul><li><h4 id="SyntaxError-Non-ASCII-character-xe6-in-file"><a href="#SyntaxError-Non-ASCII-character-xe6-in-file" class="headerlink" title="SyntaxError: Non-ASCII character &#39;\xe6&#39; in file"></a><code>SyntaxError: Non-ASCII character &#39;\xe6&#39; in file</code></h4><ul><li>解决方案：主文件输入 <code>-\*- coding: utf-8 -* </code></li><li>原理：未知</li></ul></li><li><h4 id="python无法找到本就存在的库-no-import-module-named-xxx"><a href="#python无法找到本就存在的库-no-import-module-named-xxx" class="headerlink" title="python无法找到本就存在的库  no import module named &quot;xxx&quot;"></a>python无法找到本就存在的库  <code>no import module named &quot;xxx&quot;</code></h4><ul><li><p>解决方案1： 其实是无法链接的问题，引入ssl库进行链接即可</p><ul><li>import ssl</li><li>ssl._create_default_https_context &#x3D; ssl._create_unverified_context</li></ul></li><li><p>解决方案2 ： Vscode的coderunner扩展有问题，它的默认python路径是python2.7, 所以检测不出库</p><p>在setting.json 中添加这个条目即可。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;code-runner.executorMap&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;python&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;python3 -u&quot;</span><span class="hljs-punctuation">,</span><br><br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About Binary Search</title>
    <link href="/1976/04/01/about%20Binary%20Search%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/1976/04/01/about%20Binary%20Search%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="about-Binary-Search-二分查找"><a href="#about-Binary-Search-二分查找" class="headerlink" title="about Binary Search 二分查找"></a>about Binary Search 二分查找</h1><h3 id="普通的二分查找"><a href="#普通的二分查找" class="headerlink" title="普通的二分查找"></a>普通的二分查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinarySearch_nonrecursive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = (<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;  <span class="hljs-comment">//不加 = 如果数组长度为1 会错</span><br>        <span class="hljs-type">int</span> mid = (left + right)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//递归 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinarySearch_recursive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (nums[mid] &gt; target) <span class="hljs-keyword">return</span> <span class="hljs-built_in">BinarySearch_recursive</span>(nums, target, left, mid - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) <span class="hljs-keyword">return</span> <span class="hljs-built_in">BinarySearch_recursive</span>(nums, target, mid + <span class="hljs-number">1</span>, right);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如果你只想要二分查找找到的第一个："><a href="#如果你只想要二分查找找到的第一个：" class="headerlink" title="如果你只想要二分查找找到的第一个："></a>如果你只想要二分查找找到的第一个：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinarySearch_First_nonrecursive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123; <span class="hljs-comment">//查找第一个</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = (<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = (left + right)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[left] == target ? left : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>(l + r + 1) &gt;&gt; 1; 进阶的 (r - l)&#x2F;2 + l;</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About Bit Manipulation (Bit-Twiddling)</title>
    <link href="/1976/04/01/about%20Bit%20Manipulation/"/>
    <url>/1976/04/01/about%20Bit%20Manipulation/</url>
    
    <content type="html"><![CDATA[<h1 id="about-位运算-运算符"><a href="#about-位运算-运算符" class="headerlink" title="about 位运算 (运算符)"></a>about 位运算 (运算符)</h1><h3 id="uint32-t-32位二进制整数-一般情况下-左移就是除二"><a href="#uint32-t-32位二进制整数-一般情况下-左移就是除二" class="headerlink" title="uint32_t   32位二进制整数  一般情况下 左移就是除二"></a>uint32_t   32位二进制整数  一般情况下 左移就是除二</h3><h5 id="x-x-1-可以检测是否是2的整数次幂-x-x-1-可以清除最右边的1-如果这个1是第一位的1-那这个数就变为0"><a href="#x-x-1-可以检测是否是2的整数次幂-x-x-1-可以清除最右边的1-如果这个1是第一位的1-那这个数就变为0" class="headerlink" title="x &amp; x-1 可以检测是否是2的整数次幂  (x&amp;x-1 可以清除最右边的1,如果这个1是第一位的1, 那这个数就变为0)"></a>x &amp; x-1 可以检测是否是2的整数次幂  (x&amp;x-1 可以清除最右边的1,如果这个1是第一位的1, 那这个数就变为0)</h5><h4 id="n-1-在32位下-1是-00000····001-而不是111···1-用来检测奇偶性-最后一位是否为1-偶数结果为0"><a href="#n-1-在32位下-1是-00000····001-而不是111···1-用来检测奇偶性-最后一位是否为1-偶数结果为0" class="headerlink" title="n &amp; 1 (在32位下 1是 00000····001 而不是111···1)   用来检测奇偶性(最后一位是否为1)   偶数结果为0"></a>n &amp; 1 (在32位下 1是 00000····001 而不是111···1)   用来检测奇偶性(最后一位是否为1)   偶数结果为0</h4><h4 id="对于x-取其第i位的二进制-rightarrow-x-i-1-比如在477-汉明距离总和-我们有时候可以将每一个二进制位分开来看"><a href="#对于x-取其第i位的二进制-rightarrow-x-i-1-比如在477-汉明距离总和-我们有时候可以将每一个二进制位分开来看" class="headerlink" title="对于x , 取其第i位的二进制 $\rightarrow$ (x &gt;&gt; i) &amp; 1,  比如在477. 汉明距离总和 我们有时候可以将每一个二进制位分开来看"></a>对于x , 取其第i位的二进制 $\rightarrow$ (x &gt;&gt; i) &amp; 1,  比如在<a href="https://leetcode-cn.com/problems/total-hamming-distance/">477. 汉明距离总和</a> 我们有时候可以将每一个二进制位分开来看</h4><h3 id="builtin-popcount-i-计算32位整型里-1的个数"><a href="#builtin-popcount-i-计算32位整型里-1的个数" class="headerlink" title="__builtin_popcount(i) 计算32位整型里 1的个数"></a>__builtin_popcount(i) 计算32位整型里 1的个数</h3><p>编程对于&amp; | ~的运算是基于二进制结果的记忆，但实际上还是逻辑问题</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与操作，按二进制位进行”与”运算。                                                             运算规则：<code>0&amp;0=0;    0&amp;1=0;     1&amp;0=0;      1&amp;1=1;</code></td><td>(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td>|</td><td>按位或运算符，按二进制位进行”或”运算。                                                         运算规则：&#96;0</td><td>0&#x3D;0;    0</td></tr><tr><td>^</td><td>异或运算符，按二进制位进行”异或”运算。                                                         运算规则：<code>0^0=0;    0^1=1;    1^0=1;   1^1=0;</code></td><td>(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td>~</td><td>取反运算符，按二进制位进行”取反”运算。                                                         运算规则：<code>~1=-2;    ~0=1;</code></td><td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr><tr><td>&lt;&lt;</td><td>二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）</td><td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</td><td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr></tbody></table><h3 id="位运算也有赋值运算符"><a href="#位运算也有赋值运算符" class="headerlink" title="位运算也有赋值运算符"></a>位运算也有赋值运算符</h3><table><thead><tr><th>&lt;&lt;&#x3D;</th><th>左移且赋值运算符</th><th>C &lt;&lt;&#x3D; 2 等同于 C &#x3D; C &lt;&lt; 2</th></tr></thead><tbody><tr><td>&gt;&gt;&#x3D;</td><td>右移且赋值运算符</td><td>C &gt;&gt;&#x3D; 2 等同于 C &#x3D; C &gt;&gt; 2</td></tr><tr><td>&amp;&#x3D;</td><td>按位与且赋值运算符</td><td>C &amp;&#x3D; 2 等同于 C &#x3D; C &amp; 2</td></tr><tr><td>^&#x3D;</td><td>按位异或且赋值运算符</td><td>C ^&#x3D; 2 等同于 C &#x3D; C ^ 2</td></tr><tr><td>|&#x3D;</td><td>按位或且赋值运算符</td><td>C |&#x3D; 2 等同于 C &#x3D; C | 2</td></tr></tbody></table><h3 id="杂项运算符"><a href="#杂项运算符" class="headerlink" title="杂项运算符"></a>杂项运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>sizeof</td><td><a href="https://www.runoob.com/cplusplus/cpp-sizeof-operator.html">sizeof 运算符</a>返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。</td></tr><tr><td>Condition ? X : Y</td><td><a href="https://www.runoob.com/cplusplus/cpp-conditional-operator.html">条件运算符</a>。如果 Condition 为真 ? 则值为 X : 否则值为 Y。</td></tr><tr><td>,</td><td><a href="https://www.runoob.com/cplusplus/cpp-comma-operator.html">逗号运算符</a>会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。</td></tr><tr><td>.（点）和 -&gt;（箭头）</td><td><a href="https://www.runoob.com/cplusplus/cpp-member-operators.html">成员运算符</a>用于引用类、结构和共用体的成员。</td></tr><tr><td>Cast</td><td><a href="https://www.runoob.com/cplusplus/cpp-casting-operators.html">强制转换运算符</a>把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。</td></tr><tr><td>&amp;</td><td><a href="https://www.runoob.com/cplusplus/cpp-pointer-operators.html">指针运算符 &amp;</a> 返回变量的地址。例如 &a; 将给出变量的实际地址。</td></tr><tr><td>*</td><td><a href="https://www.runoob.com/cplusplus/cpp-pointer-operators.html">指针运算符 *</a> 指向一个变量。例如，*var; 将指向变量 var。</td></tr></tbody></table><h3 id="运算符优先级-「由高到低」"><a href="#运算符优先级-「由高到低」" class="headerlink" title="运算符优先级 「由高到低」"></a>运算符优先级 「由高到低」</h3><table><thead><tr><th>类别</th><th>运算符</th><th>结合性</th></tr></thead><tbody><tr><td>后缀</td><td>() [] -&gt; . ++ - -</td><td>从左到右</td></tr><tr><td>一元</td><td>+ - ! ~ ++ - - (type)* &amp; sizeof</td><td>从右到左</td></tr><tr><td>乘除</td><td>* &#x2F; %</td><td>从左到右</td></tr><tr><td>加减</td><td>+ -</td><td>从左到右</td></tr><tr><td>移位</td><td>&lt;&lt; &gt;&gt;</td><td>从左到右</td></tr><tr><td>关系</td><td>&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td><td>从左到右</td></tr><tr><td>相等</td><td>&#x3D;&#x3D; !&#x3D;</td><td>从左到右</td></tr><tr><td>位与 AND</td><td>&amp;</td><td>从左到右</td></tr><tr><td>位异或 XOR</td><td>^</td><td>从左到右</td></tr><tr><td>位或 OR</td><td>|</td><td>从左到右</td></tr><tr><td>逻辑与 AND</td><td>&amp;&amp;</td><td>从左到右</td></tr><tr><td>逻辑或 OR</td><td>||</td><td>从左到右</td></tr><tr><td>条件</td><td>?:</td><td>从右到左</td></tr><tr><td>赋值</td><td>&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;&gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;</td><td>从右到左</td></tr><tr><td>逗号</td><td>,</td><td>从左到右</td></tr></tbody></table><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0xaaaaaaaa</span> = <span class="hljs-number">10101010101010101010101010101010</span> (偶数位为<span class="hljs-number">1</span>，奇数位为<span class="hljs-number">0</span>）<br><span class="hljs-attribute">0x55555555</span> = <span class="hljs-number">1010101010101010101010101010101</span> (偶数位为<span class="hljs-number">0</span>，奇数位为<span class="hljs-number">1</span>）<br><span class="hljs-attribute">0x33333333</span> = <span class="hljs-number">110011001100110011001100110011</span> (<span class="hljs-number">1</span>和<span class="hljs-number">0</span>每隔两位交替出现)<br><span class="hljs-attribute">0xcccccccc</span> = <span class="hljs-number">11001100110011001100110011001100</span> (<span class="hljs-number">0</span>和<span class="hljs-number">1</span>每隔两位交替出现)<br><span class="hljs-attribute">0x0f0f0f0f</span> = <span class="hljs-number">00001111000011110000111100001111</span> (<span class="hljs-number">1</span>和<span class="hljs-number">0</span>每隔四位交替出现)<br><span class="hljs-attribute">0xf0f0f0f0</span> = <span class="hljs-number">11110000111100001111000011110000</span> (<span class="hljs-number">0</span>和<span class="hljs-number">1</span>每隔四位交替出现)<br></code></pre></td></tr></table></figure><hr><h3 id="190-颠倒二进制位-「-和-的区别」"><a href="#190-颠倒二进制位-「-和-的区别」" class="headerlink" title="190. 颠倒二进制位  「&gt;&gt;&#x3D; 和 &gt;&gt; 的区别」"></a><a href="https://leetcode-cn.com/problems/reverse-bits/">190. 颠倒二进制位</a>  「&gt;&gt;&#x3D; 和 &gt;&gt; 的区别」</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// res 一开始为0, 每次我们都将 res左移, 将n右移</span><br><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> </span>&#123;<br>        <span class="hljs-type">uint32_t</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i) &#123;<br>            res = (res &lt;&lt; <span class="hljs-number">1</span>) | (n &amp; <span class="hljs-number">1</span>);   <br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h3 id="XOR-异或运算的性质"><a href="#XOR-异或运算的性质" class="headerlink" title="XOR 异或运算的性质:"></a>XOR 异或运算的性质:</h3><ol><li><p>x⊕x&#x3D;0 ,  x⊕0 &#x3D; x</p></li><li><h4 id="x⊕y-y⊕x-交换律"><a href="#x⊕y-y⊕x-交换律" class="headerlink" title="x⊕y&#x3D;y⊕x (交换律)"></a>x⊕y&#x3D;y⊕x (交换律)</h4></li><li><p>(x⊕y)⊕z&#x3D;x⊕(y⊕z) (结合律)    「不支持分配律」</p></li><li><p>x⊕y⊕y&#x3D;x (自反性)</p></li><li><p>∀i∈Z，有 4i⊕(4i+1)⊕(4i+2)⊕(4i+3)&#x3D;0</p></li></ol><hr><h4 id="在342-4的幂-偶数位上是1的32位整形-0xaaaaaaaa"><a href="#在342-4的幂-偶数位上是1的32位整形-0xaaaaaaaa" class="headerlink" title="在342. 4的幂  偶数位上是1的32位整形, 0xaaaaaaaa"></a>在<a href="https://leetcode-cn.com/problems/power-of-four/">342. 4的幂</a>  偶数位上是1的32位整形, 0xaaaaaaaa</h4><hr><h3 id="如何取按照要求-取一个整型中的某些二进制位？"><a href="#如何取按照要求-取一个整型中的某些二进制位？" class="headerlink" title="如何取按照要求 取一个整型中的某些二进制位？"></a>如何取按照要求 取一个整型中的某些二进制位？</h3><ul><li><h4 id="对于x-取其第i位的二进制-rightarrow-x-i-1-从0开始"><a href="#对于x-取其第i位的二进制-rightarrow-x-i-1-从0开始" class="headerlink" title="对于x , 取其第i位的二进制 $\rightarrow$ (x &gt;&gt; i) &amp; 1 (从0开始)"></a>对于x , 取其第i位的二进制 $\rightarrow$ (x &gt;&gt; i) &amp; 1 (从0开始)</h4></li><li><p>如果我们框定了x的范围，比如我们确认x &lt;&#x3D; 1024 那么32位中必然只需要使用其中最右边的10位</p><ul><li>想取 高4位(即10位中左边的4位) 那显然 res &#x3D; x &gt;&gt; 6</li><li>想取 低6位 则不需要移位，可以通过&#x3D;&#x3D;与运算(和全1与)&#x3D;&#x3D;直接取 比如这里 2^6 -1   res &#x3D; x &amp; 63;</li></ul></li></ul><h4 id="关于进制转换问题"><a href="#关于进制转换问题" class="headerlink" title="关于进制转换问题"></a>关于进制转换问题</h4><ul><li>我们使用的进制转换是<strong>短除法</strong>的进制转换，因此最后有一个 reverse 操作，不要忘记</li></ul><h4 id="交换x-y"><a href="#交换x-y" class="headerlink" title="交换x y"></a>交换x y</h4><ul><li>直接交换法:  a &#x3D; a - b , b &#x3D; a + b, a &#x3D; b - a;</li><li>异或法 : x &#x3D; x ^ y, y &#x3D; x ^ y, x &#x3D; x ^ y</li></ul><ul><li>一句话逻辑运算<ul><li>or &#x3D;&gt; 只要有 1 结果为 1</li><li>and &#x3D;&gt; 只有 1 &amp; 1 &#x3D; 1,其他为 0   <ul><li>取奇偶(配合移位取二进制)</li><li>分组(见<code>找出 2 个只出现 1 次的数</code>， 核心思想：按照某一位是否为 1 来把数组分成两个部分)</li></ul></li><li>xor &#x3D;&gt; 两个二进制不同, 结果为 1 &#x2F; 二进制不进位加法<ul><li>抵消 &#x2F; 二进制交换</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About C++ STL</title>
    <link href="/1976/04/01/about%20C++%20STL/"/>
    <url>/1976/04/01/about%20C++%20STL/</url>
    
    <content type="html"><![CDATA[<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; a,b; <span class="hljs-comment">//缺省所有参数时 size直接为0的</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span> <span class="hljs-comment">//注意不使用[] 使用()来选定大小 值默认为0</span><br><br><span class="hljs-built_in">vector</span>&lt;&gt;::reverse_iterator i;<span class="hljs-comment">//在STL库中定义反向迭代器 </span><br><span class="hljs-comment">//迭代器可以用来遍历，反向迭代器++之后往前移动 通过加*号的迭代器 也可以直接访问数组元素的值(作为在STL中封装好的指针来使用)</span><br>begin(),end(),rbegin(),rend(); <span class="hljs-comment">//后两个的意思</span><br><br>a.assign(b.begin(),b.begin()+<span class="hljs-number">3</span>); <span class="hljs-comment">//b数组的前3个元素分给a</span><br>a.assign(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">//4个2</span><br><br>a.back(); a.front(); a[i]; a.clear(); a.empty(); a.pop_back();<br><br><span class="hljs-comment">//删除a中第一个（从第0个算起）到第二个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）结束</span><br>a.erase(a.begin()+<span class="hljs-number">1</span>,a.begin()+<span class="hljs-number">3</span>);<br>a.push_back(); a.emplace_back(); <span class="hljs-comment">//两者一样功能 建议使用emplace 优化内存 c++11可以使用</span><br><br>a.insert(a.begin()+<span class="hljs-number">1</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">//第一个参数就是插入值之后这个值在数组里的下标！注意使用迭代器(前插)</span><br>a.insert(a.begin()+<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">//可以连续插入多个一样的 插入个数是第二个参数</span><br>a.inse3rt(a.begin()+<span class="hljs-number">1</span>,b+<span class="hljs-number">3</span>,b+<span class="hljs-number">6</span>); <span class="hljs-comment">//b是数组，在1号下标插入 b的[3,6)下标元素(不包括最后一个)</span><br><br>a.size();a.capacity(); <span class="hljs-comment">//返回数组大小 由于在空间不够时vector每次都直接扩大一倍，size返回的是元素的个数 而capacity返回的是现在vector能容纳多少个元素</span><br><br>a.resize(<span class="hljs-number">10</span>); <span class="hljs-comment">//把长度变成10 多删 少补(值随机)</span><br>a.resize(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">//与上面的区别在于补的数值默认为2</span><br>a.reserve(<span class="hljs-number">100</span>); <span class="hljs-comment">//注意和reverse区分 注意：reserve是保留空间，但不创建对象(resize的可以直接调用)</span><br><br><br>a.swap(b); <span class="hljs-comment">//交换向量a和b</span><br><span class="hljs-comment">//b为向量，向量的比较操作还有 != &gt;= &gt; &lt;= &lt;</span><br>a==b;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(a.begin(), a.begin()+k) ; 我们可以通过这个语句 来返回数组的 前k项<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><ol><li><p><strong>vector 没有length() 函数</strong></p></li><li><p>&#x3D;&#x3D;<strong>vector 只能push_back 和 pop_back 从头插入 使用insert(a.begin(), value)</strong>&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;<strong>所有的STL返回整型 全部都是 unsigned long 我们需要在前面加括号 用int型接收它们</strong>&#x3D;&#x3D;</p></li><li><p><strong>size 和 capicity 大部分时候不需要关注</strong></p></li><li><p>&#x3D;&#x3D;在你直接初始化一个二维数组时 你可以使用memset 也可以这样&#x3D;&#x3D;</p><p>&#x3D;&#x3D;<code>vector&lt;vector&lt;int&gt;&gt; (5, vector&lt;int&gt;(6,1))</code> 显然 这里用了套娃的属性&#x3D;&#x3D;</p></li><li><p><strong>少使用push_back() 要使用emplace_back();</strong></p></li><li><p>**vector&lt;pair &lt;int, int&gt; &gt; 或者 vector&lt;vector&lt;int,int&gt; &gt; 在用sort比较时 会先比较first 如果first相同，再比较second **</p></li></ol></blockquote><ul><li>关于<code>pair</code> <ul><li>Pair 定义有序对 是结构体 调用使用 <code>.first</code> 和 <code>.second</code> 比较时也是先比较first 再比较second</li></ul></li></ul><hr><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span> == #<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span> <span class="hljs-comment">//他们都是c语言的字符串库 ⚠️ 它们是不能定义string的 但可以使用字符串函数(如 strcpy)</span></span><br><br><span class="hljs-type">char</span>* <span class="hljs-type">char</span>[] <span class="hljs-comment">//都可以通过赋值 直接传给字符串对象 但字符串转到char[] 需要用data()或c_str()</span><br><br>string a, b<br><br>a.<span class="hljs-built_in">compare</span>(b); <span class="hljs-comment">//cmp函数 a和b相同返回0 a和b不同返回-1</span><br><br>a.<span class="hljs-built_in">find</span>(b); <span class="hljs-comment">// 寻找子串 , 未找寻到 返回 string::npos</span><br><br>a.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">// 从下标3开始 截取2个字符.</span><br>a.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 从下标2开始的所有字符 (包括2).</span><br></code></pre></td></tr></table></figure><p>注意string::npos的使用 </p><hr><h1 id="Hash-table"><a href="#Hash-table" class="headerlink" title="Hash table"></a>Hash table</h1><ul><li><h4 id="C-17-hash-table-遍历-迭代器遍历则应当注意我们不能通过迭代器更改元素值"><a href="#C-17-hash-table-遍历-迭代器遍历则应当注意我们不能通过迭代器更改元素值" class="headerlink" title="C++ 17 hash table 遍历 (迭代器遍历则应当注意我们不能通过迭代器更改元素值)"></a>C++ 17 hash table 遍历 (迭代器遍历则应当注意我们不能通过迭代器更改元素值)</h4><p>for (auto&amp; [_, c] : cnt) {            maxCnt &#x3D; max(maxCnt, c);        } &#x2F;&#x2F; first 和 second, 用 <code>_</code> 也可以不命名</p></li><li><h4 id="请务必使用-mp-count-element-来查看是否存在某个元素-使用-mp-element"><a href="#请务必使用-mp-count-element-来查看是否存在某个元素-使用-mp-element" class="headerlink" title="请务必使用(mp.count(element)) 来查看是否存在某个元素, 使用 !mp[element]"></a>请务必使用(mp.count(element)) 来查看是否存在某个元素, 使用 !mp[element]</h4><blockquote><p>e.g <a href="https://leetcode-cn.com/problems/contiguous-array/">525. 连续数组</a></p></blockquote></li></ul><hr><h1 id="Priority-queue"><a href="#Priority-queue" class="headerlink" title="Priority_queue"></a>Priority_queue</h1><h2 id="自实现heap"><a href="#自实现heap" class="headerlink" title="自实现heap"></a>自实现heap</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">min_heap</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">min_heap</span>() &#123; <span class="hljs-comment">//下标从1开始</span><br>        nums.<span class="hljs-built_in">emplace_back</span>(nullhead);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        nums.<span class="hljs-built_in">emplace_back</span>(val);<br>        <span class="hljs-built_in">Shift_up</span>((<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Shift_up</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (index / <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (nums[index/<span class="hljs-number">2</span>] &gt; nums[index]) <span class="hljs-built_in">swap</span>(nums[index], nums[index/<span class="hljs-number">2</span>]); <span class="hljs-comment">//由于向下取整 2i 和 2i+1 对应的双亲只要除2就能到</span><br>            index /= <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">heap_top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;nums[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_delete</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;ERROR&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        nums.<span class="hljs-built_in">erase</span>(nums.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span> + index);<br>        <span class="hljs-built_in">heap_sort</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> index = (<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">Shift_up</span>(index);<br>            index --;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_print</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//用来测试</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            cout &lt;&lt; nums[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h3><ol><li>上浮「shift_up」操作的关键在于 我们取1开始 两个孩子分别是 2i 和 2i+1 它们俩除2 可以同时到达双亲节点</li><li>我们把上浮定义成 可以指定任何一个下标 上浮。 这样的好处是 之后的 heap_sort 以及 Insert 函数 都很方便写了 「heapsort就是把每个元素都上浮，insert就是加到末尾然后上浮」</li><li>要注意的是 下标从1 开始 返回top的时候不要用front！</li></ol></blockquote><p>⚠️ 优先队列是一种数据结构 但堆不是 堆是优先队列的内部实现方式</p><h2 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h2><blockquote><ul><li><code>priority_queue&lt;int&gt; q;//等价于默认，从大到小排</code></li><li><code>priority_queue&lt;int, vector&lt;int&gt;,  less&lt;int&gt;&gt; q;//等价于默认，从大到小排</code></li><li><code>priority_queue&lt;int, vector&lt;int&gt;,  greater&lt;int&gt;&gt; q; 　　//通过操作，按照元素从小到大的顺序出队</code></li><li>priority_queue&lt;TreeNode*, vector&lt;TreeNode*&gt;,  decltype(cmp)&gt; q{cmp};</li></ul></blockquote><h2 id="自定义优先级"><a href="#自定义优先级" class="headerlink" title="自定义优先级"></a>自定义优先级</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;    <span class="hljs-comment">//通过传入不同类型来定义不同类型优先级</span><br>        <span class="hljs-keyword">return</span> a &gt; b;    <span class="hljs-comment">//最小值优先</span><br>      <span class="hljs-comment">//return a &lt; b; // 最大值优先</span><br>    &#125;<br>&#125;;<br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, cmp &gt; q;<br><br><span class="hljs-comment">//或者可以使用这种方式定义</span><br><span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">const</span> TreeNode* a, <span class="hljs-type">const</span> TreeNode* b) &#123;<br>    <span class="hljs-keyword">return</span> a-&gt;val &gt; b-&gt;val;<br>&#125;;<br>priority_queue&lt;TreeNode*, vector&lt;TreeNode*&gt;,  <span class="hljs-keyword">decltype</span>(cmp)&gt; q&#123;cmp&#125;;<br></code></pre></td></tr></table></figure><h2 id="自定义结构体、优先级"><a href="#自定义结构体、优先级" class="headerlink" title="自定义结构体、优先级"></a>自定义结构体、优先级</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> priority;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node &amp;a, <span class="hljs-type">const</span> node &amp;b) &#123;<br>        <span class="hljs-keyword">return</span> a.priority &lt; b.priority;<br>    &#125;<br>    <span class="hljs-comment">/* 这样写也可以</span><br><span class="hljs-comment">    bool operator &lt; (const node &amp;a) const &#123;</span><br><span class="hljs-comment">        return priority &lt; a.priority;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br>&#125;;<br><br>priority_queue&lt;node&gt; q;<br></code></pre></td></tr></table></figure><blockquote><p>因为标准库默认使用元素类型的 <code>&lt;</code> 操作符来确定它们之间的优先级关系。而且自定义类型的 <code>&lt;</code> 操作符与 <code>&gt;</code> 操作符并无直接联系，故会编译不过。</p><p>错误示范：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br> <span class="hljs-type">int</span> priority;<br> <span class="hljs-type">int</span> value;<br> <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &gt; (<span class="hljs-type">const</span> node &amp;a, <span class="hljs-type">const</span> node &amp;b) &#123;   <span class="hljs-comment">//错误示范</span><br>     <span class="hljs-keyword">return</span> a.priority &gt; b.priority;<br> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h2 id="decltype关键字-C-11"><a href="#decltype关键字-C-11" class="headerlink" title="decltype关键字 ( C++11 )"></a>decltype关键字 ( C++11 )</h2><blockquote><p><a href="https://baike.baidu.com/item/decltype">decltype</a>，在C++中，作为操作符，用于查询表达式的数据类型.</p><pre><code class="hljs">有时我们希望从表达式的**类型推断**出要定义的**变量类型**，但是不想用该表达式的值初始化变量 ( 如果要初始化就用auto了 )。为了满足这一需求，C++11新标准引入了decltype类型说明符，它的作用是**选择并返回操作数的数据类型**，在此过程中，编译器**分析**表达式并得到它的类型，却**不实际计算**表达式的值。</code></pre></blockquote><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> tempA = <span class="hljs-number">2</span>;<br>    <br>    <span class="hljs-comment">/*1.dclTempA为int*/</span><br>    <span class="hljs-keyword">decltype</span>(tempA) dclTempA;<br>    <span class="hljs-comment">/*2.dclTempB为int，对于getSize根本没有定义，但是程序依旧正常，因为decltype只做分析，并不调用getSize，*/</span><br>    <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">getSize</span>()) dclTempB;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="与-const-结合"><a href="#与-const-结合" class="headerlink" title="与 const 结合"></a>与 const 结合</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> tempA = <span class="hljs-number">3.0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> ctempA = <span class="hljs-number">5.0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> ctempB = <span class="hljs-number">6.0</span>；<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> *<span class="hljs-type">const</span> cptrTempA = &amp;ctempA;<br><span class="hljs-comment">/*1.dclTempA推断为const double（保留顶层const，此处与auto不同）*/</span><br><span class="hljs-keyword">decltype</span>(ctempA) dclTempA = <span class="hljs-number">4.1</span>;<br><span class="hljs-comment">/*2.dclTempA为const double，不能对其赋值，编译不过*/</span><br>dclTempA = <span class="hljs-number">5</span>;<br><span class="hljs-comment">/*3.dclTempB推断为const double * const*/</span><br><span class="hljs-keyword">decltype</span>(cptrTempA) dclTempB = &amp;ctempA;<br><span class="hljs-comment">/*4.输出为4（32位计算机）和5*/</span><br>cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(dclTempB)&lt;&lt;<span class="hljs-string">&quot;    &quot;</span>&lt;&lt;*dclTempB&lt;&lt;endl;<br><span class="hljs-comment">/*5.保留顶层const，不能修改指针指向的对象，编译不过*/</span><br>dclTempB = &amp;ctempB;<br><span class="hljs-comment">/*6.保留底层const，不能修改指针指向的对象的值，编译不过*/</span><br>*dclTempB = <span class="hljs-number">7.0</span>;<br></code></pre></td></tr></table></figure><h3 id="与引用结合"><a href="#与引用结合" class="headerlink" title="与引用结合"></a>与引用结合</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> tempA = <span class="hljs-number">0</span>, &amp;refTempA = tempA;<br><br><span class="hljs-comment">/*1.dclTempA为引用，绑定到tempA*/</span><br><span class="hljs-keyword">decltype</span>(refTempA) dclTempA = tempA;<br><span class="hljs-comment">/*2.dclTempB为引用，必须绑定到变量，编译不过*/</span><br><span class="hljs-keyword">decltype</span>(refTempA) dclTempB = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/*3.dclTempC为引用，必须初始化，编译不过*/</span><br><span class="hljs-keyword">decltype</span>(refTempA) dclTempC;<br><span class="hljs-comment">/*4.双层括号表示引用，dclTempD为引用，绑定到tempA*/</span><br><span class="hljs-keyword">decltype</span>((tempA)) dclTempD = tempA;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ctempA = <span class="hljs-number">1</span>, &amp;crefTempA = ctempA;<br><br><span class="hljs-comment">/*5.dclTempE为常量引用，可以绑定到普通变量tempA*/</span><br><span class="hljs-keyword">decltype</span>(crefTempA) dclTempE = tempA;<br><span class="hljs-comment">/*6.dclTempF为常量引用，可以绑定到常量ctempA*/</span><br><span class="hljs-keyword">decltype</span>(crefTempA) dclTempF = ctempA;<br><span class="hljs-comment">/*7.dclTempG为常量引用，绑定到一个临时变量*/</span><br><span class="hljs-keyword">decltype</span>(crefTempA) dclTempG = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/*8.dclTempH为常量引用，必须初始化，编译不过*/</span><br><span class="hljs-keyword">decltype</span>(crefTempA) dclTempH;<br><span class="hljs-comment">/*9.双层括号表示引用,dclTempI为常量引用，可以绑定到普通变量tempA*/</span><br><span class="hljs-keyword">decltype</span>((ctempA))  dclTempI = ctempA;<br></code></pre></td></tr></table></figure><h3 id="与指针结合"><a href="#与指针结合" class="headerlink" title="与指针结合"></a>与指针结合</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> tempA = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> *ptrTempA = &amp;tempA;<br><span class="hljs-comment">/*1.常规使用dclTempA为一个int *的指针*/</span><br><span class="hljs-keyword">decltype</span>(ptrTempA) dclTempA;<br><span class="hljs-comment">/*2.需要特别注意，表达式内容为解引用操作，dclTempB为一个引用，引用必须初始化，故编译不过*/</span><br><span class="hljs-keyword">decltype</span>(*ptrTempA) dclTempB;<br></code></pre></td></tr></table></figure><h3 id="decltype-总结"><a href="#decltype-总结" class="headerlink" title="decltype 总结"></a>decltype 总结</h3><blockquote><p>decltype和auto都可以用来推断类型，但是二者有几处明显的差异：</p><p>1.<code>auto</code><strong>忽略</strong>顶层<code>const</code>，<code>decltype</code> <strong>保留</strong>顶层 <code>const</code>；</p><p>2.对<strong>引用操作</strong>，<code>auto</code>推断出<strong>原有类型</strong>，<code>decltype</code>推断出<strong>引用</strong>；</p><p>3.对<strong>解引用操作</strong>，<code>auto</code>推断出<strong>原有类型</strong>，<code>decltype</code>推断出<strong>引用</strong>；</p><p>4.<code>auto</code>推断时会<strong>实际执行</strong>，<code>decltype</code><strong>不会执行</strong>，<strong>只做分析</strong>。</p><p>总之在使用中过程中和<code>const</code>、引用和指针结合时需要特别小心。</p></blockquote><h2 id="Lambda-与-decltype-结合"><a href="#Lambda-与-decltype-结合" class="headerlink" title="Lambda 与 decltype 结合"></a>Lambda 与 decltype 结合</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">counts</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">auto</span> cmp = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; letter1, <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; letter2) &#123;<br><span class="hljs-keyword">return</span> counts[letter1 - <span class="hljs-string">&#x27;a&#x27;</span>]  &lt; counts[letter2 - <span class="hljs-string">&#x27;a&#x27;</span>];<br>&#125;;<br>priority_queue&lt;<span class="hljs-type">char</span>, vector&lt;<span class="hljs-type">char</span>&gt;,  <span class="hljs-keyword">decltype</span>(cmp)&gt; qu&#123;cmp&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About Dynamic Programming</title>
    <link href="/1976/04/01/about%20DP/"/>
    <url>/1976/04/01/about%20DP/</url>
    
    <content type="html"><![CDATA[<h1 id="about-Dynamic-Programming-「DP-动态规划」"><a href="#about-Dynamic-Programming-「DP-动态规划」" class="headerlink" title="about Dynamic Programming 「DP&#x2F;动态规划」"></a>about Dynamic Programming 「DP&#x2F;动态规划」</h1><p>子问题最优则原始问题最优——贪心算法或者动态规划算法。<br>子问题最优则原始问题最优，且子问题互相独立——分治算法。<br>子问题最优不能推导出原始问题最优——暴力搜索等。</p><p>如果子问题最优则原问题最优，贪心算法。<br>如果子问题需要全部求解才能求解原问题，子问题互相独立，分治算法。<br>如果子问题最优不能保证原问题最优，但是子问题之间不会循环（所谓循环，是指从问题 A 拆解出子问题 B，然后子问题 B 又能拆解出子问题 A），考虑动态规划算法。<br>更加复杂的情况，我们总是可以考虑暴力搜索解决。</p><p>分治「Divide and Conquer Algorithm 」</p><p>值的注意的是 : 贪心算法在解决01背包问题的时候错误很明显 所以你最好能够证明这个题可以使用贪心算法. </p><p>分治和动态规划的思想区别本质在于: 分治的子问题毫无关联, 而动态规划则是子问题的嵌套「所以需要状态转移方程」</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划:"></a>动态规划:</h3><h3 id="在不问最优解-只问最优值的时候-可以尝试动态规划"><a href="#在不问最优解-只问最优值的时候-可以尝试动态规划" class="headerlink" title="在不问最优解 只问最优值的时候 可以尝试动态规划"></a>在不问最优解 只问最优值的时候 可以尝试动态规划</h3><ol><li><p>递归 直接基于状态转移方程来实现 </p></li><li><p>自顶向下(记忆化) 相当于是查表 「重叠子结构」</p></li><li><p>自底向上(迭代)  </p><ol><li><p>有了状态转移方程，我们就知道如何从最小的问题规模入手，然后不断地增加问题规模，直到所要求的问题规模为止。在这个过程中，我们同样地可以记忆每个问题规模的解来避免重复的计算。这种方法就是自底向上的方法，由于避免了递归，这是一种更好的办法。</p><p>但是迭代法需要有一个明确的迭代方向，例如线性，区间，树形，状态压缩等比较主流的动态规划问题中，迭代方向都有相应的模式。参考后面的例题。但是有一些问题迭代法方向是不确定的，这时可以退而求其次用记忆化来做，参考后面的例题。</p></li></ol></li></ol><h3 id="动态规划存在无后效性的原则-「状态必须是确定的」"><a href="#动态规划存在无后效性的原则-「状态必须是确定的」" class="headerlink" title="动态规划存在无后效性的原则 「状态必须是确定的」"></a>动态规划存在无后效性的原则 「状态必须是确定的」</h3><h4 id="e-g-丢n枚硬币-我们求其中k个朝上的概率是多少"><a href="#e-g-丢n枚硬币-我们求其中k个朝上的概率是多少" class="headerlink" title="e.g. 丢n枚硬币, 我们求其中k个朝上的概率是多少"></a>e.g. 丢n枚硬币, 我们求其中k个朝上的概率是多少</h4><h4 id="设立矩阵-p-i-j-其中i代表丢下第i枚硬币-j代表-其中在这次丢硬币之前有-j-枚朝上"><a href="#设立矩阵-p-i-j-其中i代表丢下第i枚硬币-j代表-其中在这次丢硬币之前有-j-枚朝上" class="headerlink" title="设立矩阵 p[i] [j] 其中i代表丢下第i枚硬币, j代表 其中在这次丢硬币之前有 j 枚朝上"></a>设立矩阵 p[i] [j] 其中i代表丢下第i枚硬币, j代表 其中在这次丢硬币<em>之前</em>有 j 枚朝上</h4><h4 id="显然-我们有这样的状态转移方程-p-i-j-p-i-1-j-1-0-5-p-i-1-j-0-5"><a href="#显然-我们有这样的状态转移方程-p-i-j-p-i-1-j-1-0-5-p-i-1-j-0-5" class="headerlink" title="显然 我们有这样的状态转移方程:  p[i] [j] &#x3D; p[i-1] [j-1] * 0.5 + p[i-1] [j] * 0.5"></a>显然 我们有这样的状态转移方程:  p[i] [j] &#x3D; p[i-1] [j-1] * 0.5 + p[i-1] [j] * 0.5</h4><h4 id="现在我们改变问题-当连续两次丢下硬币都朝着一面的时候-下一次丢硬币一定会是另一面-因为我们的状态里没有包含前两次的结果-所以显然刚才的状态方程是错误的-如果想要使用动态规划-这里应该添加两个维度-来存储上一次-和上上次的结果"><a href="#现在我们改变问题-当连续两次丢下硬币都朝着一面的时候-下一次丢硬币一定会是另一面-因为我们的状态里没有包含前两次的结果-所以显然刚才的状态方程是错误的-如果想要使用动态规划-这里应该添加两个维度-来存储上一次-和上上次的结果" class="headerlink" title="现在我们改变问题  当连续两次丢下硬币都朝着一面的时候,  下一次丢硬币一定会是另一面.  因为我们的状态里没有包含前两次的结果, 所以显然刚才的状态方程是错误的,  如果想要使用动态规划, 这里应该添加两个维度, 来存储上一次 和上上次的结果."></a>现在我们改变问题  当连续两次丢下硬币都朝着一面的时候,  下一次丢硬币一定会是另一面.  因为我们的状态里没有包含前两次的结果, 所以显然刚才的状态方程是错误的,  如果想要使用动态规划, 这里应该添加两个维度, 来存储上一次 和上上次的结果.</h4><h3 id="动态规划的最优子结构-「在设计状态的时候-我们应当保证最优的状态只从之前的最优状态来-而不是从之前的非最优状态来」"><a href="#动态规划的最优子结构-「在设计状态的时候-我们应当保证最优的状态只从之前的最优状态来-而不是从之前的非最优状态来」" class="headerlink" title="动态规划的最优子结构 「在设计状态的时候, 我们应当保证最优的状态只从之前的最优状态来, 而不是从之前的非最优状态来」"></a>动态规划的最优子结构 「在设计状态的时候, 我们应当保证最优的状态只从之前的最优状态来, 而不是从之前的非最优状态来」</h3><h4 id="比如01背包问题-如果我们加入一个条件-某两件物品一起拿能够产生额外价值-那么就不适用动态规划了"><a href="#比如01背包问题-如果我们加入一个条件-某两件物品一起拿能够产生额外价值-那么就不适用动态规划了" class="headerlink" title="比如01背包问题, 如果我们加入一个条件, 某两件物品一起拿能够产生额外价值,  那么就不适用动态规划了."></a>比如01背包问题, 如果我们加入一个条件, 某两件物品一起拿能够产生额外价值,  那么就不适用动态规划了.</h4><h3 id="重叠子结构"><a href="#重叠子结构" class="headerlink" title="重叠子结构"></a>重叠子结构</h3><p>比如在解斐波那契的时候 , 我们加入一个dp[n], 存储每一次的答案, 不需要重复计算,</p><h3 id="动态规划例题"><a href="#动态规划例题" class="headerlink" title="动态规划例题:"></a>动态规划例题:</h3><h4 id="1-编辑距离-II-在编辑距离的基础上-不允许插入操作-这意味着在A删除和在B删除是有区别的"><a href="#1-编辑距离-II-在编辑距离的基础上-不允许插入操作-这意味着在A删除和在B删除是有区别的" class="headerlink" title="1. 编辑距离 II 在编辑距离的基础上, 不允许插入操作, 这意味着在A删除和在B删除是有区别的"></a>1. 编辑距离 II 在编辑距离的基础上, 不允许插入操作, 这意味着在A删除和在B删除是有区别的</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 在A中删除一个字符 或者替换</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">edit_distance</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>(), m = t.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span> (!(n * m)) <span class="hljs-keyword">return</span> m + n;<br>        <br>        <span class="hljs-comment">// 请务必注意dp边界的初始化 请一定要注意</span><br>        <span class="hljs-type">int</span> dp[n<span class="hljs-number">+1</span>][m<span class="hljs-number">+1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) dp[<span class="hljs-number">0</span>][i] = i;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (s[i<span class="hljs-number">-1</span>] == t[j<span class="hljs-number">-1</span>]) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                <span class="hljs-comment">// 问题就在于 s的子串长度一定要超过 t 的子串长度. 否则不应删减掉</span><br>                <span class="hljs-keyword">else</span> dp[i][j] = i &gt; j ? <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j])<span class="hljs-number">+1</span> : dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];   <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-打家劫舍I-「给定一个序列-我们不能连着偷相邻的两家-求我们能获取的最大利润是多少」"><a href="#2-打家劫舍I-「给定一个序列-我们不能连着偷相邻的两家-求我们能获取的最大利润是多少」" class="headerlink" title="2. 打家劫舍I 「给定一个序列, 我们不能连着偷相邻的两家, 求我们能获取的最大利润是多少」"></a>2. 打家劫舍I 「给定一个序列, 我们不能连着偷相邻的两家, 求我们能获取的最大利润是多少」</h3><blockquote><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p></blockquote><blockquote><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p></blockquote><h4 id="思路-四种DP的方式-「无非就是从增加维度控制后效性-rightarrow-不增加维度的dp优化」"><a href="#思路-四种DP的方式-「无非就是从增加维度控制后效性-rightarrow-不增加维度的dp优化」" class="headerlink" title="思路: 四种DP的方式  「无非就是从增加维度控制后效性 $\rightarrow$ 不增加维度的dp优化」"></a>思路: 四种DP的方式  「无非就是从增加维度控制后效性 $\rightarrow$ 不增加维度的dp优化」</h4><ol><li><h5 id="2维DP-dp-i-0-代表不偷第-i-间-前i间房能获取的最大利润-dp-i-1-则是偷第i间-显然-dp-i-0-max-dp-i-1-1-dp-i-1-0-而dp-i-1-dp-i-1-0-nums-i-因为偷这一间意味着上一间肯定不能偷啦"><a href="#2维DP-dp-i-0-代表不偷第-i-间-前i间房能获取的最大利润-dp-i-1-则是偷第i间-显然-dp-i-0-max-dp-i-1-1-dp-i-1-0-而dp-i-1-dp-i-1-0-nums-i-因为偷这一间意味着上一间肯定不能偷啦" class="headerlink" title="2维DP dp[i] [0] 代表不偷第 i 间, 前i间房能获取的最大利润  dp[i] [1]则是偷第i间. 显然 dp[i] [0] &#x3D; max(dp[i-1] [1], dp[i-1] [0]), 而dp[i] [1] &#x3D; dp[i-1] [0] + nums[i] (因为偷这一间意味着上一间肯定不能偷啦 )"></a>2维DP dp[i] [0] 代表不偷第 i 间, 前i间房能获取的最大利润  dp[i] [1]则是偷第i间. 显然 dp[i] [0] &#x3D; max(dp[i-1] [1], dp[i-1] [0]), 而dp[i] [1] &#x3D; dp[i-1] [0] + nums[i] (因为偷这一间意味着上一间肯定不能偷啦 )</h5></li><li><h4 id="1维DP-法1"><a href="#1维DP-法1" class="headerlink" title="1维DP 法1"></a>1维DP 法1</h4><ul><li><em><strong>这种思路是错误的</strong></em> 「我们通过dp[i-1」和dp[i-2]是否相同来判断是否可以偷第[i]间, 但是问题就在于, 每两间房必会偷一间, 但显然, 这种方式无法每次都找到最优解.</li></ul></li><li><h4 id="1维DP-法2"><a href="#1维DP-法2" class="headerlink" title="1维DP 法2"></a>1维DP 法2</h4><ul><li><h5 id="dp-i-确实有两种情况-1-不偷-dp-i-dp-i-1-显然-上一个房间也不一定非要偷-2-偷-dp-i-dp-i-2-nums-i"><a href="#dp-i-确实有两种情况-1-不偷-dp-i-dp-i-1-显然-上一个房间也不一定非要偷-2-偷-dp-i-dp-i-2-nums-i" class="headerlink" title="dp[i] 确实有两种情况  1. 不偷 dp[i] &#x3D; dp[i-1] (显然, 上一个房间也不一定非要偷)  2. 偷 dp[i] &#x3D; dp[i-2] + nums[i];"></a>dp[i] 确实有两种情况  1. 不偷 dp[i] &#x3D; dp[i-1] (显然, 上一个房间也不一定非要偷)  2. 偷 dp[i] &#x3D; dp[i-2] + nums[i];</h5></li><li><h5 id="所以dp-i-max-dp-i-1-dp-i-2-nums-i"><a href="#所以dp-i-max-dp-i-1-dp-i-2-nums-i" class="headerlink" title="所以dp[i] &#x3D; max(dp[i-1], dp[i-2]+nums[i])"></a>所以dp[i] &#x3D; max(dp[i-1], dp[i-2]+nums[i])</h5></li></ul></li><li><h4 id="0维DP-直接上代码-两个变量相互继承-有点类似之前做过的最长湍流子数组-是吗"><a href="#0维DP-直接上代码-两个变量相互继承-有点类似之前做过的最长湍流子数组-是吗" class="headerlink" title="0维DP 直接上代码 两个变量相互继承, 有点类似之前做过的最长湍流子数组? 是吗"></a>0维DP 直接上代码 两个变量相互继承, 有点类似之前做过的最长湍流子数组? 是吗</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <br>        <span class="hljs-type">int</span> rob = nums[<span class="hljs-number">0</span>], nrob = nums[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> temp = rob;<br>            rob = <span class="hljs-built_in">max</span> (rob, nrob);<br>            nrob = temp + nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(rob, nrob);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="打家截舍II-现在第一间房屋和最后一间房屋连起来-偷第一间就不可以偷最后一间"><a href="#打家截舍II-现在第一间房屋和最后一间房屋连起来-偷第一间就不可以偷最后一间" class="headerlink" title="打家截舍II  现在第一间房屋和最后一间房屋连起来 偷第一间就不可以偷最后一间"></a>打家截舍II  现在第一间房屋和最后一间房屋连起来 偷第一间就不可以偷最后一间</h3><blockquote><p>改变区间就可以了. 如果偷第一家 就把最后一家从区间中去掉.  (根据一维dp法2来做)</p></blockquote></li></ol><h2 id="3-预测赢家-「给定一组牌-数组-我们只能从最后或者最前面拿牌-玩家1先手-我们-希望能在给定序列的情况下-提前知道玩家1是否可以赢-假设两名玩家都绝顶聪明-」"><a href="#3-预测赢家-「给定一组牌-数组-我们只能从最后或者最前面拿牌-玩家1先手-我们-希望能在给定序列的情况下-提前知道玩家1是否可以赢-假设两名玩家都绝顶聪明-」" class="headerlink" title="3. 预测赢家 「给定一组牌(数组), 我们只能从最后或者最前面拿牌, 玩家1先手, 我们 希望能在给定序列的情况下, 提前知道玩家1是否可以赢(假设两名玩家都绝顶聪明)」"></a>3. 预测赢家 「给定一组牌(数组), 我们只能从最后或者最前面拿牌, 玩家1先手, 我们 希望能在给定序列的情况下, 提前知道玩家1是否可以赢(假设两名玩家都绝顶聪明)」</h2><h3 id="此题出现了-dp-i-由-dp-i-1-和-dp-i-2-推导而来的情况-我们需要通过一个矩阵来解决这个问题-麻烦画一下-现在我懒得画了-其实比较容易"><a href="#此题出现了-dp-i-由-dp-i-1-和-dp-i-2-推导而来的情况-我们需要通过一个矩阵来解决这个问题-麻烦画一下-现在我懒得画了-其实比较容易" class="headerlink" title="此题出现了 dp[i]由 dp[i+1] 和 dp[i+2] 推导而来的情况, 我们需要通过一个矩阵来解决这个问题. 麻烦画一下 现在我懒得画了 其实比较容易."></a>此题出现了 dp[i]由 dp[i+1] 和 dp[i+2] 推导而来的情况, 我们需要通过一个矩阵来解决这个问题. 麻烦画一下 现在我懒得画了 其实比较容易.</h3><blockquote><h4 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h4><p>输入：[1, 5, 2]<br>输出：False<br>解释：一开始，玩家1可以从1和2中进行选择。<br>如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。<br>所以，玩家 1 的最终分数为 1 + 2 &#x3D; 3，而玩家 2 为 5 。<br>因此，玩家 1 永远不会成为赢家，返回 False 。</p><h4 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2"></a>示例2</h4><p>输入：[1, 5, 233, 7]<br>输出：True<br>解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。<br>     最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// dp[i][j] 表示玩家1 在牌i到牌j可以拿到的最大分数; 最终的结果是 dp[i][nums.size()-1]</span><br>    <span class="hljs-comment">// dp[i][j] = max (left, right);  left -&gt; 拿左边的, right -&gt; 拿右边的</span><br>    <span class="hljs-comment">// left = min(dp[i+1][j-1], dp[i+2][j]) + nums[i] 站在玩家2的角度上思考,他必然选择最优解, 这意味着玩家1之后将拿到的只能是最小值. </span><br>    <span class="hljs-comment">// right = min(dp[i+1][j-1], dp[i][j-2]) + nums[j];</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PredictTheWinner</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>(), sum = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) dp[i][i] = nums[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) dp[i][i<span class="hljs-number">+1</span>] = <span class="hljs-built_in">max</span>(nums[i], nums[i<span class="hljs-number">+1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">3</span>; l &lt;= n; ++l) &#123;<br>            <span class="hljs-comment">//l作为长度, 最开始至少有3三张, 我们从前3张卡开始,不断的向外扩散</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + l - <span class="hljs-number">1</span> &lt; n; ++i) &#123;<br>                <span class="hljs-type">int</span> j = i + l - <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> left = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">+1</span>][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">+2</span>][j]) + nums[i];<br>                <span class="hljs-type">int</span> right = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">+1</span>][j<span class="hljs-number">-1</span>], dp[i][j<span class="hljs-number">-2</span>]) + nums[j];<br>                dp[i][j] = <span class="hljs-built_in">max</span>(left, right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>] &gt;= sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>备注：当手牌为奇数的时候，先手必胜。</p><hr><h2 id="4-礼物的最大价值-「有的时候-我们可以直接在原数组上dp-不需要空间」"><a href="#4-礼物的最大价值-「有的时候-我们可以直接在原数组上dp-不需要空间」" class="headerlink" title="4. 礼物的最大价值 「有的时候 我们可以直接在原数组上dp, 不需要空间」"></a>4. 礼物的最大价值 「有的时候 我们可以直接在原数组上dp, 不需要空间」</h2><h4 id="剑指offer-47-在一个-m-n-的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于-0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？"><a href="#剑指offer-47-在一个-m-n-的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于-0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？" class="headerlink" title="剑指offer 47 :在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？"></a>剑指offer 47 :在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>(), n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j];</span><br>        <span class="hljs-comment">// vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n));</span><br>        <span class="hljs-comment">// // 我从左上角拿 那也意味着想要顺着边拿只能一直往下或一直往右.</span><br>        <span class="hljs-comment">// dp[0][0] = grid[0][0];</span><br>        <span class="hljs-comment">// for (int i = 1; i &lt; m; ++i) dp[i][0] = dp[i-1][0] + grid[i][0];</span><br>        <span class="hljs-comment">// for (int i = 1; i &lt; n; ++i) dp[0][i] = dp[0][i-1] + grid[0][i];</span><br>        <span class="hljs-comment">// for (int i = 1; i &lt; m; ++i) &#123;</span><br>        <span class="hljs-comment">//     for (int j = 1; j &lt; n; ++j) &#123;</span><br>        <span class="hljs-comment">//         dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j];</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// return dp[m-1][n-1];</span><br>        <br>        <span class="hljs-comment">// 我们可以直接用grid数组本身代替dp数组 以下为优化方案. </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i) grid[i][<span class="hljs-number">0</span>] += grid[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) grid[<span class="hljs-number">0</span>][i] += grid[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; ++j) grid[i][j] += <span class="hljs-built_in">max</span>(grid[i<span class="hljs-number">-1</span>][j], grid[i][j<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">return</span> grid[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About Search</title>
    <link href="/1976/04/01/about%20Search/"/>
    <url>/1976/04/01/about%20Search/</url>
    
    <content type="html"><![CDATA[<h1 id="about-Search"><a href="#about-Search" class="headerlink" title="about Search"></a>about Search</h1><h2 id="深度优先搜索「一条路走到底，不撞南墙不回头」"><a href="#深度优先搜索「一条路走到底，不撞南墙不回头」" class="headerlink" title="深度优先搜索「一条路走到底，不撞南墙不回头」"></a>深度优先搜索「一条路走到底，不撞南墙不回头」</h2><ul><li><h5 id="深度优先遍历-只要前面有可以走的路，就会一直向前走，直到无路可走才会回头；"><a href="#深度优先遍历-只要前面有可以走的路，就会一直向前走，直到无路可走才会回头；" class="headerlink" title="深度优先遍历 只要前面有可以走的路，就会一直向前走，直到无路可走才会回头；"></a>深度优先遍历 只要前面有可以走的路，就会一直向前走，直到无路可走才会回头；</h5></li><li><h4 id="「无路可走」有两种情况：①-遇到了墙；②-遇到了已经走过的路；"><a href="#「无路可走」有两种情况：①-遇到了墙；②-遇到了已经走过的路；" class="headerlink" title="「无路可走」有两种情况：① 遇到了墙；② 遇到了已经走过的路；"></a>「无路可走」有两种情况：① 遇到了墙；② 遇到了已经走过的路；</h4></li><li><p>在「无路可走」的时候，沿着原路返回，直到回到了还有未走过的路的路口，尝试继续走没有走过的路径；有一些路径没有走到，这是因为找到了出口，程序就停止了；</p></li><li><p>「深度优先遍历」也叫「深度优先搜索」，遍历是行为的描述，搜索是目的（用途）；</p></li><li><p>遍历不是很深奥的事情，把 所有 可能的情况都看一遍，才能说「找到了目标元素」或者「没找到目标元素」。遍历也称为 穷举，穷举的思想在人类看来虽然很不起眼，但借助 计算机强大的计算能力，穷举可以帮助我们解决很多专业领域知识不能解决的问题。</p></li><li><h3 id="n皇后问题「n个皇后位于nxn的棋盘-她们不可互相攻击-横-竖-斜-都不可以在一列上-」"><a href="#n皇后问题「n个皇后位于nxn的棋盘-她们不可互相攻击-横-竖-斜-都不可以在一列上-」" class="headerlink" title="n皇后问题「n个皇后位于nxn的棋盘, 她们不可互相攻击(横 竖 斜 都不可以在一列上)」"></a>n皇后问题「n个皇后位于nxn的棋盘, 她们不可互相攻击(横 竖 斜 都不可以在一列上)」</h3></li><li><h4 id="解决这个问题的思路是尝试每一种可能，然后逐个判断。只不过回溯算法按照一定的顺序进行尝试，在一定不可能得到解的时候进行剪枝，进而减少了尝试的可能。"><a href="#解决这个问题的思路是尝试每一种可能，然后逐个判断。只不过回溯算法按照一定的顺序进行尝试，在一定不可能得到解的时候进行剪枝，进而减少了尝试的可能。" class="headerlink" title="解决这个问题的思路是尝试每一种可能，然后逐个判断。只不过回溯算法按照一定的顺序进行尝试，在一定不可能得到解的时候进行剪枝，进而减少了尝试的可能。"></a>解决这个问题的思路是尝试每一种可能，然后逐个判断。只不过回溯算法按照一定的顺序进行尝试，<strong>在一定不可能得到解的时候进行剪枝</strong>，进而减少了尝试的可能。</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayDeque;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 记录某一列是否放置了皇后</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] col;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 记录主对角线上的单元格是否放置了皇后</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] main;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 记录了副对角线上的单元格是否放置了皇后</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] sub;<br>    <br>    <span class="hljs-keyword">private</span> List&lt;List&lt;String&gt;&gt; res;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-comment">// 设置成员变量，减少参数传递，具体作为方法参数还是作为成员变量，请参考团队开发规范</span><br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.col = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-built_in">this</span>.main = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">this</span>.sub = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>];<br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        dfs(<span class="hljs-number">0</span>, path);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row, Deque&lt;Integer&gt; path)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            <span class="hljs-comment">// 深度优先遍历到下标为 n，表示 [0.. n - 1] 已经填完，得到了一个结果</span><br>            List&lt;String&gt; board = convert2board(path);<br>            res.add(board);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 针对下标为 row 的每一列，尝试是否可以放置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!col[j] &amp;&amp; !main[row - j + n - <span class="hljs-number">1</span>] &amp;&amp; !sub[row + j]) &#123;<br>                path.addLast(j);<br>                col[j] = <span class="hljs-literal">true</span>;<br>                main[row - j + n - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                sub[row + j] = <span class="hljs-literal">true</span>;<br>                dfs(row + <span class="hljs-number">1</span>, path);<br>                sub[row + j] = <span class="hljs-literal">false</span>;<br>                main[row - j + n - <span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>                col[j] = <span class="hljs-literal">false</span>;<br>                path.removeLast();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">convert2board</span><span class="hljs-params">(Deque&lt;Integer&gt; path)</span> &#123;<br>        List&lt;String&gt; board = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Integer num : path) &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            row.append(<span class="hljs-string">&quot;.&quot;</span>.repeat(Math.max(<span class="hljs-number">0</span>, n)));<br>            row.replace(num, num + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Q&quot;</span>);<br>            board.add(row.toString());<br>        &#125;<br>        <span class="hljs-keyword">return</span> board;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        vis = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>);<br>        tmp = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n);<br>        <span class="hljs-comment">//从0层递归到n层 ，这里我们无需判断某一层是否有多个皇后，因为我们</span><br>        <span class="hljs-comment">//是按照层来递归，一层只有一个皇后</span><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, n);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">const</span> <span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-comment">//到达n层，存储一个可行解</span><br>        <span class="hljs-keyword">if</span>(k == n)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;string&gt;(n, <span class="hljs-built_in">string</span>(n, <span class="hljs-string">&#x27;.&#x27;</span>)));<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>                ans.<span class="hljs-built_in">back</span>()[i][tmp[i]] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>            <span class="hljs-comment">//该列已经有皇后了，不能放置</span><br>            <span class="hljs-keyword">if</span>(vis[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//第k行第i个位置放皇后</span><br>            tmp[k] = i;<br>            vis[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(k))<br>                <span class="hljs-built_in">dfs</span>(k + <span class="hljs-number">1</span>, n);<br>            vis[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//和之前已经放置过的皇后判断是否在对角线、斜对角线上</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i ++)&#123;<br>            <span class="hljs-keyword">if</span>(tmp[i] - i == tmp[k] - k || tmp[i] + i == tmp[k] + k)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//判断某一列上是否有皇后</span><br>    vector&lt;<span class="hljs-type">bool</span>&gt; vis;<br>    <span class="hljs-comment">//保存答案</span><br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    <span class="hljs-comment">//存储每一层皇后的位置</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="DFS的方向模版"><a href="#DFS的方向模版" class="headerlink" title="DFS的方向模版"></a>DFS的方向模版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> row, column;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; vis, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span>&amp; maxn)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= row || y &lt; <span class="hljs-number">0</span> || y &gt;= column || vis[x][y] || grid[x][y] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ++maxn;<br>        vis[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> dx = x + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> dy = y + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">dfs</span>(grid, vis, dx, dy, maxn);<br>        &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About Sort</title>
    <link href="/1976/04/01/about%20Sort/"/>
    <url>/1976/04/01/about%20Sort/</url>
    
    <content type="html"><![CDATA[<h1 id="about-Sort"><a href="#about-Sort" class="headerlink" title="about Sort"></a>about Sort</h1><h2 id="稳定排序-不稳定排序-「相同的元素-在排序前后-仍然处于相同顺序-rightarrow-稳定排序」"><a href="#稳定排序-不稳定排序-「相同的元素-在排序前后-仍然处于相同顺序-rightarrow-稳定排序」" class="headerlink" title="稳定排序&#x2F;不稳定排序 「相同的元素 在排序前后 仍然处于相同顺序 $\rightarrow$ 稳定排序」"></a>稳定排序&#x2F;不稳定排序 「相同的元素 在排序前后 仍然处于相同顺序 $\rightarrow$ 稳定排序」</h2><hr><ul><li><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2></li></ul><h5 id="Pivot-算法-「每次选择一个参考数-小于这个参考数的放在左边-大于它的放在右边-这个参考数当然也在合适的位置」"><a href="#Pivot-算法-「每次选择一个参考数-小于这个参考数的放在左边-大于它的放在右边-这个参考数当然也在合适的位置」" class="headerlink" title="Pivot 算法 「每次选择一个参考数 小于这个参考数的放在左边 大于它的放在右边 &#x2F;&#x2F; 这个参考数当然也在合适的位置」"></a>Pivot 算法 「每次选择一个参考数 小于这个参考数的放在左边 大于它的放在右边 &#x2F;&#x2F; 这个参考数当然也在合适的位置」</h5><h4 id="找出参考数之后-向左右部分递归调用Pivot算法-每次调用算法-会产生一个参考数-它一定会在最后正确的位置-如果参考数每次都处在中间位置-那么为O-nlogn-级别-但在最差情况下会退化到n-2"><a href="#找出参考数之后-向左右部分递归调用Pivot算法-每次调用算法-会产生一个参考数-它一定会在最后正确的位置-如果参考数每次都处在中间位置-那么为O-nlogn-级别-但在最差情况下会退化到n-2" class="headerlink" title="找出参考数之后 向左右部分递归调用Pivot算法 每次调用算法 会产生一个参考数 它一定会在最后正确的位置      如果参考数每次都处在中间位置 那么为O((nlogn))级别 但在最差情况下会退化到n^2"></a>找出参考数之后 向左右部分递归调用Pivot算法 每次调用算法 会产生一个参考数 它一定会在<em><strong>最后正确</strong></em>的位置      如果参考数每次都处在中间位置 那么为O((nlogn))级别 但在最差情况下会退化到n^2</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义 pivot 函数，他会以数组第一个数作为参考数，并会按上述规则调整数组，并返回参考数的下标</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pivot</span>(<span class="hljs-params">a</span>):<br>    <span class="hljs-comment"># 首先我们分析一下边界情况，首先如果只有一个数，这种情况下数组已经是有序的了，我们返回 -1 代表不需要再继续后面的过程。那如果是两个数的话，我们可以直接比较大小然后给出正确排序，也不需要 pivot 过程了。我们仍然返回 -1。</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a) == <span class="hljs-number">1</span>:<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a) == <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">if</span> a[<span class="hljs-number">0</span>] &gt; a[<span class="hljs-number">1</span>]:<br>            a[<span class="hljs-number">0</span>],a[<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>],a[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-comment"># 那么接下来我们就得进行我们的算法了，首先按我们刚才说的，我们假设参考数是第一个值。同时我们定义两个指针，i 指向 1，j 指向末尾。</span><br>    pivot = a[<span class="hljs-number">0</span>]<br>    i = <span class="hljs-number">1</span>; j = <span class="hljs-built_in">len</span>(a)-<span class="hljs-number">1</span><br>    <span class="hljs-comment"># 如果 i 和 j 还没重叠的话</span><br>    <span class="hljs-keyword">while</span> i &lt; j:<br>        <span class="hljs-comment"># 我们比较 a[i] 和 pivot 的大小关系，直到碰到第一个 a[i] 大于 pivot，或者 i 等于 j 就退出</span><br>        <span class="hljs-keyword">while</span> a[i] &lt; pivot <span class="hljs-keyword">and</span> i &lt; j:<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 对 a[j] 进行类似操作</span><br>        <span class="hljs-keyword">while</span> a[j] &gt; pivot <span class="hljs-keyword">and</span> i &lt; j:<br>            j -= <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 如果 i, j 重合，就可以退出了</span><br>        <span class="hljs-keyword">if</span> i == j:<span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># 交换 a[i], a[j] 继续算法</span><br>        a[i],a[j] = a[j],a[i]<br>    <span class="hljs-comment"># 最后交换 pivot</span><br>    <span class="hljs-keyword">if</span> a[i] &gt; a[<span class="hljs-number">0</span>]:<br>        a[<span class="hljs-number">0</span>],a[i-<span class="hljs-number">1</span>] = a[i-<span class="hljs-number">1</span>],a[<span class="hljs-number">0</span>]; i -=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        a[<span class="hljs-number">0</span>],a[i] = a[i],a[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> i<br><br>// 完整的快排算法 就是对其进行左右递归.  下面的是严蔚敏的快速排序算法<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = nums[low];<br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        <span class="hljs-keyword">while</span> (low &lt; high <span class="hljs-keyword">and</span> nums[high] &gt;= pivot) --high;<br>        nums[low] = nums[high];<br>        <span class="hljs-keyword">while</span> (low &lt; high <span class="hljs-keyword">and</span> nums[low] &lt;= pivot) ++low;<br>        nums[high] = nums[low];<br>    &#125;<br>    nums[low] = pivot;<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">Partition</span>(nums, low, high);<br>        <span class="hljs-built_in">QuickSort</span>(nums, low, pivot - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">QuickSort</span>(nums, pivot + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><ul><li><h2 id="基数排序-桶排序-桶排序是基数排序的特例"><a href="#基数排序-桶排序-桶排序是基数排序的特例" class="headerlink" title="基数排序(桶排序) 桶排序是基数排序的特例"></a>基数排序(桶排序) 桶排序是基数排序的特例</h2></li></ul><h3 id="桶排序-在序列里值的范围-且这个范围不算太大时使用"><a href="#桶排序-在序列里值的范围-且这个范围不算太大时使用" class="headerlink" title="桶排序  在序列里值的范围 且这个范围不算太大时使用"></a>桶排序  在序列里值的范围 且这个范围不算太大时使用</h3><p>是一种非常特殊的排序算法。在前面的课程中，我们有一道题目是要找数据流的中位数，限制是所有的数都在 1 到 100 以内。我们当时提到在这种限制下，可以将数字放到 1-100 的桶里，每个桶只记录当前数字的数量，从而将插入的复杂度从 O(n) 降低为<br>O(1)，这就是一个桶排序的思想。同样的，如果我们碰到这样的题目：</p><blockquote><h4 id="例题：有-10-万个整数，每个数范围在-0-99-之间。有若干查询，每个查询给定一个数-x，问比-x-小的数有多少。"><a href="#例题：有-10-万个整数，每个数范围在-0-99-之间。有若干查询，每个查询给定一个数-x，问比-x-小的数有多少。" class="headerlink" title="例题：有 10 万个整数，每个数范围在 [0,99] 之间。有若干查询，每个查询给定一个数 x，问比 x 小的数有多少。"></a>例题：有 10 万个整数，每个数范围在 [0,99] 之间。有若干查询，每个查询给定一个数 x，问比 x 小的数有多少。</h4><p>对于这道题目，我们可以直接把数都拿过来排序，然后对每个 x 做一个二分查找，可以解决问题。但是通过桶排序我们可以有更优的解。</p><p>我们开一个数组，大小为 100，分别代表 0 到 99 每个数有多少个。然后我们遍历所有数据，记录每个数字的数量。最后统计的时候，我们只需要计算数组中下标小于 x 的数的总和就可以了。</p><p>后面统计的部分只有 0 到 100 的循环，所以查询的时间非常短。整体复杂度的瓶颈就在于开始时预处理数据，也就是 O(n) </p></blockquote><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h4 id="我们开一个长度为10的桶-把数据按照-最后一位-放到对应的桶里-形成一个序列"><a href="#我们开一个长度为10的桶-把数据按照-最后一位-放到对应的桶里-形成一个序列" class="headerlink" title="我们开一个长度为10的桶  把数据按照&#x3D;&#x3D;最后一位&#x3D;&#x3D;放到对应的桶里 形成一个序列"></a>我们开一个长度为10的桶  把数据按照&#x3D;&#x3D;最后一位&#x3D;&#x3D;放到对应的桶里 形成一个序列</h4><h4 id="我们开一个长度为10的桶-把数据按照-倒数第二位-放到对应的桶里-⚠️-同一个桶里的元素要按照上个序列的顺序放"><a href="#我们开一个长度为10的桶-把数据按照-倒数第二位-放到对应的桶里-⚠️-同一个桶里的元素要按照上个序列的顺序放" class="headerlink" title="我们开一个长度为10的桶  把数据按照 &#x3D;&#x3D;倒数第二位&#x3D;&#x3D; 放到对应的桶里 ⚠️ 同一个桶里的元素要按照上个序列的顺序放"></a>我们开一个长度为10的桶  把数据按照 &#x3D;&#x3D;倒数第二位&#x3D;&#x3D; 放到对应的桶里 ⚠️ 同一个桶里的元素要按照上个序列的顺序放</h4><h4 id="我们开始一个长度为10的桶-把数据按照-倒数第三位-放到对应的桶里-同理"><a href="#我们开始一个长度为10的桶-把数据按照-倒数第三位-放到对应的桶里-同理" class="headerlink" title="我们开始一个长度为10的桶 把数据按照 &#x3D;&#x3D;倒数第三位&#x3D;&#x3D; 放到对应的桶里 同理"></a>我们开始一个长度为10的桶 把数据按照 &#x3D;&#x3D;倒数第三位&#x3D;&#x3D; 放到对应的桶里 同理</h4><img src="/Users/edelweiss/Library/Application Support/typora-user-images/image-20210308201415058.png" alt="image-20210308201415058" style="zoom:50%;" /><hr><ul><li><h2 id="冒泡排序-「优化-如果一轮里没有元素被交换-说明排序结束」"><a href="#冒泡排序-「优化-如果一轮里没有元素被交换-说明排序结束」" class="headerlink" title="冒泡排序 「优化 : 如果一轮里没有元素被交换 说明排序结束」"></a>冒泡排序 「优化 : 如果一轮里没有元素被交换 说明排序结束」</h2></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span><br>            arr[j + <span class="hljs-number">1</span>] = arr[j + <span class="hljs-number">1</span>] + arr[j];<br>            arr[j] = arr[j + <span class="hljs-number">1</span>] - arr[j];<br>            arr[j + <span class="hljs-number">1</span>] = arr[j + <span class="hljs-number">1</span>] - arr[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><ul><li><h2 id="选择排序-「不受输入状态影响-交换次数少-最多n次交换-」「选择排序的优化版本就是堆排序」"><a href="#选择排序-「不受输入状态影响-交换次数少-最多n次交换-」「选择排序的优化版本就是堆排序」" class="headerlink" title="选择排序 「不受输入状态影响 &amp; 交换次数少(最多n次交换)」「选择排序的优化版本就是堆排序」"></a>选择排序 「不受输入状态影响 &amp; 交换次数少(最多n次交换)」「选择排序的优化版本就是堆排序」</h2></li></ul><p>维护一个长度逐渐变长的窗口 这个窗口中的元素是已经排好序的了 每一次都把序列搜索一遍.  搜索n-1遍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> index = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span>; j &lt; n; ++j) &#123;<br>                index = nums[j] &lt; nums[index] ? j : index;<br>            &#125;<br>            <span class="hljs-built_in">swap</span> (nums[i], nums[index]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><ul><li><h3 id="插入排序-「分为-向后腾挪和交换-两种方式」"><a href="#插入排序-「分为-向后腾挪和交换-两种方式」" class="headerlink" title="插入排序 「分为 向后腾挪和交换 两种方式」"></a>插入排序 「分为 向后腾挪和交换 两种方式」</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 从第二个数开始，往前插入数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentNumber</span> <span class="hljs-operator">=</span> arr[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 寻找插入位置的过程中，不断地将比 currentNumber 大的数字向后挪</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; currentNumber &lt; arr[j]) &#123;<br>            arr[j + <span class="hljs-number">1</span>] = arr[j];<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">// 两种情况会跳出循环：1. 遇到一个小于或等于 currentNumber 的数字，跳出循环，currentNumber 就坐到它后面。</span><br>        <span class="hljs-comment">// 2. 已经走到数列头部，仍然没有遇到小于或等于 currentNumber 的数字，也会跳出循环，此时 j 等于 -1，currentNumber 就坐到数列头部。</span><br>        arr[j + <span class="hljs-number">1</span>] = currentNumber;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 这种采取了交换的方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 从第二个数开始，往前插入数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-comment">// j 记录当前数字下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-comment">// 当前数字比前一个数字小，则将当前数字与前一个数字交换</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">1</span> &amp;&amp; arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>            arr[j] = arr[j - <span class="hljs-number">1</span>];<br>            arr[j - <span class="hljs-number">1</span>] = temp;<br>            <span class="hljs-comment">// 更新当前数字下标</span><br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux &amp; Mac terminal</title>
    <link href="/1976/04/01/linux%20&amp;%20mac%20terminal/"/>
    <url>/1976/04/01/linux%20&amp;%20mac%20terminal/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux-basic-command"><a href="#Linux-basic-command" class="headerlink" title="Linux basic command"></a>Linux basic command</h2><p><a href="https://www.runoob.com/linux/linux-command-manual.html">command repo</a></p><h3 id="普通命令"><a href="#普通命令" class="headerlink" title="普通命令"></a>普通命令</h3><ul><li><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4></li></ul><blockquote><p>cd ..&#x2F;.. 直接回到根目录，对应在finder中使用 ⇧+⌘+h</p></blockquote><ul><li><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4></li></ul><blockquote><p>ls -al &#x3D;&#x3D; ls -la</p><p>ls -l &#x3D;&#x3D;  limit</p><p>ls -a 看全部的</p><p>ls -l 看权限 (可以查看某一个文件的权限 :  ls -l myfile)</p><h4 id="左到右-一共十位-构成是-type-｜-rwx-｜-rwx-｜-rwx"><a href="#左到右-一共十位-构成是-type-｜-rwx-｜-rwx-｜-rwx" class="headerlink" title="左到右 一共十位 构成是 type ｜  rwx ｜ rwx ｜ rwx"></a>左到右 一共十位 构成是 type ｜  rwx ｜ rwx ｜ rwx</h4><p>type： p、d、l、s、c、b和-</p><ul><li>p表示命名管道文件 </li><li>d表示目录文件 </li><li>l表示符号连接文件 </li><li>-表示普通文件    &#x2F;&#x2F;myfile作为一个txt文件 属于普通文件</li><li>s表示socket文件 </li><li>c表示字符设备文件 </li><li>b表示块设备文件</li></ul><h4 id="剩下9位-每3位一组-分别表示文件所有者的权限，同组用户的权限，其他用户的权限"><a href="#剩下9位-每3位一组-分别表示文件所有者的权限，同组用户的权限，其他用户的权限" class="headerlink" title="剩下9位 每3位一组      分别表示文件所有者的权限，同组用户的权限，其他用户的权限"></a>剩下9位 每3位一组      分别表示文件所有者的权限，同组用户的权限，其他用户的权限</h4><p>⚠️ 首先描述的是所有者的权限 而不是根用户的权限</p><ul><li>r表示可读，可以读出文件的内容</li><li>w表示可写，可以修改文件的内容</li><li>&#x3D;&#x3D;x表示可执行，可运行这个程序  &#x2F;&#x2F; execute&#x3D;&#x3D; </li><li>没有权限的位置用-表示 「所有者 是否可读、可写、可执行｜同组用户是否可读…」</li></ul><h4 id="作为分割，-之后则是文件的其他属性"><a href="#作为分割，-之后则是文件的其他属性" class="headerlink" title=".作为分割， 之后则是文件的其他属性"></a>.作为分割， 之后则是文件的其他属性</h4><ul><li>1 $\Rightarrow$ 有一个硬连接</li><li>root $\Rightarrow$ <strong>所属用户</strong> ｜  之后的 root $\Rightarrow$ <strong>用户所属的组</strong></li><li>0 $\Rightarrow$ <strong>文件字节数</strong></li><li>时间 $\Rightarrow$ <strong>最后修改时间</strong></li></ul></blockquote><ul><li><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><ul><li>rmdir 删除目录</li></ul></li><li><h4 id="pwd-显示路径-「print-working-directory」"><a href="#pwd-显示路径-「print-working-directory」" class="headerlink" title="pwd 显示路径 「print working directory」"></a>pwd 显示路径 「print working directory」</h4></li><li><h4 id="cat-显示文件-文件连接"><a href="#cat-显示文件-文件连接" class="headerlink" title="cat 显示文件 + 文件连接"></a>cat 显示文件 + 文件连接</h4><ul><li>cat -n 显示行号</li></ul></li></ul><blockquote><p>cat textA &gt; textB 我们把A中的内容给拿到B里了，但B里的内容会被overwrite</p><p>cat testA &gt;&gt; textB 这次则是追加</p></blockquote><ul><li><h4 id="touch-文件存在-修改时间戳｜文件不存在-创建文件"><a href="#touch-文件存在-修改时间戳｜文件不存在-创建文件" class="headerlink" title="touch 文件存在&#x3D;&gt;修改时间戳｜文件不存在&#x3D;&gt;创建文件"></a>touch 文件存在&#x3D;&gt;修改时间戳｜文件不存在&#x3D;&gt;创建文件</h4></li><li><h4 id="echo-显示一行的内容"><a href="#echo-显示一行的内容" class="headerlink" title="echo 显示一行的内容"></a>echo 显示一行的内容</h4></li><li><h4 id="rm-删除文件"><a href="#rm-删除文件" class="headerlink" title="rm 删除文件"></a>rm 删除文件</h4><ul><li>rm -rf (r $\Rightarrow$ recursive ｜ f $\Rightarrow$  force)  可以删除目录 子目录和其中的文件一起全部删除</li></ul></li><li><h4 id="mv-移动文件-也可以改名"><a href="#mv-移动文件-也可以改名" class="headerlink" title="mv 移动文件 也可以改名"></a>mv 移动文件 也可以改名</h4></li></ul><blockquote><ol><li>文件 $\Rightarrow$ 文件 改名字</li><li>文件 $\Rightarrow$ 目录 移动到目录中(⚠️工作目录)</li><li>目录 $\Rightarrow$ 目录 ｜ 如果后面的目录存在，就移动到这个目录下｜如果不存在就改目录名</li><li>目录 $\Rightarrow$ 文件 报错</li></ol></blockquote><ul><li><h4 id="cp-文件和目录复制"><a href="#cp-文件和目录复制" class="headerlink" title="cp 文件和目录复制"></a>cp 文件和目录复制</h4></li></ul><blockquote><p>语法： cp[options] source dest</p><p>-r 复制目录时的参数 可以把目录下所有的文件都复制。 ⚠️ 如果不加这个参数 目录的复制会直接跳过</p></blockquote><ul><li><h4 id="more-less"><a href="#more-less" class="headerlink" title="more &amp; less"></a>more &amp; less</h4></li><li><h4 id="grep-文本字符串过滤"><a href="#grep-文本字符串过滤" class="headerlink" title="grep 文本字符串过滤"></a>grep 文本字符串过滤</h4></li><li><h4 id="wc-文本内容信息统计"><a href="#wc-文本内容信息统计" class="headerlink" title="wc 文本内容信息统计"></a>wc 文本内容信息统计</h4></li><li><h4 id="file-可以测试文件类型"><a href="#file-可以测试文件类型" class="headerlink" title="file 可以测试文件类型"></a>file 可以测试文件类型</h4></li></ul><hr><h3 id="su-sudo"><a href="#su-sudo" class="headerlink" title="su &amp; sudo"></a>su &amp; sudo</h3><ul><li>su是直接切换成超级用户  su- &#x2F; su + 用户名 可以拿来登陆</li><li>使用sudo命令时不需要知道超级用户的口令 使用的是自己的口令</li></ul><h3 id="用户-组"><a href="#用户-组" class="headerlink" title="用户&amp;组"></a>用户&amp;组</h3><ul><li>linux中有三种权限不同的用户： <strong>超级用户 root</strong> ｜ <strong>伪用户</strong>(不能直接登陆系统) ｜ <strong>普通用户</strong>(可以登陆 但只可以管理自己的目录)</li><li>伪用户存在的意义：在使用特殊服务时 我们会自己以伪用户登陆(比如匿名访问ftp客户端 使用ftp客户)</li><li>而 <code>组</code> 是用户的集合 <em><strong>用户被加入组来获得额外的存取权限</strong></em>，因为组中所有的用户都可以共享属于该组的文件。 以下介绍 <code>私有组</code> 和<code>主组</code>的概念</li><li>在linux中 如果创建用户时没有制定他所属的组，那么系统将会<strong>建立一个和用户同名的私有组</strong>，这个<strong>私有组里只有这个用户</strong>「这样在这个新用户中创建的文件不会在公共组中被查到」(私有组都只有一个用户)</li><li>在linux中 <strong>用户可以同时属于多个组 但只能在一个主组中</strong>(在创建用户时 指定一个标准组 那这个用户就属于这个标准组，否则它自己的私有组就是自己的主组)</li></ul><h4 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h4><p>users 查看可登陆用户</p><ul><li>useradd [-options] username<ul><li>-d 指定这个用户的主目录 缺省时会在&#x2F;home创建</li><li>-g 指定新建用户所在主组名称 缺省时创建和用户名相同的组</li><li>-G 指定新建用户所在附加组名称 系统会在这之后创建和用户名相同的组作为新建用户的主组</li></ul></li><li>usermod 属性修改 (不能修改正在线上的用户的名称、不能修改正在系统上执行程序的用户ID)<ul><li>-c comment 账户注释</li><li>-d home_dir 设置用户主目录</li><li>-e expiredate 设置过期日期</li><li><strong>-u uid 修改用户ID     格式：usermod -u NATSU natsumi     &#x2F;&#x2F;把natsumi改成NATSU</strong></li><li><strong>-l login 修改用户名  格式：usermod -l NAT natsumi &#x2F;&#x2F; 把natsumi改成NATSU</strong></li><li><strong>-g group 强制修改用户的新主组</strong> ｜ -G groups 修改附加组列表<ul><li>比如： usermod -g groupf natsumi     &#x2F;&#x2F;把natsumi加入到groupf组里 (主组)</li><li><strong>usermod -aG sudo natsumi 把组sudo添加到natsumi的附加组列表 这样natsumi可以执行sudo命令</strong>    -G是不行的</li></ul></li><li>-L &#x2F; -U   锁定、解锁用户账户</li><li>-s shell 设置登录后的shell</li></ul></li><li>userdel<ul><li>-f 强制删除 (现在正登陆的用户也可以删除)</li><li>-r 递归删除 会同时删除用户的主目录</li></ul></li></ul><h4 id="组管理命令-groups-username-查看用户加入的组"><a href="#组管理命令-groups-username-查看用户加入的组" class="headerlink" title="组管理命令 groups [username] 查看用户加入的组"></a>组管理命令 groups [username] 查看用户加入的组</h4><ul><li>groupadd<ul><li>-g 可以指定新建组的ID</li></ul></li><li>groupmod 属性修改<ul><li>-n 修改组名 和修改名字一样 是先输改动之后的名字 后输改动之前的名字</li></ul></li><li>groupdel ⚠️ 如果组里有用户 需要先删除用户 再删除这个组</li><li>gpasswd<ul><li>-a [username] [groupname] 添加一个成员到组内</li><li>-d [username] [groupname] 从组内删除一个成员</li><li>-M [usernames] [groupname] 设置成员列表</li><li>-A [usernames] [groupname] 设置组的管理员列表</li><li>-r 删除组的密码</li><li>newgrp 切换用户当前的主组(这个切换需要输入密码 并且是暂时的)</li></ul></li></ul><h4 id="用户密码管理-passwd"><a href="#用户密码管理-passwd" class="headerlink" title="用户密码管理 passwd"></a>用户密码管理 passwd</h4><ul><li>普通用户根据原密码修改自己的密码 而<strong>超级用户可以重置包括root在内的所有用户密码</strong></li><li>passwd [-options] [username]</li><li>-d delete 删除密码</li><li>-l lock 锁定账户</li><li>-u unlock 解锁账户</li><li>-S status 显示状态信息</li></ul><h4 id="与用户管理相关的文件有"><a href="#与用户管理相关的文件有" class="headerlink" title="与用户管理相关的文件有"></a>与用户管理相关的文件有</h4><ul><li><h4 id="–-etc-passwd-用户名和-UID-保存在此"><a href="#–-etc-passwd-用户名和-UID-保存在此" class="headerlink" title="–&#x2F;etc&#x2F;passwd 用户名和 UID 保存在此"></a>–&#x2F;etc&#x2F;passwd 用户名和 UID 保存在此</h4><ul><li>如图 UID &lt; 1000的 是系统用户(伪用户) &#x2F;sbin&#x2F;nologin</li><li>超级用户 UID &#x3D; 0， GID &#x3D; 0</li></ul></li><li><h4 id="–-etc-shadow-用户口令-密码"><a href="#–-etc-shadow-用户口令-密码" class="headerlink" title="–&#x2F;etc&#x2F;shadow 用户口令(密码)"></a>–&#x2F;etc&#x2F;shadow 用户口令(密码)</h4><ul><li>使用<code>:</code>作为分隔符 共有9个字段</li><li>用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的宽限时间：账号失效时间：保留字段</li></ul></li><li><p>–&#x2F;etc&#x2F;group 组和GID</p></li><li><p>–&#x2F;etc&#x2F;gshadow 组口令被保存在</p></li><li><p>–&#x2F;etc&#x2F;login.defs 相关配置参数</p></li><li><p>–&#x2F;etc&#x2F;default&#x2F;useradd</p></li></ul><h4 id="成批生成用户"><a href="#成批生成用户" class="headerlink" title="成批生成用户"></a>成批生成用户</h4><p>newusers [filename]    filename 的格式要和 &#x2F;etc&#x2F;passwd 一样才行 利用filename文件生成</p><h4 id="成批创建密码"><a href="#成批创建密码" class="headerlink" title="成批创建密码"></a>成批创建密码</h4><p>chpasswd [filename] filename 每行都应为如下格式： username:passwd </p><p>我们还可以使用pwgen命令 它可以批量生成口令</p><hr><h4 id="linux文件系统-在linux中不同分区构成一颗唯一的目录树"><a href="#linux文件系统-在linux中不同分区构成一颗唯一的目录树" class="headerlink" title="linux文件系统  在linux中不同分区构成一颗唯一的目录树"></a>linux文件系统  在linux中不同分区构成一颗唯一的目录树</h4><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><ul><li>普通文件<ul><li>文本文件 行是其基本结构</li><li>数据文件 (电子表格 数据库)</li><li>可执行二进制文件</li></ul></li><li>目录文件  就是目录 它也是一种文件 存储一组相关文件的位置、大小等与文件有关的信息</li><li>符号连接文件 指向同一索引文件 使用ls查看时 以字母l开头  -&gt; 指向链接的文件</li><li>设备文件  外设在linux中也被看作文件 它们被放在&#x2F;dev 目录中<ul><li>&#x2F;dev&#x2F;fd0 $\Rightarrow$ 软盘   |    &#x2F;dev&#x2F;hda $\Rightarrow$ 硬盘</li><li></li></ul></li></ul><p><code>隐藏文件</code> ：以 .  开头   使用ls不显示</p><ul><li>&#x2F;bin Binaries 存放二进制命令 | &#x2F;usr 存放普通用户的应用程序、库文件、文档 ｜ &#x2F;lib Libraries</li><li>&#x2F;dev Device 设备目录(disk screen)</li><li>&#x2F;etc  系统配置文件</li><li>&#x2F;sys System 系统信息 ｜ &#x2F;tmp Temporary files 临时文件 ｜ &#x2F;var Variable files 属性经常变化的文件(文件大小、时间、内容经常变化)</li></ul><h4 id="文件名通配符-这个很好用"><a href="#文件名通配符-这个很好用" class="headerlink" title="文件名通配符 这个很好用"></a>文件名通配符 这个很好用</h4><ul><li><em>号 file * 可以匹配0个和任意多个字符    如file123、fileac     「rm file</em>  这几个文件全都被删除」</li><li>？号 只和一个字符匹配 file? $\Rightarrow$ file1    但不可以实现file? $\Rightarrow$ file23</li><li>[]号 和方括号中的 一个字符匹配(但可以同时输入多个字符) 加入!后的是excluded<ul><li>file[1-4] $\Rightarrow$ file1 .2 .3 .4     &#x2F;&#x2F;</li><li>file[!1234] $\rightarrow$ file 1,2,3,4 之外的其他所有</li></ul></li></ul><h5 id="ln-file1-file2-让file1和file2-建立硬链接-｜-ln-s-file1-file2-则是建立软链接"><a href="#ln-file1-file2-让file1和file2-建立硬链接-｜-ln-s-file1-file2-则是建立软链接" class="headerlink" title="ln file1 file2  让file1和file2 建立硬链接  ｜  ln -s file1 file2 则是建立软链接"></a>ln file1 file2  让file1和file2 建立硬链接  ｜  ln -s file1 file2 则是建立软链接</h5><p>硬连接： file1 和 file2同时指向某个储存空间 (删除file1 对 file2没有影响)</p><p>软链接： file2指向file1 而file1才指向一个存储空间   所以file1如果被删除了file2就废了</p><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>root用户(超级用户)享有最高权力 它可以修改&#x2F;etc&#x2F;shadow 账户管理的文件</p><p>rwx 在list命令中已经讲解过  但&#x3D;&#x3D;<em><strong>值得注意的是 在管理目录文件时 x 是指进入目录(使用cd命令)这也是rw命令的基础 没有x命令权限 也不能进行rw</strong></em>&#x3D;&#x3D;  ⚠️ 在只有x权限时 不可以删除文件 也不能列举出文件夹所有文件 比如知道文件名才能访问</p><p>在目录中 w权限是最高权限</p><ul><li><h4 id="chown-change-owner-改变文件-目录的所有者-⚠️只有root用户才可以改变文件所有者-文件的所有者可以改变文件所属的组"><a href="#chown-change-owner-改变文件-目录的所有者-⚠️只有root用户才可以改变文件所有者-文件的所有者可以改变文件所属的组" class="headerlink" title="chown [change owner]改变文件&#x2F;目录的所有者    ⚠️只有root用户才可以改变文件所有者(文件的所有者可以改变文件所属的组)"></a>chown [change owner]改变文件&#x2F;目录的所有者    ⚠️只有root用户才可以改变文件所有者(文件的所有者可以改变文件所属的组)</h4><ul><li><strong>chown natsumi  file1  &#x2F;&#x2F;把file1 的主人换成natsumi</strong></li><li>-R recursive 只适用于目录 ｜ -v verbose 为处理的所有文件显示诊断信息 显示chown命令所做的工作</li><li>chown -R natsumi:group1 &#x2F;tmp &#x2F;&#x2F;把&#x2F;tmp 目录的主人变成 matsuri 和 组 group1</li></ul></li><li><h4 id="chgrp-改变文件-目录所属的组"><a href="#chgrp-改变文件-目录所属的组" class="headerlink" title="chgrp 改变文件&#x2F;目录所属的组"></a>chgrp 改变文件&#x2F;目录所属的组</h4></li><li><h4 id="chmod-改变文件-目录的权限-同样支持-R-v"><a href="#chmod-改变文件-目录的权限-同样支持-R-v" class="headerlink" title="chmod 改变文件&#x2F;目录的权限 同样支持 -R &#x2F; -v"></a>chmod 改变文件&#x2F;目录的权限 同样支持 -R &#x2F; -v</h4><ul><li><strong>linux 不允许用户在创建一个普通文件时 就赋予其可执行权限 必须使用chmod修改</strong></li><li>chmod [who] [+|-|&#x3D;] [permission] [filename]<ul><li>+&#x2F;- 添加或减少某权限</li><li>&#x3D; 直接赋予某权限 但取消其他所有权限</li></ul></li><li>u 主人  g 同组  o 其他  a 所有   (权限有3组 user ｜ 同组 ｜ 其他人)  (这个放在 who 一栏 不需要-)</li><li><strong>chmod a+x file1   &#x2F;&#x2F; 使所有用户都可以执行file1文件</strong></li></ul></li><li><h4 id="umask-设置文件的缺省生成掩码-「umash规定-不允许-的权限」"><a href="#umask-设置文件的缺省生成掩码-「umash规定-不允许-的权限」" class="headerlink" title="umask 设置文件的缺省生成掩码   「umash规定 不允许 的权限」"></a>umask 设置文件的缺省生成掩码   「umash规定 <strong>不允许</strong> 的权限」</h4><ul><li>文件权限的二进制写法： rwx    用0&#x2F;1  3个二进制表示    然后转十进制数   一共3组</li><li>缺省状态下 文件的默认权限为 0666(所有人具有读写权限 但无法执行)  文件夹则为0777「⚠️ 这是缺省时的权限 不是缺省时的mask」</li><li>大多数情况下 root默认mask 0022   普通用户则是 0002    实际权限 &#x3D; 缺省权限-mask</li><li>那么实际上的权限就是 root：文件 0644   文件夹0755 ｜ 普通：文件 0664  文件夹 0775</li></ul></li></ul><h3 id="FACL-ACL-「File-Access-Control-Lists」"><a href="#FACL-ACL-「File-Access-Control-Lists」" class="headerlink" title="FACL(ACL) 「File Access Control Lists」"></a>FACL(ACL) 「File Access Control Lists」</h3><p>如果要细化规定 组内的每个成员具有的不同的权限时 就需要用到ACL权限</p><ul><li><p>getfacl [file&#x2F;dir]</p></li><li><p>setfacl </p><ul><li><p>-R  recursive|  -m 修改ACL ｜ -x 删除ACL ｜ -r 要设置的ACL规则</p><p>setfacl -x u:st &#x2F;project   删除用户的ACL权限</p><p>setfacl -b project&#x2F;       删除目录上所有的ACL权限</p></li></ul></li></ul><p>默认的ACL权限只对目录有效</p><p>设置默认facl后该目录下新建立的文件和目录都会自动用于ACL权力</p><p>setfacl -m d:u:用户名:权限 文件名    更改默认facl</p><p>setfacl -R-m u:用户名:权限 文件名   只有已经创建的文件会被更改文件权限 其他的则不会</p><h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><ul><li>可执行文件<ul><li>SUID   使用命令的所属者的权限来运行 (而不是命令执行者的权限)   ⚠️ 只对二进制可执行文件生效   <ul><li>占用<strong>文件主人的x位  变为s</strong>    如修改普通用户修改密码 虽然只有root用户可以访问和修改 但由于s位 普通的用户也可以访问&#x2F;etc&#x2F;shadow    「可以访问 但是cat读取不了！」</li></ul></li><li>SGID   使用命令的组权限来运行  <strong>占用组的x位 变为 s</strong></li></ul></li><li>目录的特殊权限<ul><li>SGID 设置该权限的目录中创建的文件 会具有该目录的组权限</li><li>Sticky-bit 带有粘滞位的目录中的文件只能被文件的所属用户和root用户删除(无视权限设置)<ul><li><strong>占用 other的x位 变为 t</strong></li></ul></li></ul></li></ul><hr><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>查看分区情况：</p><p>•fdisk -l</p><p>•df -lh</p><p>•lsblk</p><p>•blkid</p><p>mkfs</p><p>lsblk</p><p>fdisk &#x2F;dev&#x2F;sdc</p><p>+5G</p><hr><h3 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h3><ul><li><p>强退 q!              &#x2F;&#x2F;⚠️ !+cmd $\Rightarrow$ 回到SHELL</p></li><li><p>重做 $\Rightarrow$ ⌃ + r </p></li><li><p>u $\Rightarrow$ undo</p></li><li><p>：下</p><ul><li>set nu   加入行号</li><li>set nonu 不要行</li><li>syntax on: 开启语法高亮</li><li>:set number: 显示行号</li><li>:set tabstop&#x3D;4: 设置 Tab 键宽度</li><li>:set expandtab: 使用空格替代 Tab</li><li>:set softtabstop&#x3D;4: 设置软件 Tab (自动Tab)宽度为 4</li><li>:set shiftwidth&#x3D;4: 设置自动缩进宽度为 4</li><li>:set autoindent: 开启自动缩进，通常用于编写程序</li><li>:set textwidth&#x3D;20设置行的宽度</li><li>:set wrap 设置自动换行</li></ul></li></ul><h3 id="管道与重定向"><a href="#管道与重定向" class="headerlink" title="管道与重定向"></a>管道与重定向</h3><p>管道：将前面命令的结果 作为下一个命令的输入来执行    |</p><ul><li><h4 id="echo-平常会使用””-转义字符-在之前加上-就可以正常输出了"><a href="#echo-平常会使用””-转义字符-在之前加上-就可以正常输出了" class="headerlink" title="echo    平常会使用””   转义字符 在之前加上\  就可以正常输出了"></a>echo    平常会使用””   转义字符 在之前加上\  就可以正常输出了</h4></li><li><h4 id="tr-c-d-s-“string1”-“string2”-input-file"><a href="#tr-c-d-s-“string1”-“string2”-input-file" class="headerlink" title="tr -c -d -s [“string1”] [“string2”] &lt; input-file"></a>tr -c -d -s [“string1”] [“string2”] &lt; input-file</h4><ul><li>-c 没有出现在字符串1中的 字母    将被替换为字符串2中的 最后一个字母(ASCII字符才可以)</li><li>-d 删除字符串1中出现了点所有输入字符</li><li>-s 如果没有string2 将string1字符去重    如裹有string2 去重之后再用string2替换1</li><li>input-file 是转换之后的文件名</li></ul></li></ul><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><ul><li>ps   process status  静态查看当前的进程<ul><li>输出 PID  TTY(终端) 运行时间  ⌘(产生该进行的命令)</li><li>ps -l  获取PID</li></ul></li><li>top  动态 3s刷新<ul><li>P $\Rightarrow$ CPU使用率排序</li><li>M $\Rightarrow$ 内存使用率排序</li><li>N $\Rightarrow$ PID排序</li><li>q 退出top</li></ul></li><li>pstree</li></ul><h4 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h4><ul><li>kill   这个命令向进程发送信号 而不是直接杀死进程<ul><li>kill -[sign] PID  &#x2F;&#x2F;  kill -1 2246   让2246进程重启  ⚠️ - 不能去 所以 1 实际上是-1<ul><li>1 立即关闭进程然后重启</li><li>2 终止前台进程</li><li><strong>9 强制终止</strong></li><li>15 优雅的退出(程序可以自己选择 退还是不退)</li><li>18 唤醒暂停的进程</li><li>19 暂停前台进程 &#x3D;&#x3D; ctrl+z</li></ul></li></ul></li><li>killall</li><li>pkill  利用进程名称杀死进程 可以杀死终端</li></ul><p>进程有其ProcessID 「PID」</p><p>还有4种识别号：</p><ul><li>real user ID 「RUID」 ｜ real group ID 「RGID」 $\Rightarrow$ 识别正在运行此进程的用户和组<ul><li>一个进程的RUID和RGID就是运行此进程的UID &#x2F; GID</li></ul></li><li>effect user ID 「EUID」｜ effect group ID 「EGID」$\Rightarrow$ 确定一个进程对其访问的文件的权限<ul><li>如果SetUID&#x2F;SetGID 没有被设置 那么它们</li></ul></li></ul><h4 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h4><p>优先级为 -20 - 19  共40级  数字越大 优先级越低 默认时为0</p><ul><li>nice -n 5 top  top命令来到优先级5   &#x2F;&#x2F; 需要在运行命令前调整！</li><li>renice  &#x2F;&#x2F;可以调整正在运行的命令  分为 在top内调整 和 直接renice两种<ul><li>打开top命令 tpye  <code>r</code> 输入调整进程号和优先级值</li><li>10 18625   将PID为18625的进程优先级调整为10   ⚠️ centos 先输入PID 然后调进程</li><li>renice +10 -u natsumi        &#x2F;&#x2F;这时不在top里 直接输就行</li></ul></li></ul><h4 id="进程调度-只能有一个前台进程-在不执行任何前台操作时-这个进程就是SHELL"><a href="#进程调度-只能有一个前台进程-在不执行任何前台操作时-这个进程就是SHELL" class="headerlink" title="进程调度   只能有一个前台进程 在不执行任何前台操作时 这个进程就是SHELL"></a>进程调度   只能有一个前台进程 在不执行任何前台操作时 这个进程就是SHELL</h4><p>通过<code>jobs</code> 查看后台的命令   「只能看自己终端的」  jobs -l  显示PID</p><ul><li><p>-&amp; 调入后台   sleep 10000 &amp;     &#x2F;&#x2F;如果是需要交互的命令 放入后台也无法执行</p><ul><li>find &#x2F; -name install.log &amp;</li><li>执行命令时 ⌃+z 也可以放入后台</li></ul></li><li><p>fg %工作号 $\Rightarrow$ 把暂停的工作恢复到前台(⚠️不是PID 是工作号)</p></li><li><p>bg%工作号 $\Rightarrow$ 把暂停的工作恢复到后台</p></li><li><p>-at</p><ul><li>atq 查看没有执行的工作任务</li><li>atrm 删除已经设置的任务</li><li>at -c [jobnumber]</li></ul></li><li><p>-batch</p></li><li><p>-cron</p></li></ul><hr><h2 id="About-mac-terminal"><a href="#About-mac-terminal" class="headerlink" title="About mac terminal"></a>About mac terminal</h2><ul><li>ohmyzsh自动补全<ul><li><code>git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</code></li><li>open ~&#x2F;.zshrc 在这个文件里修改 <code>plugins=(git)</code>&#x3D;&gt;<code>plugins=(git zsh-autosuggestions)</code></li></ul></li><li>cd ~&#x2F;.oh-my-zsh&#x2F;themes &amp;&amp; ls   查看当前主题</li></ul><p><a href="http://lzqlearn.com/blog/e7beb15ab2ea/">MAC中的冷门问题</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Computation tech</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCV 视觉编程</title>
    <link href="/1976/04/01/opencv%20%E8%A7%86%E8%A7%89%E7%BC%96%E7%A8%8B/"/>
    <url>/1976/04/01/opencv%20%E8%A7%86%E8%A7%89%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><a href="http://c.biancheng.net/view/1091.html">opencv基本信息</a>，<a href="https://blog.csdn.net/LOVEmy134611/article/details/119489496?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164880826916781683965243%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164880826916781683965243&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-119489496.142%5Ev5%5Epc_search_result_control_group,157%5Ev4%5Econtrol&utm_term=OpenCV&spm=1018.2226.3001.4187">opencv 实战</a></p><p><a href="https://www.mementos.top/2022/04/01/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%88%9D%E6%AD%A5">图像处理的基础</a></p><hr><h2 id="Chapter0-注意事项"><a href="#Chapter0-注意事项" class="headerlink" title="Chapter0 注意事项"></a>Chapter0 注意事项</h2><ul><li><p>opencv的图像是 先宽度 再高度，这点是与numpy不同的</p><ul><li>img.shape[0:2] # 0可省略，返回图像的宽和高(长和宽)</li><li>img.shape[0:3] # 包括通道数一起返回，要3个参数接收</li></ul></li><li><p>imread 的图像路径如果包含中文会有bug(可能是win特供, 在ubuntu下可以)，因此可以使用imdecode 来代替</p></li><li><p>resize 要慎用，因为插值的方法不一定能保证图片前后像素的一致性(除非等倍放缩)</p></li></ul><h2 id="图像裁剪「👷‍♀️中」https-blog-csdn-net-hfutdog-article-details-82351549"><a href="#图像裁剪「👷‍♀️中」https-blog-csdn-net-hfutdog-article-details-82351549" class="headerlink" title="图像裁剪「👷‍♀️中」https://blog.csdn.net/hfutdog/article/details/82351549"></a>图像裁剪「👷‍♀️中」<a href="https://blog.csdn.net/hfutdog/article/details/82351549">https://blog.csdn.net/hfutdog/article/details/82351549</a></h2><h2 id="Chapter1-基本图像操作"><a href="#Chapter1-基本图像操作" class="headerlink" title="Chapter1 基本图像操作"></a>Chapter1 基本图像操作</h2><h3 id="1-1-图像的基本I-O操作"><a href="#1-1-图像的基本I-O操作" class="headerlink" title="1.1 图像的基本I&#x2F;O操作"></a>1.1 图像的基本I&#x2F;O操作</h3><ul><li>注意waitKey() 有返回值，其值是16位int形式的ASCII码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python3">import cv2<br>import numpy as np<br><br># 这是一个展示图片的函数，之后都会调用它来精简代码。 &#123;name&#125; 中填图片路径即可<br>def cv_show(name):<br>    img = cv2.imread(name) # 读入是可以添加其他选项的<br>    while True:<br>        cv2.imshow(name, img)<br>        key = cv2.waitKey(10)<br>        if key &amp; 0xFF == ord(&quot;q&quot;):<br>            break<br><br># 生成窗口的函数<br>cv2.namedWindow(&quot;video&quot;, cv2.WINDOW_NORMAL)<br>cv2.resizeWindow(&quot;video&quot;, 640, 800)<br><br><br>cv_show(&quot;niya.png&quot;)  # 直接填图片路径<br></code></pre></td></tr></table></figure><hr><h3 id="1-2-视频I-O"><a href="#1-2-视频I-O" class="headerlink" title="1.2  视频I&#x2F;O"></a>1.2  视频I&#x2F;O</h3><h4 id="1-2-1视频-调用摄像头来输入"><a href="#1-2-1视频-调用摄像头来输入" class="headerlink" title="1.2.1视频(调用摄像头来输入)"></a>1.2.1视频(调用摄像头来输入)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python3"># 摄像头输入<br>cap = cv2.VideoCapture(0)  # 默认为摄像头0<br>while cap.isOpened():<br>    ret, frame = cap.read()  <br>    if not ret:  #没捕捉到画面，就离开<br>        break<br>    cv_show(&#x27;video&#x27;, frame) #对每一帧调用cv_show <br>cap.release()<br></code></pre></td></tr></table></figure><hr><h4 id="1-2-2将鼠标引入"><a href="#1-2-2将鼠标引入" class="headerlink" title="1.2.2将鼠标引入"></a>1.2.2将鼠标引入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python3"># event 指鼠标事件，x,y为坐标，flags为组合按键<br>def mouse_callback(event, x, y, flags, userdata):<br>    print(event, x, y, flags, userdata)<br>    if event == 2:  # 右键退出<br>        cv2.destroyAllWindows()<br>        <br>cv2.setMouseCallback(&quot;窗口名&quot;, mouse_callback, &quot;&quot;)<br></code></pre></td></tr></table></figure><hr><h3 id="1-3-C-中的Mat在python接口处的转化"><a href="#1-3-C-中的Mat在python接口处的转化" class="headerlink" title="1.3 C++中的Mat在python接口处的转化"></a>1.3 C++中的Mat在python接口处的转化</h3><p>Mat是OpenCV C++中的数据结构，**<u>在python中被转化为 numpy的ndarray</u>**</p><ul><li>Mat 由header + data构成，header中记录图片的维数、大小、数据类型等</li><li>利用numpy提供的深浅拷贝方法，可以实现Mat的拷贝<ul><li>img.view() # 浅拷贝 </li><li>img.copy() # 深拷贝</li></ul></li><li>访问ndarray的属性，就相当于访问Mat图像的属性<ul><li>包括.shape, .size, .dtype(注意uint这个格式) 等</li></ul></li></ul><hr><h3 id="1-4-图像通道的分类与合并"><a href="#1-4-图像通道的分类与合并" class="headerlink" title="1.4 图像通道的分类与合并"></a>1.4 图像通道的分类与合并</h3><ul><li>spilt(mat) 分割通道， merge((ch1, ch2, ch3)) 融合通道</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python3">b, g, r = cv2.split(img) # 先划分出来，它们会成为单独的图片<br><br>b[10:100, 10:100] = 255 # 在图像上划分出一个白色的方块(意义不明)<br>g[10:100, 10:100] = 255<br><br>img2 = cv2.merge((b, g, r)) # 图像合并<br><br>cv_show(&quot;b&quot;, b)<br>cv_show(&quot;g&quot;, g)<br>cv_show(&quot;r&quot;, r)<br>cv_show(&quot;img2&quot;, img2)<br></code></pre></td></tr></table></figure><hr><h3 id="1-5图像绘制"><a href="#1-5图像绘制" class="headerlink" title="1.5图像绘制"></a>1.5图像绘制</h3><ul><li><p>line(img, pt1, pt2, color, thickness, lineType, shift) 画直线</p><ul><li>img: 在哪个图像上画线</li><li>pt1, pt2: 开始点, 结束点. 指定线的开始与结束位置</li><li>color: 颜色</li><li>thickness: 线宽</li><li>lineType: 线型.线型为-1, 4, 8, 16, 默认为8</li><li>shift: 坐标缩放比例.</li></ul></li><li><p>rectangle() 参数同上  画矩形</p></li><li><p>circle(img, center, radius, color[, thickness[, lineType[, shift]]]) 中括号内参数表示可选参数. 画圆</p></li><li><p>ellipse(img, 中心点, 长宽的一半, 角度, 从哪个角度开始, 从哪个角度结束,…)</p></li><li><p>polylines(img, pts, isClosed, color[, thickness[, lineType[, shift]]]) 画多边形</p></li><li><p>fillPoly 填充多边形</p></li><li><p>putText(img, text, org, fontFace, fontScale, color[, thickness[, lineType[, bottomLeftOrigin]]]) 绘制文本</p><ul><li>text 要绘制的文本</li><li>org 文本在图片中的左下角坐标</li><li>fontFace  字体类型即字体</li><li>fontScale 字体大小</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python3">img = np.zeros((480, 640, 3), np.uint8)  # 创建画布(可以用numpy直接创建)<br><br># 画线<br>cv2.line(img, (10, 20), (300, 400), (0, 0, 255), 5, 4)<br>cv2.line(img, (80, 100), (380, 480), (0, 0, 255), 5, 16)<br><br># 画矩形<br>cv2.rectangle(img, (10, 10), (100, 100), (0, 0, 255), -1)<br><br># 画圆<br>cv2.circle(img, (320, 240), 100, (0, 0, 255))<br>cv2.circle(img, (320, 240), 5, (0, 0, 255), -1)<br><br># 画椭圆<br>cv2.ellipse(img, (320, 240), (100, 50), 15, 0, 360, (0, 0, 255), -1)<br><br># 画多边形<br>pts = np.array([(300, 10), (150, 100), (450, 100)], np.int32)<br>cv2.polylines(img, [pts], True, (0, 0, 255))<br># 填充多边形(上色)<br>cv2.fillPoly(img, [pts], (255, 255, 0))<br><br># 写字<br>cv2.putText(img, &quot;Hello OpenCV!&quot;, (10, 400), cv2.FONT_HERSHEY_TRIPLEX, 3, (255, 0, 0))<br></code></pre></td></tr></table></figure><ul><li>结合鼠标callback的方法，我们就可以使用opencv来绘图了</li></ul><hr><h2 id="Chapter2-图像的基本处理"><a href="#Chapter2-图像的基本处理" class="headerlink" title="Chapter2 图像的基本处理"></a>Chapter2 图像的基本处理</h2><h3 id="2-1-图像基本变换"><a href="#2-1-图像基本变换" class="headerlink" title="2.1 图像基本变换"></a>2.1 图像基本变换</h3><h4 id="2-1-1-放大-缩小"><a href="#2-1-1-放大-缩小" class="headerlink" title="2.1.1 放大&#x2F;缩小"></a>2.1.1 放大&#x2F;缩小</h4><ul><li><p>resize(src, dsize[, dst[, fx [, fy[, interpolation]]]])</p><ul><li><p>src: 要缩放的图片</p></li><li><p>dsize: 缩放之后的图片大小, 元组和列表表示均可.</p></li><li><p>dst: 可选参数, 缩放之后的输出图片</p></li><li><p>fx, fy: x轴和y轴的缩放比, 即宽度和高度的缩放比.</p></li><li><p>interpolation: 插值算法, 主要有以下几种:</p><ul><li>INTER_NEAREST, 邻近插值, 速度快, 效果差.</li><li>INTER_LINEAR, 双线性插值,  使用原图中的4个点进行插值. 默认.</li><li>INTER_CUBIC, 三次插值, 原图中的16个点.</li><li>INTER_AREA, 区域插值, 效果最好, 计算时间最长.</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python3">dog = cv2.imread(&#x27;dog.jpg&#x27;)<br><br>new_dog = cv2.resize(dog, dsize=(800, 800), interpolation=cv2.INTER_NEAREST)<br>cv_show(new_dog)<br></code></pre></td></tr></table></figure><hr><h4 id="2-1-2-旋转-翻转"><a href="#2-1-2-旋转-翻转" class="headerlink" title="2.1.2 旋转&#x2F;翻转"></a>2.1.2 旋转&#x2F;翻转</h4><ul><li><p>flip(src, flipCode)  # 翻转</p><ul><li><p>flipCode &#x3D; 0 表示上下翻转</p></li><li><p>flipCode &gt; 0 表示左右翻转</p></li><li><p>flipCode &lt; 0 上下 + 左右</p></li></ul></li><li><p>rotate(img, rotateCode&#x3D;___)  # 旋转</p><ul><li>ROTATE_90_CLOCKWISE 90度顺时针</li><li>ROTATE_180 180度</li><li>ROTATE_90_COUNTERCLOCKWISE 90度逆时针</li></ul></li></ul><hr><h3 id="2-2-图像的仿射变换"><a href="#2-2-图像的仿射变换" class="headerlink" title="2.2 图像的仿射变换"></a>2.2 图像的仿射变换</h3><p>仿射变换：图像旋转、缩放、平移都可以用仿射变换来描述。其本质是 变换矩阵和图片矩阵的矩阵运算。</p><ul><li>warpAffine(src, M, dsize, flags, mode, value)<ul><li>M:变换矩阵</li><li>dsize: 输出图片大小</li><li>flag: 与resize中的插值算法一致</li><li>mode: 边界外推法标志</li><li>value: 填充边界值</li></ul></li></ul><h4 id="2-2-1-平移矩阵"><a href="#2-2-1-平移矩阵" class="headerlink" title="2.2.1 平移矩阵"></a>2.2.1 平移矩阵</h4><ul><li>矩阵中的每个像素由(x,y)组成,(x, y)表示这个像素的坐标. 假设沿x轴平移$t_x$, 沿y轴平移$t_y$, 那么最后得到的坐标为$(\hat x, \hat y) &#x3D; (x + t_x, y + t_y)$,  用矩阵表示就是:</li><li><font size = 4 color = 'red'>$ \left(\begin{matrix}\hat x \\hat y \1\end{matrix}\right) &#x3D; \left(\begin{matrix}1 &amp; 0 &amp; t_x\0 &amp; 1 &amp; t_y\0 &amp; 0 &amp; 1\end{matrix}\right)\left(\begin{matrix}x \y \1\end{matrix}\right) $</font></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python3">h, w, ch = img.shape<br>M = np.float32([[1, 0, 0], [0, 1, -100]])  # 最终代码长这样<br>new_img = cv2.warpAffine(img, M, (w, h))<br></code></pre></td></tr></table></figure><hr><h4 id="2-2-2-获取变换矩阵W-（通过这个API获取你想要进行的变换的-变换矩阵W，然后调用warpAffine）"><a href="#2-2-2-获取变换矩阵W-（通过这个API获取你想要进行的变换的-变换矩阵W，然后调用warpAffine）" class="headerlink" title="2.2.2 获取变换矩阵W （通过这个API获取你想要进行的变换的 变换矩阵W，然后调用warpAffine）"></a>2.2.2 获取变换矩阵W （通过这个API获取你想要进行的变换的 变换矩阵W，然后调用warpAffine）</h4><ul><li><font color = 'red'>getRotationMatrix2D(center, angle, scale)</font></li></ul><p></p><ul><li><p>center 中心点 , 以图片的哪个点作为旋转时的中心点.</p></li><li><p>angle 角度: 旋转的角度, 按照逆时针旋转.</p></li><li><p>scale 缩放比例: 想把图片进行什么样的缩放.</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python3">M = cv2.getRotationMatrix2D((w/2, h/2), 15, 1.0)<br>new = cv2.warpAffine(img, M, (w, h))<br></code></pre></td></tr></table></figure><ol><li>按照病例来划分训练和测试集，不使用比例划分的方式，修改训练代码，不使用轮次batch喂模型</li><li>优化多边形和方形裁剪的方式，不用边缘回归了，直接图像中心裁剪后padding为224**输入模型</li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Graphic Processing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Image Processing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像处理初步</title>
    <link href="/1976/04/01/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%88%9D%E6%AD%A5/"/>
    <url>/1976/04/01/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%88%9D%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p><strong>CV非常依赖图像处理的基本知识！注意学习图像的基础知识</strong></p><h1 id="图像的基本知识"><a href="#图像的基本知识" class="headerlink" title="图像的基本知识"></a>图像的基本知识</h1><p>不同的色彩空间：</p><ul><li><p>灰度 1byte  描述灰白图像，一个数值，单通道</p></li><li><p>RGB 3byte 描述一张彩色图像，3个数值，一般是三通道，但是可以通过压缩，让RGB三个数值总共占16bit(比如RGB 565)，即两通道</p><ul><li>BGR 交换了色彩通道，不同的框架在显示图片时默认的色彩空间是不一样的，但图片的二进制一样，因此颜色可能会出现问题。</li></ul></li><li><h4 id="HSV"><a href="#HSV" class="headerlink" title="HSV"></a>HSV</h4><ul><li>Hue： 色相，用角度度量的色彩 红色为0°，绿色为120°,蓝色为240°，其实吧，直接通过Hue就可以看出来颜色了啊？<ul><li><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h31z6bcrhnj20k50lu0th.jpg" style="zoom:50%;" /></li></ul></li><li>Saturation: 饱和度, 表示颜色接近光谱色的程度。一种颜色，可以看成是某种光谱色与白色混合的结果。其中光谱色所占的比例愈大，颜色接近光谱色的程度就愈高，颜色的饱和度也就愈高。饱和度高，颜色则深而艳。光谱色的白光成分为0，饱和度达到最高。通常取值范围为0%～100%，值越大，颜色越饱和。 「人话就是：颜色的纯度。控制饱和度的方式是在颜色中加入白色，这个值越大，加入的白色越少，颜色就越纯，换句话说，圆盘的中心就是白色，外圈则是纯色」</li><li>Value: 明度. 明度表示颜色明亮的程度，对于光源色，明度值与发光体的光亮度有关；对于物体色，此值和物体的透射比或反射比有关。通常取值范围为0%（黑）到100%（白） 「和饱和度相对应，就是在颜色中加入黑色的量，这个值越大，加入的黑色越少，明度就越高」</li></ul></li><li><h4 id="HSL"><a href="#HSL" class="headerlink" title="HSL"></a>HSL</h4><ul><li>Hue 还是色相，这和HSV是完全一样的</li><li>Saturation，这个和HSV的饱和度机制不同，<u>具体如何生效？</u></li><li>Lightness：图像亮度 「它一项就相当于HSV中的S和V，最亮为白色，最暗为纯黑色，所以可以看到HSL最上面一圈是白的，最下面一圈是黑的」</li><li>他们的具体区别如下图所示 (左为HSL，右为HSV)</li><li><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h31z81dl11j20yn0j0adg.jpg"></li></ul></li><li><h4 id="YUV"><a href="#YUV" class="headerlink" title="YUV"></a>YUV</h4><ul><li>颜色编码方法。 考虑到人类的色彩感知能力，在编码时对信息进行下采样</li><li>Y：明度(灰阶值)， U&amp;V(色度，描述色彩和饱和度)</li><li>出现在彩色和黑白电视的过渡时期。</li></ul></li></ul><hr><h1 id="图像的变换-直接处理"><a href="#图像的变换-直接处理" class="headerlink" title="图像的变换(直接处理)"></a>图像的变换(直接处理)</h1><h3 id="反色变换"><a href="#反色变换" class="headerlink" title="反色变换"></a>反色变换</h3><p>目标：<code>增加暗色背景图像里的明亮区域</code></p><p>如果图像灰度值范围为 [0, L], 则反色变换为 </p><p>$输出灰度值output &#x3D; 最大灰度值L - 输入灰度值input$</p><p>也就是说，输出灰度矩阵中的每个点的灰度，是原图像中最大灰度点的灰度 - 自己本身的灰度 </p><p>​(如图像最大灰度为160，这个像素点的灰度为20，那么转换后它的灰度为 160-20 &#x3D; 140)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np   <span class="hljs-comment"># matrix manipulation</span><br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image   <span class="hljs-comment"># read image from hard disk</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt   <span class="hljs-comment"># matplotlib中的绘图工具</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">image_inverse</span>(<span class="hljs-params"><span class="hljs-built_in">input</span></span>):<br>  value_max = np.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">input</span>)  <span class="hljs-comment"># 求出图片的最大灰度值，注意这里是一个整型</span><br>  output = value_max - <span class="hljs-built_in">input</span>  <span class="hljs-comment"># 利用numpy的广播机制，使得value</span><br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><span class="hljs-comment"># asarray 将图像转变为numpy矩阵</span><br>    gray_img = np.asarray(Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./x.jpg&#x27;</span>).convert(<span class="hljs-string">&#x27;L&#x27;</span>))<br>inv_img = image_inverse(gray_img)<br>    <br>    fig = plt.figure()<br>    ax1 = fig.add_subplot(<span class="hljs-number">121</span>)   <span class="hljs-comment"># 指图像数量为一行两列, 第三个1为1号位置</span><br>    ax1.set_title(<span class="hljs-string">&#x27;before&#x27;</span>)<br>    <span class="hljs-comment"># cmap = &#x27;gray&#x27; 意味着图像以灰度图像的形式显示</span><br>    ax1.imshow(gray_img, cmap = <span class="hljs-string">&#x27;gray&#x27;</span>, vmin = <span class="hljs-number">0</span>, vmax = <span class="hljs-number">255</span>)<br>    <br>    ax2 = fig.add_subplot(<span class="hljs-number">122</span>)<br>    ax2.set_title(<span class="hljs-string">&#x27;after&#x27;</span>)<br>    ax2.imshow(inv_img, cmap = <span class="hljs-string">&#x27;gray&#x27;</span>, vmin = <span class="hljs-number">0</span>, vmax = <span class="hljs-number">255</span>)<br>    <br>    plt.show()<br>    <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Computer Graphic Processing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Image Processing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机技术杂谈</title>
    <link href="/1976/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    <url>/1976/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机技术杂谈"><a href="#计算机技术杂谈" class="headerlink" title="计算机技术杂谈"></a>计算机技术杂谈</h1><h3 id="大数据与云计算"><a href="#大数据与云计算" class="headerlink" title="大数据与云计算"></a>大数据与云计算</h3><p>大数据不是数据存储技术，而是和海量数据相关的抽取、集成、管理、分析、解释方法，是一个庞大的框架系统。宏观上讲，对数据进行映射和提炼，发现其数据特征并加以利用。从技术上说，是通过<strong>获取、存储、分析，从大容量数据里挖掘价值的</strong>技术架构。</p><p>大数据的量级在 PB(1024TB)或者EB级，其关键特点有 Volume(量)、Variety、**Velocity(时效性短)**、Value(价值密度低)</p><p>云计算：这种基于互联网的计算方式，可以更好的对软硬计算资源进行整合，在我看来，这个概念有些类似操作系统中提供虚拟化资源的概念，相当于是面向互联网计算的虚拟计算环境，使用户能够方便、有效地共享和利用网络上的资源</p><hr><h3 id="前端-后端"><a href="#前端-后端" class="headerlink" title="前端 &amp; 后端"></a>前端 &amp; 后端</h3><ul><li>广义上说，任何和UI直接相关的工作，都属于前端，狭义上讲，前端就是网页端</li><li>后端 是具体实现功能的地方，<strong>并且负责关键的 状态维护 和 控制权限</strong>，这些控制机制不能被放在前端</li></ul><h3 id="JavaScript，CSS与HTML的关系"><a href="#JavaScript，CSS与HTML的关系" class="headerlink" title="JavaScript，CSS与HTML的关系"></a>JavaScript，CSS与HTML的关系</h3><ul><li><strong>HTML定义页面结构和核心内容，CSS则为这些内容加上样式，JS则可以同时做到这两件事。</strong><ul><li>抽象的说，html是骨，负责将信息结构化，CSS则是肉，负责添加装饰性内容</li><li>CSS可以更简单的完成一些html完成很麻烦的工作，比如将所有的标题居中。</li></ul></li><li>JS可以完成html和css的工作，但复杂一些，其主要功能是 <strong>指导浏览器如何动态建立结构和作用样式，也就是负责控制逻辑</strong></li></ul><hr><h4 id="SSL-SSH"><a href="#SSL-SSH" class="headerlink" title="SSL &amp; SSH"></a>SSL &amp; SSH</h4><p>在原本的HTTP协议中，内容是明文形式传输，而HTTPS &#x3D;&gt; <strong>SSL&#x2F;TLS</strong>(Secure Sockets Layer &#x2F; Transport Layer Security) 协议，默认为443端口，本身可以看作是传输层的附加层。有三个好处</p><ul><li>加密。防窃听</li><li>校验。防篡改</li><li>证书。防冒充</li></ul><p>其基本思路在于 **使用<code>公钥加密</code>加密<code>会话密钥</code>**，注意：会话密钥本身是对称加密的密钥，实际上https客户端和服务器的通信是使用对称加密的，这样更快。</p><h4 id="SSL和SSH-Secure-Shell"><a href="#SSL和SSH-Secure-Shell" class="headerlink" title="SSL和SSH Secure Shell"></a>SSL和SSH Secure Shell</h4><p>两者间建立一条加密通道，将数据加密并且压缩传输。  SSL并非协议，而SSH则是建立在SSL基础上的协议。 SSH可以代替telnet 和 ftp</p><hr><h2 id="成为后端工程师"><a href="#成为后端工程师" class="headerlink" title="成为后端工程师"></a>成为后端工程师</h2><p>语言： Java(Spring)、<strong>Golang</strong>、C++， 和语言对应的Web框架</p><ul><li>计算机网络 TCP&#x2F;IP详解「卷一」，HTTP相关</li><li>算法导论</li><li>OS   OS黑皮</li><li>数据库 <ul><li>MySQL， 高性能MySQL 面之前要看前半段</li><li>非关系数据库 redis</li></ul></li><li>linux  鸟叔私房菜，30天入门linux</li></ul><p>Web项目： 开源项目</p><hr><h2 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h2><blockquote><p>深度学习是基于 DBN(Brief) 深度置信网络来设计的，<br>DeepLearning 和 神经网络的关系， 深度学习 ≈ 神经网络， 算是传统神经网络的升级版本，**<u>深度学习的特征是自己提取的， 而不是人工提取的</u>**</p><p>DL 学习能力更强，也能解决更复杂的问题，但是需要更大量的数据和更高的硬件要求，容易出现偏见的情况。<br>DL的应用：计算机视觉、NLP</p><p>4个典型的DL算法</p><p>CNN，RNN(循环) ， GANS(生成对抗网络)， RL </p><p>后续会专门介绍CNN， 这里简要介绍一下RNN、GANS和RL</p><ul><li>RNN  用来处理 <strong><u>序列数据</u></strong> 如文章、语音、股票，一般就用来翻译、语音识别等等。</li><li><a href="https://easyai.tech/ai-definition/gan/">GANS</a> </li><li>RL  其实RL和监督&#x2F;无监督学习的区别就在于，它不需要数据喂养，而是自己尝试, 注意强化学习是一种深度学习算法</li></ul></blockquote><blockquote><h4 id="CNN-convolution-neutral-network"><a href="#CNN-convolution-neutral-network" class="headerlink" title="CNN  convolution neutral network"></a>CNN  convolution neutral network</h4><p>CNN是受到人类视觉神经系统启发。 实际应用在图片分类、检索，目标分割、人脸识别等等。 说白了，&#x3D;&#x3D;主要就是处理图像用的&#x3D;&#x3D;，其关键就在于可以对图像进行降维(1000 pix -&gt; 200 pix 其实不会影响识别)</p><p>典型CNN由  **<u>卷积层、池化层、全连接层</u>**来组成</p><ul><li>卷积层 负责<strong>提取图像特征</strong></li><li>池化层 <strong>降维 防止过拟合现象</strong></li><li>全连接层  输出结果</li></ul><p>卷积层干了啥：</p><ul><li>&#x3D;&#x3D;卷积是什么：将一个函数翻转，然后 滑动叠加 (求积分、加权求和)&#x3D;&#x3D;</li><li>可以有很多个卷积核，每个代表了一种图像模式，用卷积核去遍历图像，某个图像块如果和这个卷积核卷积出的值大, 就认为这个图像块比较类似此卷积核。  通过这个方法提取出整个小区域的特征。注意边界需要进行padding，填充一下</li><li>卷积层的输出是一张特征图, 需要通过全连接转化成特征向量.</li></ul><p>池化层(简单来说就是 下采样，降低数据维度)</p><ul><li>Convolved feature &#x3D;&gt; Pooled feature ， 其实卷积也是降低数据维度，但是池化的降低非常有效，并且可以有效的避免过拟合</li></ul><p>全连接层</p><ul><li><p>首先要注意的是，典型的CNN并不一定是，3层结构，而是多层结构</p></li><li><p>全连接本质上 是一个classification,  在FCN中, 就用1x1的卷积代替了全连接的功能(先把特征图平铺, 然后用1x1卷积核遍历)</p></li></ul></blockquote><ul><li>NLP 是什么，我的理解是， 让计算机可以理解文字的意义，并做出回答。实际上，人类的语言比较随便，不确定性很大，像单词边界界定、单词的多义、句法的模糊性、不正确的输入，都是NLP需要解决的问题。</li><li>贝叶斯分类：  <strong>一种分类算法</strong>，以贝叶斯定理为基础， 朴素贝叶斯又是里面最基础的？</li><li>SVM 支持向量机  完成分类</li><li>什么是梯度下降<ul><li>寻找极小值的方法，沿着梯度反方向迭代搜索</li></ul></li><li>什么是反向传播<ul><li>对所有权重计算损失函数的梯度</li></ul></li></ul><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链:"></a>区块链:</h3><ul><li>分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的 新型应用模式，狭义来讲，区块链是一种按照时间顺序将数据区块以顺序相连 的方式组合成的一种链式数据结构， 并以密码学方式保证的不可篡改和不可伪造的分布式账本</li></ul><h4 id="P问题、NP问题、NP难、NP完全问题"><a href="#P问题、NP问题、NP难、NP完全问题" class="headerlink" title="P问题、NP问题、NP难、NP完全问题"></a>P问题、NP问题、NP难、NP完全问题</h4><ul><li>P &#x3D;&gt; Polynomial 可以在多项式时间内解决的问题(计算机在有限时间可以解决)</li><li>NP  &#x3D;&gt; nonderministic polynomial   可以在多项式时间内验证的问题 ，但不能确定是否能在多项式时间内解决(典型：是否存在哈密顿回路)</li><li>NP难， 未必可以在多项式时间内验证解的正确性，比如每个广播站有个圆形范围，我们要用最少的广播站覆盖全美，我们无法在有限时间里验证答案的正确性.</li><li>NPC &#x3D;&gt; NP complete， NP里面难解的问题，如果NPC有解，那么说明P &#x3D; NP(因为NPC问题可以转化成NP问题)</li></ul><h4 id="计算机安全学"><a href="#计算机安全学" class="headerlink" title="计算机安全学"></a>计算机安全学</h4><ul><li>古典密码基本模块：Substitution 代换、置换 permutation</li><li>对称和公钥的区别：公钥匙俩密钥，其实对称加密，对密钥的使用、加密解密算法都可以不同</li><li>AES在做什么： 是一种分组密码 基本上思想是 扩散和混淆<ul><li>分组长度128， 密钥 128 等三种，N轮加密，10、12、14 由密钥决定</li><li>128位例 输入的密钥被扩展成44个数组，每一轮用4个作为轮密钥</li><li>每一轮进行4个操作，(加解密时最后一轮少一个)  字节代换(查表SBOX)，行移位、列混淆然后轮密钥加(分组和扩展密钥中的4行进行按位XOR)</li></ul></li><li>RSA  公钥加密，私钥解密<ul><li>找两个大素数、 n &#x3D; p*q， <strong>phi(n) &#x3D; (p-1)*(q-1)</strong></li><li><strong>选一个和phi(n)互素的e</strong>， <strong><u>d 是 e 在 phi(n)下的 的逆元</u></strong></li><li>可以公开e 和 n，  但必须保密 p和q以及d</li><li>P^e^ &#x3D; C (mod n),   C^d^ &#x3D; P (mod n)</li></ul></li><li>数字签名： 私钥只有你能掌握，你用私钥加密报文就可以了</li><li>密码学的HASH： 完整性认证(防篡改、数字签名、生成随机数 就记这么几个)<ul><li>HASH函数： 分块、填充、迭代压缩</li><li>报文认证码 可以用hash实现，也可以不用 懂了吧</li></ul></li><li>什么是XSS攻击，在动态网页里植入恶意链接</li><li>SQL注入： 将恶意的SQL查询&#x2F;添加语句插入到输入参数里，然后进行解释执行</li></ul><h3 id="计组"><a href="#计组" class="headerlink" title="计组"></a>计组</h3><ul><li>DRAM  主存， SRAM Cache</li><li>哈夫曼树原理，  指令拓展(一地址 二地址 三地址) 和 计网里IP地址分配， 都有一定的哈夫曼树思想</li><li>CPU里包含： ALU、PC、IR、寄存器组，CU(ID),  一般MAR和MDR也集成在CPU中</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><p>Tree</p><ul><li><p>BST 注意中序有序的性质， AVL 最小不平衡子树的概念 是BST的特殊形式</p></li><li><p>RBT 如果问到这个 建议是展开聊一下 unordered_map和map(RBT 因为需要有序)的不同实现</p></li><li><p>Huffman Tree  给叶子的权值，想要建一颗WPL最小的树</p><ul><li>每次在优先队列里挑出俩最小的合并</li></ul></li><li><p>字典树 Tire ，利用 共同前缀设计的，一路走下去就是一个字符串，可以快速查找和插入</p></li><li><p>线段树 ，用<strong>来维护区间信息</strong></p></li></ul></li><li><p>查找</p><ul><li>B树    用在磁盘，BST的进化，其插入和删除都比较复杂</li><li>B+   用在关系型数据库，叶子连着，中无信息，可以顺序查找，启动磁盘的次数更少！</li><li>散列： 我感觉散列的核心就是： hash函数、冲突处理、物理结构</li></ul></li><li><p>图算法， 我们看待图问题，应该从图算法需要解决的问题来考虑</p><ul><li>十字链表 邻接多重表，图算法的复杂度和存储结构的关系很大</li><li>统计连通分量： BFS、 并查集</li><li>最小生成树： Prim(点优先)  Kruskal 边优先</li><li>最短路径：BFS(无权图)、Dij(带权, 贪心思想)、Floyd(动态规划)<ul><li>Diji  final, dist, path, 三个数组, 在dist里找最小，更新final，找相连 再更新dist</li></ul></li><li><strong>拓扑排序</strong>：找到做事的先后顺序，使用优先队列，可以完成特殊的拓扑排序(可以stack)<ul><li>DFS在退栈时输出，可以直接完成逆拓扑排序 毕竟是统计出度的</li></ul></li><li>关键路径 我不管了</li><li>并查集：判环(拓扑排序)、求联通分量 、kruskal算法利用了USF</li></ul></li><li><p>排序</p><ul><li>冒、选、插、堆、归、快速、希尔、桶排序、基数排序<ul><li>希尔：按照间隔进行插入排序</li><li>快排：什么时候最快，什么时候最慢，如果你的基准元素选第一个元素，那么已经有序是最慢的。 两个指针轮流走(其中一个指针指的是空的)，走到不符合的地方，把自己的元素拿过去，然后另一个走，两指针相遇算结束，两指针相遇的地方就是**<u>枢轴</u>**元素正确的位置，然后对两边递归的再次快排。</li><li>归并排序：有的时候想给磁盘里的东西排序，但是内存不够大，于是通过归并来完成</li><li>桶排序就是 利用某种规则，比如&#x2F;10， 把元素们分别放到若干个桶里，然后每个桶内部再排</li><li>Radix Sort 是特例，设置10个桶，从个位开始，放入，收集，放入收集。和桶排序都一样是空间换时间，不是基于比较的排序, 不受到nlogn的下限影响</li></ul></li></ul></li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li><p>动态规划</p><ul><li><p>LCS 子串必须连续，子序列则是去掉几个元素后形成的序列</p><p>LCS作为典型的动态规划问题，二维动态规划， <u>可以画表来解决</u>，</p></li></ul></li><li><p>贪心和动态规划如何选？</p><ul><li>两个人其实都是求最优解，而且都是划成小问题吧，贪心的小问题 没有后效性(换句话说就是每个小问题的结果对后面的问题没有影响)</li></ul></li><li><p>分治 Divide and Conquer</p><ul><li>树的算法 其实经常就是分治法(一个大问题 分成好几个问题)， 值得注意的是， 斐波那契数列是有分治思想的</li></ul></li><li><p>是否存在一条合理的路径， 是否存在一个合理的解， 深度优先搜索</p></li><li><p>回溯算法的思想：一条路走到黑，走不通就退回来，典型问题 八皇后，我觉得回溯的效率是比较低的，不喜欢使用</p></li></ul><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li><p>大内核和小内核： 大内核复杂但效率高，小内核方便维护但需频繁切换目态和管态</p></li><li><p>&#x3D;&#x3D;操作系统做什么： 管理资源，向上层提供接口，扩充机器，保护系统？，直接去利用硬件资源是困难的&#x3D;&#x3D;</p></li><li><p>一个C++ 文件如何运行： 编译 -&gt; 链接 -&gt; 装入 -&gt; 运行</p></li><li><p>是不是连续分配(有无分页？)，有没有虚拟化？    只要不是按需分配 就一定会存在内部碎片！</p></li><li><p>逻辑地址A      我们要知道逻辑地址和物理地址 是解读方式不一样</p><ul><li>页号 + 页内偏移量     这个页号拿去跟TLB比一下，不行就拿去跟页表比一下</li></ul></li><li><p>内存管理时 &#x3D;&#x3D;<strong>stack用来函数调用，  堆则用来存动态分配的变量</strong>&#x3D;&#x3D;</p></li><li><h4 id="死锁：-满足4个条件，互斥、不可剥夺、请求和保持、循环等待"><a href="#死锁：-满足4个条件，互斥、不可剥夺、请求和保持、循环等待" class="headerlink" title="死锁： 满足4个条件，互斥、不可剥夺、请求和保持、循环等待"></a>死锁： 满足4个条件，互斥、不可剥夺、请求和保持、循环等待</h4><ul><li>预防死锁(破坏这4个条件)，避免死锁(银行家)，检测死锁 要提到并发度的影响</li></ul></li><li><h4 id="锁-只用来实现互斥-与条件变量-只用来实现同步-因为没有值-就是等待队列-讲一下和信号量的"><a href="#锁-只用来实现互斥-与条件变量-只用来实现同步-因为没有值-就是等待队列-讲一下和信号量的" class="headerlink" title="锁(只用来实现互斥)与条件变量(只用来实现同步 因为没有值 就是等待队列)   讲一下和信号量的"></a>锁(只用来实现互斥)与条件变量(只用来实现同步 因为没有值 就是等待队列)   讲一下和信号量的</h4><ul><li>为什么有锁呢，因为有些资源必须要互斥访问，进入临界区时获得锁，出去时释放锁</li><li>自旋锁  就是说 忙等，在多核系统上好使</li></ul></li></ul><h4 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h4><ul><li>SDN是什么<ul><li>软件来控制整个网络，包括路由器的转发表和路由表，在传统网络里这都是需要路由器自己计算的</li></ul></li><li>数据链路是什么 点对点信道</li><li>IP  A 10开始  B 172. C. 192. ,<ul><li>ARP： 发广播回单波，不知道人家的MAC地址， RARP是不知道自己的IP地址</li></ul></li><li>TCP<ul><li>为什么三次握手：两次 服务器不知道自己接受连接的消息有没有送到客户端，会浪费资源。 第三次握手 可以传数据，但是一般不传</li><li>为什么四次挥手：  CSSC的顺序，等待2MSL是看服务器是否还有消息(信道)</li></ul></li><li>应用层<ul><li>FTP： 两条连接，是C&#x2F;S模式，只有两种格式</li><li>发SMTP 收 POP3，IMAP，HTTP</li><li>HTTP： 传输层是TCP，但HTTP本身不依赖连接。 浏览器向Web服务器发HTTP请求报文(在这之前先要向域名解析服务器要到IP)，Web服务器发送HTTP响应，然后释放TCP连接。  短连接、无状态是描述HTTP最好的方式，但在HTTP1.1 之后支持KEEP ALIVE</li></ul></li></ul><hr><h2 id="科普"><a href="#科普" class="headerlink" title="科普"></a>科普</h2><ul><li>UTF-8 是什么：可变长的Unicode编码，因为正常的Unicode要2个字节，用哈夫曼编码的思想改组一下。 注意，ASCII编码可以看作是Unicode(UTF-8)编码的一部分。<ul><li>UTF-8是存储和传输时的编码，在运行时是Unicode编码！！</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Computation tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互联网原理</title>
    <link href="/1976/04/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8E%9F%E7%90%86/"/>
    <url>/1976/04/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="SP-edition-信息社会传奇"><a href="#SP-edition-信息社会传奇" class="headerlink" title="#SP edition 信息社会传奇"></a>#SP edition 信息社会传奇</h1><ul><li><strong>信息网络 能源 交通 是现代社会的三大基础</strong></li><li><strong>数据$\Rightarrow$  传输和存储的 可识别的数字符号</strong></li><li>信息交互 (一对一 一对多 多对多)<ul><li>有效性</li><li>安全性</li></ul></li><li><strong>计算机网络$\Rightarrow$ 将计算机或外部设备连接在一起，实现 <u>信息交互和应用服务</u>的设备 通信链路 通信规约和软件的集合</strong></li></ul><ul><li>因特网 $\Rightarrow$ 特指由美国创建和管理的全球互联网</li></ul><hr><h4 id="计算机网络发展-Web发展-快速发展期"><a href="#计算机网络发展-Web发展-快速发展期" class="headerlink" title="计算机网络发展(Web发展&#x2F;快速发展期)"></a>计算机网络发展(Web发展&#x2F;快速发展期)</h4><ul><li>Tim Berners-Lee 1989年提出了 Web， 1991年开通了第一个 WWW网站<a href="https://info.cern.ch/">https://info.cern.ch/</a>  1993年制定了全球信息浏览的Web规范</li><li>1994年8月11日 netMarket公司 建立了第一个电子商务网站并完成了全球第一笔网络零售交易</li><li>1995年 杰夫·贝佐斯创建了 Amazon</li><li>1994年4月20日 中国科学技术网成功和Internet连接(64k&#x2F;s)</li><li>1994年10月 Grand Juction公司推出第一套快速以太网</li><li>1995年3月 IEEE宣布了快速以太网标准 Fast Ethernet LAN进入100M时代</li><li>1997年6月 IEEE802.11标准出台 无线网络代替了有线网络实现高效 高速的联网方案 (WIFI)</li><li>1998～1999 高速以太网标准形成 </li><li>1998年9月7日 Google成立 &#x2F; qq出现</li><li>2001年 万兆以太网出现(有线)(用于组网核心 城域网)</li><li>2004年 Mark Zuckerberg 建立Facebook</li><li>2006年 Twitter出现</li><li>2007年6月29日 Steve Jobs的iPhone上市 移动互联网时代开启</li><li>2007年11月 Google发起的手机联盟推出Android 以Apache开源许可证的授权方式开放源代码</li></ul><hr><h4 id="计算机网络提供的服务"><a href="#计算机网络提供的服务" class="headerlink" title="计算机网络提供的服务"></a>计算机网络提供的服务</h4><p><strong><u>三大核心$\Rightarrow$应用 交互 管理</u></strong></p><ol><li>网络应用服务</li><li>具体联网和信息交互(解决不同速率 距离 成本需要的组网技术) 1973年 Vinton Cerf&#x2F;Robert Kahn指出不可能存在能满足所有需求的单一分组网络技术</li><li>大规模的组网和信息交互技术</li><li>网络辅助技术 解决网络运行时的问题</li></ol><hr><h4 id="计算机网络应用"><a href="#计算机网络应用" class="headerlink" title="计算机网络应用"></a>计算机网络应用</h4><p>互联网网络应用(服务) 建立在TCP&#x2F;IP协议之上的应用服务</p><p>连接 $\Rightarrow$ 联合</p><p>早期的Internet应用 Telnet(远程计算机访问) Email FTP(文件传送) Newsgroup(新闻组) BBS论坛</p><h5 id="应用的发展过程"><a href="#应用的发展过程" class="headerlink" title="应用的发展过程"></a>应用的发展过程</h5><p>E-mail FTP $\Rightarrow$ 静态网页 $\Rightarrow$ 动态网页 $\Rightarrow$ 网上营销 $\Rightarrow$ 电子商务 $\Rightarrow$ 移动应用服务</p><p>宏观来看 信息交互 $\Rightarrow$ 综合业务应用 多媒体应用 $\Rightarrow$ 物联网 云计算应用</p><h5 id="万维网-World-Wide-Web"><a href="#万维网-World-Wide-Web" class="headerlink" title="万维网 World Wide Web"></a>万维网 World Wide Web</h5><p>万维网起源于欧洲粒子物理研究中心CERN </p><p>核心创新： 广泛关联 文档定位 文档快速传输 多格式文档阅读</p><p>网页(超文本) 表达的不再是线性的信息 而是非线性 联想式 信息关联的信息网。 Web表示这种由超文本连接起来的信息网</p><p>网址 $\Rightarrow$ 统一资源定位符 URL (Uniform Resource Locator)</p><p><a href="http://www.baidu.com/view/25482.htm">http://www.baidu.com/view/25482.htm</a></p><p> $\Uparrow$                     $\Uparrow$                              $\Uparrow$</p><p>Protocol       Name of Computer    Index and File name</p><p>支持缺省输入(支持默认)</p><h6 id="指定URL后-如何传输？"><a href="#指定URL后-如何传输？" class="headerlink" title="指定URL后 如何传输？"></a>指定URL后 如何传输？</h6><p>浏览器按URL链接服务器 请求服务 $\Rightarrow$ 网页服务器应答 返回 $\Rightarrow$ 浏览器完成解析之后显示网页</p><p>使用超文本传输协议HTTP 让网站和浏览器协商进行网页传输</p><h6 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h6><p>基本功能 $\Rightarrow$ 输入选取URL时 向Web服务器发送请求 接收文档 进行解析和显示</p><hr><h1 id="Chapter1-E-mail-WWW"><a href="#Chapter1-E-mail-WWW" class="headerlink" title="Chapter1 E-mail &amp;&amp; WWW"></a>Chapter1 E-mail &amp;&amp; WWW</h1><h1 id="E-MAIL-系统概述"><a href="#E-MAIL-系统概述" class="headerlink" title="E-MAIL 系统概述"></a>E-MAIL 系统概述</h1><h3 id="⚠️-邮件系统-在大型机上不同邮箱移动报文时-就已经出现了-它的出现至少不晚于Internet"><a href="#⚠️-邮件系统-在大型机上不同邮箱移动报文时-就已经出现了-它的出现至少不晚于Internet" class="headerlink" title="⚠️ 邮件系统 在大型机上不同邮箱移动报文时 就已经出现了 (它的出现至少不晚于Internet)"></a>⚠️ 邮件系统 在大型机上不同邮箱移动报文时 就已经出现了 (它的出现至少不晚于Internet)</h3><h5 id="而我们使用的-所谓-E-Mail-则是-特指通过计算机网络进行通信的-电子化信息传递系统"><a href="#而我们使用的-所谓-E-Mail-则是-特指通过计算机网络进行通信的-电子化信息传递系统" class="headerlink" title="而我们使用的 所谓 E-Mail 则是 特指通过计算机网络进行通信的 电子化信息传递系统"></a>而我们使用的 所谓 E-Mail 则是 特指通过计算机网络进行通信的 电子化信息传递系统</h5><h5 id="E-Mail-是-Internet上-使用最广泛的应用"><a href="#E-Mail-是-Internet上-使用最广泛的应用" class="headerlink" title="E-Mail 是 Internet上 使用最广泛的应用"></a>E-Mail 是 Internet上 使用最广泛的应用</h5><p>E-Mail定义了SMTP 和 MIME </p><h5 id="电子邮件需要实现以下的几个功能"><a href="#电子邮件需要实现以下的几个功能" class="headerlink" title="电子邮件需要实现以下的几个功能"></a>电子邮件需要实现以下的几个功能</h5><ol><li>创建电子邮件</li><li>发送和接收邮件</li><li>管理邮件 「管理：包括回复 转发 删除 存储 等等」</li><li>保证邮箱的私有性质 「虽然任何人都可以在邮箱里放入邮件 但只有邮箱的拥有者可以查看」</li></ol><h3 id="E-Mail的地址结构"><a href="#E-Mail的地址结构" class="headerlink" title="E-Mail的地址结构"></a>E-Mail的地址结构</h3><p>一般认为 邮箱地址要保证唯一  需要 <strong>邮箱名+存放邮箱的主机域名</strong></p><p><a href="mailto:&#x31;&#x33;&#x35;&#55;&#48;&#48;&#x30;&#x32;&#x37;&#x34;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;">&#x31;&#x33;&#x35;&#55;&#48;&#48;&#x30;&#x32;&#x37;&#x34;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;</a> $\Rightarrow$ 1357000274 为邮箱名 ｜  qq.com 存放邮箱的主机域名</p><h2 id="SMTP-Simple-Mail-Transfer-Protocol"><a href="#SMTP-Simple-Mail-Transfer-Protocol" class="headerlink" title="SMTP Simple Mail Transfer Protocol"></a>SMTP Simple Mail Transfer Protocol</h2><ul><li>1981年出现 **它只能传输字符 信息主体被限制为 ASCII码 **</li><li>SMTP 规定相互通信的 C&#x2F;S端两个 SMTP进程间如何进行信息交互</li><li>⚠️ SMTP没有定义 邮件采用何种格式 以及 如何存储邮件 发送和递交邮件</li></ul><h3 id="SMTP传送的过程"><a href="#SMTP传送的过程" class="headerlink" title="SMTP传送的过程"></a>SMTP传送的过程</h3><ul><li>类似上图 用户按照格式填装邮件 输入发送命令后 电子邮件接口软件 首先将这个邮件放在 邮件暂存队列里</li><li>对邮件的控制权此时来到了 <strong>邮件传输程序</strong>这里。 它将判断这封邮件发往哪里。「可以发送给 本地的计算机」</li><li>如果要向互联网远程用户发送邮件 在确认连接互联网后 <strong>邮件传输软件作为客户 和 邮件服务器进行通信(它在远程计算机上)， 传输软件会将 邮件的 一个<em>副本</em>发送到邮件服务器上</strong></li><li>邮件现在来到了邮件缓存区 发送方SMTP软件会定时(几分钟或几时分钟)扫描缓冲区队列</li><li>如果SMTP软件检测到了待发邮件 它就会 <strong>作为客户和目的计算机SMTP服务器端口(25)建立TCP连接</strong><ul><li>服务器发出 220 Service ready  客户端发送 helo + 邮箱+主机名；</li><li>服务器如果可以接收 会应答 250 OK 否则返回代码 421 Service not available | 451 &#x2F; 452 等异常命令<ul><li>SMTP定义了 14条命令(由4个字母组成) 和 21种应答(由3个数字开始)</li></ul></li><li>开始传输邮件副本</li></ul></li><li><strong>由客户端在发送结束后 通过 QUIT 命令释放TCP连接</strong></li></ul><h3 id="SMTP-是复杂的协商交互协议-通常会在后台工作-因为邮件系统从来就不是一个实时传输新系统"><a href="#SMTP-是复杂的协商交互协议-通常会在后台工作-因为邮件系统从来就不是一个实时传输新系统" class="headerlink" title="SMTP 是复杂的协商交互协议 通常会在后台工作(因为邮件系统从来就不是一个实时传输新系统)"></a>SMTP 是复杂的协商交互协议 通常会在后台工作(因为邮件系统从来就不是一个实时传输新系统)</h3><h3 id="SMTP可以用在两个用户之间-但主流情况下-使用-邮局和中转的概念「分发-转发-列表-按照列表分发-多重接收-同一个计算机上的多个邮箱-只建立一个TCP连接-」"><a href="#SMTP可以用在两个用户之间-但主流情况下-使用-邮局和中转的概念「分发-转发-列表-按照列表分发-多重接收-同一个计算机上的多个邮箱-只建立一个TCP连接-」" class="headerlink" title="SMTP可以用在两个用户之间 但主流情况下 使用 邮局和中转的概念「分发 转发 列表(按照列表分发) 多重接收(同一个计算机上的多个邮箱 只建立一个TCP连接)」"></a>SMTP可以用在两个用户之间 但主流情况下 使用 邮局和中转的概念「分发 转发 列表(按照列表分发) 多重接收(同一个计算机上的多个邮箱 只建立一个TCP连接)」</h3><p><strong>邮件中继：</strong> 当需要进行 <strong>大量的</strong>的邮件转发&#x2F;分发时 一个独立且能力更强的计算机<strong>E-Mail Gateway &#x2F; E-Mail Relay</strong> 出现了</p><p>组织地址：它帮助每个自己管理下的计算机完成邮件的收发「这个组织通常会运行一个组织网关来管理」</p><p><strong>邮件网关实际隔离外部邮件地址与内部邮件地址(计算机与用户)</strong></p><h2 id="MIME-Multipurpose-Internet-Mail-Extension"><a href="#MIME-Multipurpose-Internet-Mail-Extension" class="headerlink" title="MIME Multipurpose Internet Mail Extension"></a>MIME Multipurpose Internet Mail Extension</h2><h3 id="邮件在这个协议里-被允许-分成几个部分-每个部分可以通过不同的格式来传送"><a href="#邮件在这个协议里-被允许-分成几个部分-每个部分可以通过不同的格式来传送" class="headerlink" title="邮件在这个协议里 被允许 分成几个部分 每个部分可以通过不同的格式来传送"></a>邮件在这个协议里 被允许 分成几个部分 每个部分可以通过不同的格式来传送</h3><ul><li>头部 「发、收地址 日期 主题等条目  每个头部行开始是 行关键字和冒号 + 信息」</li><li>空行 用来分割 头部和信息文本</li><li>信息文本   包含了 多媒体二进制信息 可以实现任意编辑</li></ul><h2 id="存储传送方式-非端到端直接传送-｜-POP-IMAP"><a href="#存储传送方式-非端到端直接传送-｜-POP-IMAP" class="headerlink" title="存储传送方式(非端到端直接传送) ｜ POP &amp; IMAP"></a>存储传送方式(非端到端直接传送) ｜ POP &amp; IMAP</h2><p>在目前邮箱通常被放在电子邮件系统服务器计算机上 接受者要自己去邮件服务器 读自己的邮件 而不是它主动发给你</p><h3 id="常用的-远程读取的邮局协议POP-Post-Office-Protocol-1996-POP3-IMAP-Internet-Mail-Access-Protocol"><a href="#常用的-远程读取的邮局协议POP-Post-Office-Protocol-1996-POP3-IMAP-Internet-Mail-Access-Protocol" class="headerlink" title="常用的 远程读取的邮局协议POP(Post Office Protocol)(1996 POP3) | IMAP(Internet Mail Access Protocol)"></a>常用的 远程读取的邮局协议POP(Post Office Protocol)(1996 POP3) | IMAP(Internet Mail Access Protocol)</h3><p>用户计算机的电子邮件软件作为POP服务器的客户 来存取</p><h3 id="POP相比SMTP的优越性-rightarrow-POP不进行传输交互"><a href="#POP相比SMTP的优越性-rightarrow-POP不进行传输交互" class="headerlink" title="POP相比SMTP的优越性 $\rightarrow$ POP不进行传输交互"></a>POP相比SMTP的优越性 $\rightarrow$ POP不进行传输交互</h3><p>pop主要完成 创建连接 用户认证 事务操作(列出 取回并删除等等) ｜ 邮件将在被读取后的不久被POP删除</p><h3 id="IMAP-2003-IMAP4-和POP3一样采用C-S方式来工作-但比POP3复杂-用户能进行更多的操作-比如只看首部-并且在不下令删除的情况下保留用户的邮件"><a href="#IMAP-2003-IMAP4-和POP3一样采用C-S方式来工作-但比POP3复杂-用户能进行更多的操作-比如只看首部-并且在不下令删除的情况下保留用户的邮件" class="headerlink" title="IMAP (2003 IMAP4) 和POP3一样采用C&#x2F;S方式来工作 但比POP3复杂(用户能进行更多的操作 比如只看首部) 并且在不下令删除的情况下保留用户的邮件"></a>IMAP (2003 IMAP4) 和POP3一样采用C&#x2F;S方式来工作 但比POP3复杂(用户能进行更多的操作 比如只看首部) 并且在不下令删除的情况下保留用户的邮件</h3><h3 id="目前-具有大邮箱数据库和SMTP-POP服务器-中继功能的计算机-相当于电子邮局"><a href="#目前-具有大邮箱数据库和SMTP-POP服务器-中继功能的计算机-相当于电子邮局" class="headerlink" title="目前 具有大邮箱数据库和SMTP&#x2F;POP服务器+中继功能的计算机 相当于电子邮局"></a>目前 具有大邮箱数据库和SMTP&#x2F;POP服务器+中继功能的计算机 相当于电子邮局</h3><h2 id="E-Mail传递的发展"><a href="#E-Mail传递的发展" class="headerlink" title="E-Mail传递的发展"></a>E-Mail传递的发展</h2><ol><li>两个主机间点对点的 SMTP邮件直接收发</li><li>邮件网关(中继) 和组织邮件地址 出现中间管理服务</li><li>电子邮局出现 形成现今的电子邮件系统框架</li><li>SMTP完成发送 POP&#x2F;IMAP完成电子邮局登陆 读取和管理邮件</li></ol><h2 id="MIME协议和实现"><a href="#MIME协议和实现" class="headerlink" title="MIME协议和实现"></a>MIME协议和实现</h2><p>现在使用的 是多用途Internet邮件扩充MIME协议</p><h3 id="MIME完成的是传输-ASCII码之外的-二进制信息-声音-图像-影视信号也可以发送了"><a href="#MIME完成的是传输-ASCII码之外的-二进制信息-声音-图像-影视信号也可以发送了" class="headerlink" title="MIME完成的是传输 ASCII码之外的 二进制信息(声音 图像 影视信号也可以发送了)"></a>MIME完成的是传输 ASCII码之外的 二进制信息(声音 图像 影视信号也可以发送了)</h3><p>MIME的设计思路是不推翻SMTP架构而对其微调</p><p>做法是：</p><blockquote><p>将所有不同类型的二进制数据<strong>分段编码</strong>为7位ASCII码 然后用SMTP作为一般的文本来发送 然后在接收端转换回去</p></blockquote><p>在使用MIME时发送方会在邮件头部增加附加行 这一行将会指明这个报文遵循的MIME格式 数据类型和编码算法</p><p>比如 MIME-Version:1.0 </p><p>MIME还允许发送方将报文分成多个部分(它们可以使用不一样的编码方法) 实际上就是 粘贴多个附件</p><h3 id="MIME具有-兼容性「SMTP不需要解析MIME的编码-所以和早期的SMTP兼容」-和-灵活性「不规定编码方法和名称-」"><a href="#MIME具有-兼容性「SMTP不需要解析MIME的编码-所以和早期的SMTP兼容」-和-灵活性「不规定编码方法和名称-」" class="headerlink" title="MIME具有 兼容性「SMTP不需要解析MIME的编码 所以和早期的SMTP兼容」 和 灵活性「不规定编码方法和名称 」"></a>MIME具有 兼容性「SMTP不需要解析MIME的编码 所以和早期的SMTP兼容」 和 灵活性「不规定编码方法和名称 」</h3><hr><blockquote><p><strong>1、为什么说电子邮件的使用超过了因特网的范围</strong></p><p>电子邮件用户计算机完全可以不是Internet用户(没有因特网域名或IP地址) 而可以是在某个Internet计算机上注册了邮箱的普通计算机。 甚至还可以只和本地的传输邮件。</p></blockquote><blockquote><p><strong>2、当你发送电子邮件给不同电子邮局用户时，需要经过哪些必要的环节?请画图 示意。</strong></p></blockquote><blockquote><p><strong>3、早期电子邮件直接在收发计算机之间传输完成，试说明这种模式的优缺点。</strong></p><p>优点：效率高 是即时的传输 实现简单</p><p>缺点：</p><ol><li><p>接收的计算机需要开着(并且要么连接互联网，要么和发送计算机直接相连)， 这意味着接收方需要事先知道要接收邮件，也就丧失了邮件系统的非实时性。</p></li><li><p>常用的个人计算机无法配置邮件服务器，这使得利用邮件服务器完成的功能(如 分发 转发 列表) 收发计算机都无法完成，使得邮件系统可用性大幅下降</p></li></ol></blockquote><blockquote><p><strong>4、通过目前电子邮件系统发往某邮件，常常发现传输时间是不确定的，有时快而 有时慢，为什么?</strong></p><p>因为用户邮件在发端是定时扫描、建立连接和批处理传输的；且发送到目的邮局服务器的邮箱后，需要用户登陆后取回；即E-mail系统工作过程不是一个实际收发的端到端连接通信，而是中间邮局的非实时处理，所以邮件传递快慢取决于个环节等待时间。</p></blockquote><blockquote><p> <strong>5、一个组织的电子邮件系统网关，通常具有什么功能</strong></p><ol><li>分发和管理组织内的电子邮件地址和电子邮箱</li><li>实现组织内部和组织内外之间进行大批量邮件分发或转发功能</li><li>对邮件进行一定的过滤和筛选(去除垃圾和病毒邮件)</li></ol></blockquote><blockquote><p><strong>6、SMTP的主要作用</strong></p><p>电子邮件客户软件定时扫描邮件暂存队列，有待发邮件时，SMTP客户和目的地计算机SMTP服务器建立TCP连接。然后SMTP协议进行通过ASCII码命令和应答逐步协商，最后客户发出邮件副本，服务器接收副本。</p></blockquote><blockquote><p><strong>7、POP的主要作用</strong> 见POP介绍</p></blockquote><blockquote><p><strong>8、SMTP可以传递非ASCII码信息吗</strong> 当然可以了。。MIME</p></blockquote><hr><h1 id="WWW-概述"><a href="#WWW-概述" class="headerlink" title="WWW 概述"></a>WWW 概述</h1><h2 id="World-Wide-Web-是Internet上最受欢迎-应用-其思路来自CERN-欧洲粒子物理研究中心"><a href="#World-Wide-Web-是Internet上最受欢迎-应用-其思路来自CERN-欧洲粒子物理研究中心" class="headerlink" title="World Wide Web 是Internet上最受欢迎 应用  其思路来自CERN(欧洲粒子物理研究中心)"></a>World Wide Web 是Internet上最受欢迎 应用  其思路来自CERN(欧洲粒子物理研究中心)</h2><p>Tim Berners-Lee 在1990年开发了第一个基于超文本的分布式信息系统  1991年Gopher在Internet上运行</p><p>第一个图形界面的浏览器产生于1993年「Mosaic」</p><p><strong>www的设计基于超文本 HTML HTTP和浏览器</strong></p><h2 id="超文本-一般文本-到其他文档的链接-「其数据结构是指针链接的-网状结构-⚠️和树状区分-」"><a href="#超文本-一般文本-到其他文档的链接-「其数据结构是指针链接的-网状结构-⚠️和树状区分-」" class="headerlink" title="超文本 &#x3D;  一般文本 + 到其他文档的链接 「其数据结构是指针链接的 网状结构(⚠️和树状区分)」"></a>超文本 &#x3D;  一般文本 + 到其他文档的链接 「其数据结构是指针链接的 网状结构(⚠️和树状区分)」</h2><ul><li><p>超媒体 $\Rightarrow$ 超文本 + 图像、声音、视频的链接 (即把超文本扩展为更多的媒体) 「它们被总称为 Web文档」</p><ul><li><em>所谓的 Web文档IE(也被称为HTML文档) $\Rightarrow$ 网页</em></li></ul></li><li><p><em><strong>超文本和超媒体 决定了WWW是 非线性、联想式的文档集合 和一个布满链接的信息网</strong></em></p></li><li><h3 id="所谓的-Web-指的是由超文本-连接而成的信息集合-而WWW则是指-在世界范围内分布的Web服务器的集合"><a href="#所谓的-Web-指的是由超文本-连接而成的信息集合-而WWW则是指-在世界范围内分布的Web服务器的集合" class="headerlink" title="所谓的 Web 指的是由超文本 连接而成的信息集合  而WWW则是指 在世界范围内分布的Web服务器的集合"></a>所谓的 Web 指的是由超文本 连接而成的信息集合  而WWW则是指 在世界范围内分布的Web服务器的集合</h3><ul><li>WWW &#x3D;&gt; 建立在超文本和超媒体基础上的 全球分布的 <strong>在线式</strong>的信息网 (这一概念有时会和Web混用)</li><li>Web服务器同时也集成了E-Mail FTP TELNET等服务</li></ul></li></ul><h2 id="HTML-Hypertext-MakeUp-Language-超文本标记语言-用来创建和识别标准的-Web文档"><a href="#HTML-Hypertext-MakeUp-Language-超文本标记语言-用来创建和识别标准的-Web文档" class="headerlink" title="HTML Hypertext MakeUp Language 超文本标记语言      用来创建和识别标准的 Web文档"></a>HTML Hypertext MakeUp Language 超文本标记语言      用来创建和识别标准的 Web文档</h2><ul><li><h3 id="标记语言-Rightarrow-在文本中嵌入一系列-控制符号-使得文件按照作者的想法-显示或者打印"><a href="#标记语言-Rightarrow-在文本中嵌入一系列-控制符号-使得文件按照作者的想法-显示或者打印" class="headerlink" title="标记语言 $\Rightarrow$ 在文本中嵌入一系列 控制符号 使得文件按照作者的想法 显示或者打印"></a>标记语言 $\Rightarrow$ 在文本中嵌入一系列 控制符号 使得文件按照作者的想法 显示或者打印</h3></li><li><h3 id="HTML和普通的标记语言区别-Rightarrow-在它们的基础上-扩展了-超文本引用-通过点击实现自动跳转"><a href="#HTML和普通的标记语言区别-Rightarrow-在它们的基础上-扩展了-超文本引用-通过点击实现自动跳转" class="headerlink" title="HTML和普通的标记语言区别$\Rightarrow$在它们的基础上 扩展了 超文本引用(通过点击实现自动跳转)"></a>HTML和普通的标记语言区别$\Rightarrow$在它们的基础上 扩展了 <strong><u><em>超文本引用</em></u></strong>(通过点击实现自动跳转)</h3></li><li><p>「Web文档的格式 一般情况下 就是 HTML格式  当然也支持HTML以外的格式」</p><ul><li>超文本引用的原理：文本中被预先设置指向另一个文档的被动指针(被动是指 需要用户主动选择)</li><li><strong><em>任何内容</em>都可以作为超文本引用可选项</strong>(声音 图像也是可以的) 而这种机制 被称为 anchor <em><strong>锚</strong></em></li></ul></li><li><p>当然 除了利用<strong>超文本引用</strong>来实现定位之外  URL的应用也十分广泛</p></li></ul><h2 id="通过-URL-Uniform-精确-Resource-Locater-实现网页的定位-「见sp-edition-互联网传奇」"><a href="#通过-URL-Uniform-精确-Resource-Locater-实现网页的定位-「见sp-edition-互联网传奇」" class="headerlink" title="通过 URL Uniform(精确) Resource Locater 实现网页的定位 「见sp edition 互联网传奇」"></a>通过 URL Uniform(精确) Resource Locater 实现网页的定位 「见sp edition 互联网传奇」</h2><p>找到存放Web的计算机 $\Rightarrow$ 找到是这个计算机中存放的哪个网页 $\Rightarrow$ 确认访问此网页需要的协议 $\Rightarrow$ 对接网页显示的格式</p><p>URL的一般格式：</p><p>$$<br>协议:&#x2F;&#x2F;计算机域名:端口号(optional)&#x2F;路径&#x2F;Web文档名称<br>$$<br>「端口号 http&#x2F;Web &#x3D;&gt; 80 ； FTP &#x3D;&gt; 21 在采用默认端口号时 可以省略」</p><p><em><strong>值得注意的是 虽然URL输入时 可以大小写， 但实际上URL不区分大小写</strong></em></p><p><strong>使用URL定位时 因为必须指明特定的主机 如果访问量太大 会炸。 这时只能 就近访问和负载均衡。 而正在发展的URI(Universal Resource Indentifier) 尝试将资源名称和主机位置分离开</strong></p><h2 id="网页传输-和-HTTP-协议"><a href="#网页传输-和-HTTP-协议" class="headerlink" title="网页传输 和 HTTP 协议"></a>网页传输 和 HTTP 协议</h2><h3 id="我们先把浏览器和客户等同起来，-这时浏览器和Web服务器的交流就属于典型的C-S模式-但连接时间短-不记忆状态"><a href="#我们先把浏览器和客户等同起来，-这时浏览器和Web服务器的交流就属于典型的C-S模式-但连接时间短-不记忆状态" class="headerlink" title="我们先把浏览器和客户等同起来， 这时浏览器和Web服务器的交流就属于典型的C&#x2F;S模式(但连接时间短 不记忆状态)"></a>我们先把浏览器和客户等同起来， 这时浏览器和Web服务器的交流就属于典型的C&#x2F;S模式(但连接时间短 不记忆状态)</h3><blockquote><ul><li>浏览器作为客户 根据URL指定的域名 向DNS服务器请求解析 $\Rightarrow$ 得到目的IP地址</li><li>浏览器作为客户 和目的IP对应的计算机(和这个计算机上的 Web服务器) 建立TCP连接</li><li>浏览器作为客户 向Web服务器发送请求获取Web文档命令 (GET)</li><li>Web服务器响应请求 然后返回网页(Web文档)</li><li>浏览器接收完成并释放TCP连接， 在这之后显示网页</li></ul><p>我们也把HTTP的这种连接方式称为 「无状态连接」它可以实现快速的传输和调用 缺点在于如果访问同一个计算机上的多个网页，需要多次连接 产生额外的开销</p></blockquote><h3 id="HTTP的请求和响应格式"><a href="#HTTP的请求和响应格式" class="headerlink" title="HTTP的请求和响应格式"></a>HTTP的请求和响应格式</h3><p>这是一条HTTP请求命令</p><p>以下是HTTP的某些响应命令</p><h3 id="HTTP具有以下的特点"><a href="#HTTP具有以下的特点" class="headerlink" title="HTTP具有以下的特点"></a>HTTP具有以下的特点</h3><blockquote><ol><li><h4 id="可以-高速处理-大量请求。-「包含6种请求方式-URL格式化信息-服务器简单应答」-从开销上看HTTP优于FTP"><a href="#可以-高速处理-大量请求。-「包含6种请求方式-URL格式化信息-服务器简单应答」-从开销上看HTTP优于FTP" class="headerlink" title="可以 高速处理 大量请求。 「包含6种请求方式(URL格式化信息) 服务器简单应答」  (从开销上看HTTP优于FTP)"></a>可以 高速处理 大量请求。 「包含6种请求方式(URL格式化信息) 服务器简单应答」  (<strong>从开销上看HTTP优于FTP</strong>)</h4></li><li><h4 id="可以传输任意类型的数据-并且-采用-C-S模式-支持全球访问-支持所有的超文本和超媒体"><a href="#可以传输任意类型的数据-并且-采用-C-S模式-支持全球访问-支持所有的超文本和超媒体" class="headerlink" title="可以传输任意类型的数据 并且 采用 C&#x2F;S模式 支持全球访问    支持所有的超文本和超媒体"></a>可以传输任意类型的数据 并且 采用 C&#x2F;S模式 支持全球访问    支持所有的超文本和超媒体</h4></li><li><h4 id="短连接-无状态-「一次请求-一次应答-并不记忆任何状态」"><a href="#短连接-无状态-「一次请求-一次应答-并不记忆任何状态」" class="headerlink" title="短连接 + 无状态 「一次请求 一次应答 并不记忆任何状态」"></a>短连接 + 无状态 「一次请求 一次应答 并不记忆任何状态」</h4></li><li><h4 id="可协商。-客户请求可以指明可接受的响应类型。"><a href="#可协商。-客户请求可以指明可接受的响应类型。" class="headerlink" title="可协商。 客户请求可以指明可接受的响应类型。"></a>可协商。 客户请求可以指明可接受的响应类型。</h4></li></ol></blockquote><h2 id="分布式Web-普通-与非分布式Web-公司内-｜-Web代理服务"><a href="#分布式Web-普通-与非分布式Web-公司内-｜-Web代理服务" class="headerlink" title="分布式Web(普通)与非分布式Web(公司内) ｜  Web代理服务"></a>分布式Web(普通)与非分布式Web(公司内) ｜  Web代理服务</h2><p>普通的Web文档被存放在不同的计算机上 由不同人员独立管理 由于管理人员之间信息不一定互通 所以可能会出现无效网页 错误定位等意外情况。</p><p><strong>而非分布式的 Web系统会将每个Web文档集中存放在某个计算机上，其Web文档的超链接也是本地的 并且由专门的人员统一管理， 相比分布式Web 更能保证链接的有效性和一致性</strong></p><h3 id="Web代理服务-「大量的Web访问可能占满Internet的带宽-所以做一个cache」"><a href="#Web代理服务-「大量的Web访问可能占满Internet的带宽-所以做一个cache」" class="headerlink" title="Web代理服务 「大量的Web访问可能占满Internet的带宽 所以做一个cache」"></a>Web代理服务 「大量的Web访问可能占满Internet的带宽 所以做一个cache」</h3><p>Web Proxy&#x2F;Cache Server 会用一个高速缓存存储被大量访问的Web文档</p><p>如果你连接了校园网 一般在访问WWW时 先被校园网出口的路由器重定向到Web Cache 如果里面没有再进行访问(同时把结果存在Proxy中)</p><h2 id="浏览器-Browser-Web系统最重要部分-是用户进入Internet的主要入口「本质上是Web系统的客户端」"><a href="#浏览器-Browser-Web系统最重要部分-是用户进入Internet的主要入口「本质上是Web系统的客户端」" class="headerlink" title="浏览器 Browser  Web系统最重要部分 是用户进入Internet的主要入口「本质上是Web系统的客户端」"></a>浏览器 Browser  Web系统最重要部分 是用户进入Internet的主要入口「本质上是Web系统的客户端」</h2><h3 id="浏览器实现的功能-「为了满足多功能客户端桌面的需求-」"><a href="#浏览器实现的功能-「为了满足多功能客户端桌面的需求-」" class="headerlink" title="浏览器实现的功能 「为了满足多功能客户端桌面的需求 」"></a>浏览器实现的功能 「为了满足多功能客户端桌面的需求 」</h3><blockquote><ol><li>网页浏览</li><li>作为HTTP客户 通过TCP&#x2F;IP网络 完成用户对选择URL的请求和文档接受</li><li>解析Web文档(HTML文档)  这个功能也包括控制外设来显示这个Web文档</li><li>提供额外的服务 支持多格式文档(比如flash服务)  从实际设计角度上看 Browser甚至比Web服务器更加的复杂</li></ol><ul><li>这一项同时也意味着 浏览器可以包含支持其他服务的客户端软件(FTP&#x2F;E-Mail等)</li><li>所以 Browser&#x2F;Web Server 「B&#x2F;S」已经逐渐发展为互联网应用的统一形式</li></ul></blockquote><h2 id="Web体系结构-｜-Browser-Web-Server模式-B-S模式｜Web技术的发展"><a href="#Web体系结构-｜-Browser-Web-Server模式-B-S模式｜Web技术的发展" class="headerlink" title="Web体系结构 ｜ Browser&#x2F;Web Server模式 B&#x2F;S模式｜Web技术的发展"></a>Web体系结构 ｜ Browser&#x2F;Web Server模式 B&#x2F;S模式｜Web技术的发展</h2><p>浏览器通过URL 在TCP基础上 HTTP协议规定B&#x2F;S之间遵循的规则和需要进行的操作</p><p><strong><u>这也体现出WWW的核心： 超文本｜HTML&#x2F;URL结构｜HTTP｜浏览器</u></strong></p><h3 id="B-S体系结构-是作为C-S的后继发展类型"><a href="#B-S体系结构-是作为C-S的后继发展类型" class="headerlink" title="B&#x2F;S体系结构    是作为C&#x2F;S的后继发展类型"></a>B&#x2F;S体系结构    是作为C&#x2F;S的后继发展类型</h3><p>Browser在90年代中期开始逐渐成为主流 其客户端采用标准化浏览器(Java虚拟机 多媒体解析显示+简单逻辑操作)</p><p>Web服务器要做的事 解决应用开发 逻辑计算 网页封装和管理 使网络应用系统的升级 扩展和维护更加方便</p><p>在现在的B&#x2F;S服务器端 Web服务器演变为新的 <strong>MVC</strong>结构「WebSever+应用服务器+数据库服务器」</p><p>M $\Rightarrow$ 业务逻辑   V $\Rightarrow$ 展示    C $\Rightarrow$ 控制  这种结构是目前电子商务、政务广泛流行的架构</p><h3 id="Web技术的发展"><a href="#Web技术的发展" class="headerlink" title="Web技术的发展"></a>Web技术的发展</h3><h4 id="1-HTML-Rightarrow-XML-表示数据时-HTML的个性化不够-所以需要建立一种具有理解数据格式和结构的规则和方法"><a href="#1-HTML-Rightarrow-XML-表示数据时-HTML的个性化不够-所以需要建立一种具有理解数据格式和结构的规则和方法" class="headerlink" title="1. HTML $\Rightarrow$ XML  表示数据时 HTML的个性化不够 所以需要建立一种具有理解数据格式和结构的规则和方法"></a>1. HTML $\Rightarrow$ XML  表示数据时 HTML的个性化不够 所以需要建立一种具有理解数据格式和结构的规则和方法</h4><h4 id="2-Web2-0和语义Web"><a href="#2-Web2-0和语义Web" class="headerlink" title="2. Web2.0和语义Web"></a>2. Web2.0和语义Web</h4><hr><blockquote><p><strong>什么是超媒体、HTML 与Web？</strong></p><p>超媒体：在超文本中加入了图像、声音和视频的链接。可调出指针指向多媒体的信息</p><p>HTML：超文本标记语言，在普通标记语言的基础上扩展了超文本引用</p><p>Web：由超文本(超媒体)连接而成的信息集合</p></blockquote><blockquote><p><strong>为什么有时链接打开一个网页会发现无效？</strong></p><p>WWW是基于互联网的分布式的超媒体(超文本), 每个Web文档存放在不同的计算机上，并由不同的人员独立管理，其修改、删除、增加或者重命名等不会(实际上是无法) 通知相连的其他节点。因此会出现链接无效 或者链接不一致的情况。</p></blockquote><blockquote><p><strong>如何区分分布式Web和非分布式Web系统，试说明两者的可能的应用场合。</strong></p><p>相比分布式Web系统，非分布式Web系统将所有的Web文档集中存放在某一个计算机上，通常通常其Web文档的超链也是本地的，并由专门人员统一管理，能够很好的保持链接的一致性和有效性。</p><p>分布式的Web将Web服务器散布在Internet的各处，所有Internet上的Web服务器构成了万维网，是Internet上最受欢迎的应用，</p><p>非分布式的Web系统可以应用在公司或组织的内部资料库中，由专门的人员管理，也只有公司本地网段的计算机可以访问。</p></blockquote><blockquote><p><strong>试说明C&#x2F;S结构和B&#x2F;S结构的异同。</strong></p><p>B&#x2F;S结构是由C&#x2F;S结构演变而来的，采用了客户层｜中间层｜服务器 的三层结构，是基于WWW产生的。</p><p>不同之处：</p><p>B&#x2F;S的设计目的是为了满足接入Internet的普通用户需求，而C&#x2F;S则更多的由专业用户使用，同时有一定的门槛</p><p>B&#x2F;S建立在WWW(Internet)上，而C&#x2F;S则常常被部署在局域网上</p><p>B&#x2F;S的兼容性强 部署容易，而C&#x2F;S的部署比较复杂</p><p>B&#x2F;S系统的开发和维护开销都比较小，而C&#x2F;S相对来说更大一些</p><p>B&#x2F;S建立在广域网上，相比C&#x2F;S结构对于安全性的要求更低</p></blockquote><blockquote><p><strong>B&#x2F;S架构是互联网应用基本形式，什么类应用不适合B&#x2F;S架构？</strong></p><p>B&#x2F;S的架构开发和维护都相对简单 但由于是基于WWW而设计，只需要和本地服务器交互，不需要连接互联网的应用，不适合用B&#x2F;S架构。</p><p>另外，由于其无状态连接的特点，需要点对点高强度交互的应用，不适合使用B&#x2F;S架构。</p><p>虽然浏览器的功能非常强大，但如果用户需要某些特定的功能(比如游玩大型的网络游戏)，就需要专门的客户端软件，而不适合B&#x2F;S架构。</p></blockquote><hr><h2 id="Chapter2-DNS"><a href="#Chapter2-DNS" class="headerlink" title="Chapter2 DNS"></a>Chapter2 DNS</h2><h2 id="域名服务系统-DNS-Domain-Name-System"><a href="#域名服务系统-DNS-Domain-Name-System" class="headerlink" title="域名服务系统 DNS[Domain Name System]"></a>域名服务系统 DNS[Domain Name System]</h2><h3 id="DNS系统概述"><a href="#DNS系统概述" class="headerlink" title="DNS系统概述"></a>DNS系统概述</h3><p>我们显然可以通过输入 IP地址来访问网站。 使用DNS只是为了 让字符化的计算机域名 能够起到 特征标示的作用。</p><p><em><strong>DNS 的作用是 将 用户使用的域名 和 计算机使用的IP地址 互相转换(translation)</strong></em></p><p><strong>备注：</strong></p><p><strong>1. DNS 同时也表示 Domain Name Server</strong></p><p><strong>2. DNS所实现的转换是 双向的</strong></p><p><strong>3. 域名的翻译是自动完成的 依赖分布在全球的一系列服务器完成， DNS实现的翻译 属于C&#x2F;S交互</strong></p><h3 id="Internet-域名构造"><a href="#Internet-域名构造" class="headerlink" title="Internet 域名构造"></a>Internet 域名构造</h3><p><strong>因特网将这些域名划分成 树状体系 最高级的域名一般是通用域名&#x2F;国家&#x2F;基础结构域类。 在这些最高级域名下划分子类 逐渐延伸</strong></p><p>我们的高级域名<code>.cn</code> 之下 定义了7个2级域名 ac(研究机构)  comedugovmilnetorg以及34个行政区域名</p><p><strong>如果你想要使用最高级域名， 必须向Internet管理机构ICANN(或其授权管理机构 比如中国的CCNIC)登记，层层递进</strong></p><h3 id="DNS层次结构和服务器分布模型"><a href="#DNS层次结构和服务器分布模型" class="headerlink" title="DNS层次结构和服务器分布模型"></a>DNS层次结构和服务器分布模型</h3><ul><li>每个DNS服务器 都是域名体系中部分域名的实际管理者，要负责具有某后缀的所有计算机权威管理</li><li>每个计算机域名也必须在对应的DNS组织(服务器)登记</li><li>DNS具有命名 和 服务器设置的 自治性</li><li>每个DNS服务器 只能完成部分计算机域名的处理，因此因特网所有的DNS服务器宏观上被连接成了一个系统。<ul><li>这意味着：<strong>每个DNS服务器都知道如何找到根DNS服务器，以及如何找到下级的DNS服务器</strong></li></ul></li><li>对大型组织集中单一DNS服务很困难。但由于DNS服务具有 <strong>局部访问性原理</strong> 我们可以按照层次制定分布DNS服务策略</li></ul><h3 id="DNS记录和协议报文格式"><a href="#DNS记录和协议报文格式" class="headerlink" title="DNS记录和协议报文格式"></a>DNS记录和协议报文格式</h3><h5 id="DNS的拓扑"><a href="#DNS的拓扑" class="headerlink" title="DNS的拓扑"></a>DNS的拓扑</h5><p>一般组织使用单一DNS服务器，小型公司作为用户，和提供DNS的ISP连接，DNS服务也由和其连接的ISP完成</p><hr><blockquote><p><strong>试解释中文域名可能的工作原理</strong></p><p>我认为现在的DNS系统已经比较成熟，所以中文域名的工作可以从从用户角度入手，即将用户输入的中文域名，翻译成英文域名，然后接入现有的DNS体系框架内。</p><p>在用户使用的浏览器中添加扩展，使得浏览器能够实现汉字输入转换，并考虑使用缺省和机器学习来优化</p><p>如输入 百度 则浏览器转化为 <a href="https://www.baidu.com/">https://www.baidu.com</a> 实际上仍然使用现有的DNS服务</p></blockquote><blockquote><p><strong>试说明DNS服务器怎样获取请求客户主机域名的？</strong></p><ol><li>客户机想要查询时首先在本地计算机缓存中查找，如果无法获得查询信息，则向本地DNS服务器发送查询请求</li><li>本地DNS服务器收到请求，首先在其管理区域记录里查询，如果找到了，则直接解析并返回，没找到则执行3</li><li>本地DNS服务器将客户的请求发送到根域名DNS服务器。根域名服务器解析请求的根域部分，并以此获知管理下一级域名的DNS服务器地址，并将这个地址返回给本地DNS服务器。</li><li>本地DNS服务器利用上一级域名服务器给出的地址访问下一级DNS服务器，得到更下一级的DNS服务器地址，同样，这个地址被返回给本地DNS服务器。</li><li>返回递归执行步骤4 直到本地DNS服务器获取到知道域名对应IP的DNS服务器传回的IP地址</li><li>本地DNS服务器将查询结果返回客户 完成解析过程</li></ol><p><strong>两个DNS服务器包含完全相同的域名有意义吗？为什么？</strong></p><p>是有意义的。因为DNS的解析是递归的过程，如果有两个不同的DNS服务器都包含这个域名，说不定可以减少递归的次数，提高DNS服务的效率。</p><p><strong>试分析DNS体系的层次数对域名解析速度是否有影响？</strong></p><p><strong>有影响</strong>。如果你要访问的域名离自己的本地DNS服务器太远，你的访问请求将被迫一级一级的不断上传，同时一级一级的向下返回，虽然传输的时延不长，但处理和排队的时延累加起来就很长了。比如我们访问国外的网站，即使没有被屏蔽也会很慢。</p><p><strong>DNS系统为什么要优化，优化措施主要有哪些？</strong></p><p><strong>无论是递归还是迭代</strong>的请求方式，本质上其实<strong>效率都很糟糕</strong>，特别是根服务器的负载非常大，并且根服务器作为枢纽一旦下线，非本地访问的DNS服务几乎就中断了。</p><h5 id="但由于一台计算机经常访问本地域名或重复访问同样的域名，所以可以进行以下的优化处理："><a href="#但由于一台计算机经常访问本地域名或重复访问同样的域名，所以可以进行以下的优化处理：" class="headerlink" title="但由于一台计算机经常访问本地域名或重复访问同样的域名，所以可以进行以下的优化处理："></a>但由于一台计算机经常访问本地域名或重复访问同样的域名，所以可以进行以下的优化处理：</h5><ol><li>复制。复制多个根服务器副本，按照地域分布，实现就地DNS域名服务</li><li>缓存。每次查找新域名 本地DNS服务器将地址联编副本进行缓存 实际上客户的浏览器也有类似的 域名缓存措施</li></ol></blockquote><hr><h1 id="Chapter3-FTP-File-Transfer-Protocol"><a href="#Chapter3-FTP-File-Transfer-Protocol" class="headerlink" title="Chapter3 FTP [File Transfer Protocol]"></a>Chapter3 FTP [File Transfer Protocol]</h1><h3 id="FTP-概述"><a href="#FTP-概述" class="headerlink" title="FTP 概述"></a>FTP 概述</h3><p>FTP的产生 $\rightarrow$ 早期Internet(ARPANET) 的工作主要是 信息交互 (特别是文件交互共享)</p><p><strong>从历史上讲 FTP的产生要早于TCP (现在则是使用新的FTP协议 ) 在95年之前 FTP占据因特网通信量的 1&#x2F;3</strong></p><h2 id="FTP需要解决-在异构计算机之间的-通用文件传递-这需要克服不同文件系统的差异："><a href="#FTP需要解决-在异构计算机之间的-通用文件传递-这需要克服不同文件系统的差异：" class="headerlink" title="FTP需要解决 在异构计算机之间的 通用文件传递 这需要克服不同文件系统的差异："></a>FTP需要解决 在<em><strong>异构计算机之间的 通用文件传递</strong></em> 这需要克服不同文件系统的差异：</h2><ol><li>通用性 </li><li>跨平台特性</li><li>传输和控制 $\rightarrow$ 控制 上传 下载</li><li><strong>FTP可以支持 任意类型的数据文件</strong></li><li>FTP可以加密 可以控制访问</li></ol><h5 id="FTP主要提供2种交互方式-即-实时交互-和-批处理"><a href="#FTP主要提供2种交互方式-即-实时交互-和-批处理" class="headerlink" title="FTP主要提供2种交互方式 即  实时交互 和 批处理"></a>FTP主要提供2种交互方式 即  实时交互 和 批处理</h5><p>值得注意的是 可以建立一种 同时实现两种方式的 服务</p><h2 id="FTP只有-文本-和-binary-两种格式「FTP传输的是-文件的副本-而不是文件本身」"><a href="#FTP只有-文本-和-binary-两种格式「FTP传输的是-文件的副本-而不是文件本身」" class="headerlink" title="FTP只有 文本 和 binary 两种格式「FTP传输的是 文件的副本 而不是文件本身」"></a>FTP只有 文本 和 binary 两种格式「<em><strong>FTP传输的是 文件的副本 而不是文件本身</strong></em>」</h2><p>视频 浮点数 图形… 只要不是文本 全部都使用binary 传输</p><p>当然 二进制会出现在FTP两边格式不一样的情况 这FTP不管</p><h3 id="FTP工作原理-「两条连接-控制和数据传输分离」"><a href="#FTP工作原理-「两条连接-控制和数据传输分离」" class="headerlink" title="FTP工作原理 「两条连接 控制和数据传输分离」"></a>FTP工作原理 「两条连接 控制和数据传输分离」</h3><p><strong>两端的进程会分别启动 控制和数据传送进程(它们是主进程的从属进程 并且相互独立)</strong></p><ol><li><strong>客户通过临时端口号N 和 FTP服务器(端口号 21 这是个熟知端口)  建立TCP链接</strong><ul><li><strong>这条连接 只是用来控制 由客户发起 服务器接受。 客户端输入的命令从这里发到服务器中</strong></li></ul></li><li><strong>服务器并不会马上 建立传输连接，而是在客户发起命令 确认一个文件之后</strong> </li><li><strong>服务器通过 <em>端口号20</em> 与<em>客户端口号N+1</em> 建立TCP连接</strong><ul><li>*<em>这条连接 只是用来传输 <em>由服务器发起 也会由服务器结束</em>。</em>*</li></ul></li></ol><h3 id="FTP交互方式的特点"><a href="#FTP交互方式的特点" class="headerlink" title="FTP交互方式的特点"></a>FTP交互方式的特点</h3><ol><li>两个不同的端口号分别建立控制连接和数据连接 目的是让命令交互 和 文件数据交互 之间不互相干扰</li><li>服务器在完成文件传递后 关闭数据连接 给客户端一个 文件结束条件</li><li>FTP命令可以控制远程计算机上的文件操作 就好像在操作本地文件一样</li></ol><h3 id="FTP登陆-和-常用命令"><a href="#FTP登陆-和-常用命令" class="headerlink" title="FTP登陆 和 常用命令"></a>FTP登陆 和 常用命令</h3><ol><li>输入 Open计算机域名 和这个计算机建立TCP连接。 使用Close 来关闭连接(并不是关闭FTP程序！)</li><li>对于私有的FTP服务 需要输入用户名+口令； 而有些开放的FTP服务 使用anonymous(guest) &#x2F; 电邮账户 即可实现访问了</li></ol><p><strong>FTP 一般使用命令行进行交互 客户端有约50条命令</strong></p><p>通用标准化处理(解决跨平台(OS)传输)</p><p>我们想要做到OS对FTP的C&#x2F;S透明。因此定义了 <strong>Telnet NVT(Network Vietual Terminal)网络虚拟终端</strong></p><p>这样 FTP和OS就不进行直接的交互了 而是通过NVT标准格式接口 在传输过程中 实际上就是</p><p>本地终端格式 $\rightarrow$转换为 NVT格式 $\rightarrow$ 传输 $\rightarrow$ NVT转换为本地主机格式 $\rightarrow$ 本地主机格式</p><p>NVT格式 统一使用8bit通信 7位ASCII码 最高位 为1 $\rightarrow$ 控制命令</p><h3 id="NFS-Network-File-System"><a href="#NFS-Network-File-System" class="headerlink" title="NFS(Network File System)"></a>NFS(Network File System)</h3><p>一般被集成在一个大的文件系统里</p><p>和FTP类似 但不传输文件副本 一般只传递 复制&#x2F;改变 文件的小片段</p><p>使用TCP和UDP 实现不同操作系统的各种终端和主机间远程登录和文件命令操作</p><blockquote><p><strong>1、怎样理解NVT？</strong></p></blockquote><blockquote><p><strong>2、FTP目前主要使用在什么场合，为什么不十分流行？</strong></p><p>FTP目前一般在公司或单位的内部进行公开的文件传输时使用。</p><p>不流行的原因：<br>\1. 使用命令行进行交互 没有图形界面 这意味着使用FTP的门槛要更高。</p><p>\2. 安全性不够高，FTP的信息在信道上可能被劫持 这样信息就全部泄漏了。</p><p>\3. FTP诞生时间太早，不适合现在的网络架构。使用两条TCP连接比较浪费，虽然是稳定的传输，但效率不够高，会浪费一些网络资源。</p></blockquote><blockquote><p><strong>3、在一条传输链路连接的网络两端，用FTP传输一个大文件，然后根据文件字节数和传输的时间测量链路的数据传输容量，是否准确？试说明理由。</strong></p><p>不准确。因为FTP的底层是TCP传输(TCP传输又需要进行IP层的封装)，这意味着大文件 会被封装成TCP报文段。大文件长度很可能大大超过了MTU，这意味着需要很多个TCP报文段来传输这个文件。如果只算文件字节数而忽略TCP报文头和IP报文头，算出的数据传输容量会有较大的偏差(会偏小)。</p></blockquote><blockquote><p><strong>4、二进制模式和文本模式下传输同一个文本文件，试说明两种模式传输时间哪个大？为什么？</strong></p><p>文本模式下 会花费更长时间。 FTP的文本使用ASCII&#x2F;EBCDIC 字符集，在FTP发送和接收前需要经过转换(本地文本文件$\rightarrow$ ASCII&#x2F;EBCDIC $\rightarrow$ 本地文本文件)，并且还需要加入控制字符。而二进制是不进行任何表达转换处理，直接传输文件副本。</p></blockquote><hr><h1 id="Chapter4-NAT-DHCP"><a href="#Chapter4-NAT-DHCP" class="headerlink" title="Chapter4 NAT&amp;DHCP"></a>Chapter4 NAT&amp;DHCP</h1><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>对于TCP&#x2F;IP的每一层， 有些是协议 有些是技术。</p><p>宏观来看，IPv4的地址空间不够用，导致了大量的问题</p><blockquote><p>IPv6 (128bits)</p><p>NAT &#x2F; Network Address Translation</p><p>VLSM 可变长 subnet mask</p><p>CIDR 无类域间路由</p></blockquote><h3 id="NAT-简介"><a href="#NAT-简介" class="headerlink" title="NAT 简介"></a>NAT 简介</h3><p>Network Address Translation 发明于1994年</p><p>其思路是 <strong>内网域内使用私有的IP地址空间</strong> 10网段 172.16网段 192.168网段</p><blockquote><p>10.0.0.0—10.255.255.255 A<br>172.16.0.0—172.31.255.255 B<br>192.168.0.0—192.168.255.255 C</p></blockquote><p>私有IP只在局域网里使用 互联网上不会出现这些ip</p><p>NAT的普及程度 $\rightarrow$ 70%的P2P用户位于NAT网关以内 由于P2P主要运行在PC上，这意味着大部分的PC都是通过NAT网关连接到Internet</p><ul><li>NAT技术没有公认的发明者</li></ul><h3 id="NAT工作模型"><a href="#NAT工作模型" class="headerlink" title="NAT工作模型"></a>NAT工作模型</h3><p>NAT 通常被部署在一个局域网的网络出口位置 通过**<u><em>将内部网络IP地址 替换成出口的IP地址</em></u><strong>提供</strong>公网可达性<strong>和</strong>上层协议连接能力**</p><p>目的$\rightarrow$提供一种虚拟的寻址机制</p><p>正常情况下 使用私有IP地址不需要向IANA提出申请 但是这些地址 不能作为源地址和目的地址</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul><li>在组织的出口部署 NAT gateway  其功能是：<ul><li>报文离开局域网进入Internet时 将源地址替换成公网地址(一般是出口设备的interface地址)</li><li>对访问目标来说，访问源地址自然就是NAT gateway，target会回复给NAT gateway</li><li>收到回复后 NAT gateway再把目的地址<strong>替换成私有IP地址</strong></li></ul></li><li>显然 对通信的双方来说 NAT gateway是<strong>透明</strong>的 数量庞大的内网主机 也不需要公有的IP地址了</li></ul><h4 id="注意⚠️"><a href="#注意⚠️" class="headerlink" title="注意⚠️"></a>注意⚠️</h4><ol><li><p>外网 一般无法通过IP地址访问内网主机 想要访问有两种方法</p></li><li><blockquote><p>一个全局地址 可以让不同PC同时访问<em><strong>不同</strong></em>服务器吗？$\rightarrow$ 可以 离开站点前的私有IP地址映射不一样</p><p><strong>一个全局地址 可以让不同PC同时访问<em>相同</em>服务器吗？$\rightarrow$ 不可以 因为在NAT Gateway收到服务器传回的报文时 不知道是哪个PC发送的(这个报文的源地址是服务器 目的地址是NAT Gateway的IP地址)</strong></p></blockquote></li><li><p>为实现双方的持续交流，NAT gateway需要维护一张关联表 $\rightarrow$ 地址转换表(translation table) 存储重写地址时所需的信息来实现地址转换 具体实现方法：</p><ul><li>当数据报离开站点 NAT将目的地址和发送方的私有地址记录在一起。</li><li>当数据报到达站点 NAT查询translation table 来确认哪台站内计算机接收这个相应。</li></ul></li><li><p>全局地址数量M一般远小于主机数 一个一般对应4000个内部地址</p><ul><li>内网轮流使用NAT地址池里的全局地址 当NAT地址池的全局地址被用完时 主机对外部的因特网访问将必须等待</li></ul></li><li><p>NAT gateway对交流双方是透明的</p></li></ol><h3 id="NAPT-网络地址与端口转换"><a href="#NAPT-网络地址与端口转换" class="headerlink" title="NAPT 网络地址与端口转换"></a>NAPT 网络地址与端口转换</h3><p>与NAT的区别在于 NAT是一对一转换 而NAPT则在转换时把端口号也作为参数 实现多对一转换</p><p>用于以下的两种情况 解决了 收到应答不知道给谁的问题。</p><blockquote><p>内网里两台不同主机 要同一时间 访问同一个服务器 </p><p>内网里 一台主机的 多个不同进程 要同时访问同一个服务器</p></blockquote><p>生成一个本地的端口号(临时生成 只用来区分不同主机或进程)</p><h5 id="NAPT的负载均衡器功能"><a href="#NAPT的负载均衡器功能" class="headerlink" title="NAPT的负载均衡器功能"></a>NAPT的负载均衡器功能</h5><p>外到内网服务器的访问 表的静态记录项 通过服务端口区分不同服务器的访问</p><p>接受外部主机的请求时 NAT根据已有的NAPT表 把全局地址翻译成不同内部地址 建立与多部主机的连接。根据NAPT表 转发数据包到多个内部服务器 实现服务器负载均衡(访问的是单个服务器 多个一起处理) 或不同服务器的访问</p><h5 id="外部通过NAT的访问内网-NART表项动态建立"><a href="#外部通过NAT的访问内网-NART表项动态建立" class="headerlink" title="外部通过NAT的访问内网 NART表项动态建立"></a>外部通过NAT的访问内网 NART表项动态建立</h5><p>如果是一般主机非固定的服务器，由于NAPT表中一般主机和NAT公有地址只是内到外访问时临时建立的，即NAPT表无法自动构建转换映射表，所以外部访问一般无法根据IP地址访问内网主机。一种方法通过域名访问，即建立内网域名DNS（二级域名）和NAT联用机制，由DNS触发建立NAT表的一个记录项。这时NAPT动态建立对应表项，IP地址利用率更高</p><h3 id="NAT的优缺点"><a href="#NAT的优缺点" class="headerlink" title="NAT的优缺点"></a>NAT的优缺点</h3><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><blockquote><p>节约Internet地址</p><p>解决相同IP地址的负载扩展(均衡)</p><p>消除重新编址 (现有方案能继续使用)</p></blockquote><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><blockquote><p>延迟增加</p><p>降低地址的 Traceability</p><p>某些应用功能交互更加复杂或失效(FTP TCP要解决NAT穿越问题 而要求特定的源端口和源地址的应用无法工作)</p></blockquote><hr><h2 id="因特网系统初始化设置-BOOTP-DHCP"><a href="#因特网系统初始化设置-BOOTP-DHCP" class="headerlink" title="因特网系统初始化设置 BOOTP &amp; DHCP"></a>因特网系统初始化设置 BOOTP &amp; DHCP</h2><ul><li>TCP&#x2F;IP 协议参数和配置 需要参数：<ul><li>硬件地址</li><li>使用协议类型</li><li>IP地址</li><li>默认IP路由器地址(下一跳地址)</li><li>地址掩码(地址类型)</li><li>DNS服务器地址</li></ul></li></ul><h5 id="协议配置-：-协议软件被-协议通用性原则-约束。-需要协议软件参数化，所以要在编译之前对参数赋值"><a href="#协议配置-：-协议软件被-协议通用性原则-约束。-需要协议软件参数化，所以要在编译之前对参数赋值" class="headerlink" title="协议配置 ： 协议软件被 协议通用性原则 约束。 需要协议软件参数化，所以要在编译之前对参数赋值"></a>协议配置 ： 协议软件被 协议通用性原则 约束。 需要协议软件参数化，所以要在编译之前对参数赋值</h5><p>如何配置协议？ <em><u><strong>在不知道IP地址情况下交流的核心思路$\rightarrow$使用广播</strong></u></em></p><blockquote><p>人工配置 手动录入(仍然是常用的方法)</p><p>存储文件配置 打开配置文件进行配置(因为系统只在启动时读取配置文件 所以修改参数配置需要重启)</p><p>自动协议配置 只要出现大量设备或者频繁修改 前两种几乎都行不通</p></blockquote><h5 id="自动协议配置方法"><a href="#自动协议配置方法" class="headerlink" title="自动协议配置方法"></a>自动协议配置方法</h5><p>要克服单机分散配置问题 在<strong>服务器端进行集中配置</strong> 然后通过请求&#x2F;应答形式 当计算机启动入网前发出请求 网络服务器返回适当配置响应</p><ol><li>配置协议前 使用RARP 用MAC多播(主要使用RARP的是无盘工作站 存储不了自己的IP地址 MAC地址在网卡上)</li><li>此时不知道默认网关 使用ICMP 掩码请求&#x2F;网关发现 用IP广播方式获取路由器参数(获取地址掩码&#x2F;默认网关地址)<ul><li><strong>地址屏蔽码</strong>(掩码)请求&#x2F;应答Address Mask Request&#x2F; Reply:主机启动时，会广播一个地址屏蔽码请求报文。服务器或路由器收到地址屏蔽码请求报文后，回送一个<strong>包含本网使用的32位地址屏蔽码</strong>的应答报文。</li></ul></li></ol><p><em>总的来说 协议从底层到高层进行配置 通过底层广播协议&#x2F;单播的方式逐步获得高层参数信息。</em></p><h5 id="自举的过程如下"><a href="#自举的过程如下" class="headerlink" title="自举的过程如下"></a>自举的过程如下</h5><blockquote><p>MAC 广播RARP request 获取IP地址</p><p>等待RARP reply 如果T1时间内无响应 返回1</p><p>广播ICMP地址掩码请求 获取IP地址掩码</p><p>等待回复 如果T2时间无响应 返回3</p><p>利用ICMP网关发现 找到默然路由器的IP地址 并将其加入路由表中</p></blockquote><p>可以注意到 需要至少3次分散的协议过程 会出现分散 延时 报文不同</p><h3 id="自举协议BOOTP-Bootstrap-Protocol"><a href="#自举协议BOOTP-Bootstrap-Protocol" class="headerlink" title="自举协议BOOTP(Bootstrap Protocol)"></a>自举协议BOOTP(Bootstrap Protocol)</h3><p>Bootstrap $\rightarrow$ pull or drag oneself by one’s own </p><h5 id="功能：一次广播一个BOOTP协议请求包-BOOTP服务器查找各项信息返回"><a href="#功能：一次广播一个BOOTP协议请求包-BOOTP服务器查找各项信息返回" class="headerlink" title="功能：一次广播一个BOOTP协议请求包 BOOTP服务器查找各项信息返回"></a>功能：一次广播一个BOOTP协议请求包 BOOTP服务器查找各项信息返回</h5><p><strong>注意： BOOTP协议由于尚未配置参数 所以进行了特殊的地址定义 IP广播地址全1 作为目的地址 全0作为源地址</strong></p><p><strong>BOOTP服务器可使用MAC地址进行单播(此时工作站还不知道自己的IP地址 所以IP单播无效) 或者全1广播地址回送 自举协议使用UDP发送(68&#x2F;67 端口)</strong></p><h5 id="自举协议的报文格式"><a href="#自举协议的报文格式" class="headerlink" title="自举协议的报文格式"></a>自举协议的报文格式</h5><h5 id="BOOTP的局限性"><a href="#BOOTP的局限性" class="headerlink" title="BOOTP的局限性"></a>BOOTP的局限性</h5><blockquote><p>在工作前 需要对BOOTP服务器上配置相关主机参数数据库 且是固定设置值。只能满足小区域固定IP配置和PC的静态接入网络需求。在大区域或不固定IP配置的情况下 很难实现。</p></blockquote><h3 id="DHCP-Dynamic-Host-Configuration-Protocol"><a href="#DHCP-Dynamic-Host-Configuration-Protocol" class="headerlink" title="DHCP&#x2F;Dynamic Host Configuration Protocol"></a>DHCP&#x2F;Dynamic Host Configuration Protocol</h3><p>1997年 IETF设计了动态主机配置协议 这个协议是在BOOTP基础上的扩展改进 </p><p><strong>DHCP的最大特点就是 可以自动获取IP地址分配(不固定)机制，也就是即插即用的联网</strong></p><blockquote><p>仍然使用IP广播地址全1作为目的地址 全0作为源地址 </p><p>DHCP服务器也可使用MAC地址进行单播 或者全1广播地址回送 (和BOOTP是一样的端口)</p><p>不同的是 如果有数据库中该主机的指定信息(这和BOOTP一致)就取出返回 <strong>如果没有(新增)从IP地址缓冲池动态选择一个IP地址分配给主机</strong></p></blockquote><h5 id="IP租借：由于DHCP是一个IP地址按需分配的-不固定机制-DHCP需要地址租期的概念。产生的地址在过了有效期-1s-136years-后就会被回收。"><a href="#IP租借：由于DHCP是一个IP地址按需分配的-不固定机制-DHCP需要地址租期的概念。产生的地址在过了有效期-1s-136years-后就会被回收。" class="headerlink" title="IP租借：由于DHCP是一个IP地址按需分配的 不固定机制 DHCP需要地址租期的概念。产生的地址在过了有效期(1s-136years)后就会被回收。"></a>IP租借：由于DHCP是一个IP地址按需分配的 不固定机制 DHCP需要地址租期的概念。产生的地址在过了有效期(1s-136years)后就会被回收。</h5><ul><li>DHCP通过IP地址缓冲池和租借IP按需分配的形式 形成对移动计算机入网的动态配置信息，不需要管理员对配置数据库进行任何修改。</li></ul><h5 id="DHCP优化"><a href="#DHCP优化" class="headerlink" title="DHCP优化"></a>DHCP优化</h5><blockquote><p>使用DHCP的主机首先随机广播发送 DHCP发现报文(短报) 减少冲撞的概率，在确认DHCP服务器后再发送请求报文。DHCP服务器地址通常会被永久保存，以后会单播(类似我们的记住已经连接过的WIFI密码)</p></blockquote><h5 id="DHCP中继"><a href="#DHCP中继" class="headerlink" title="DHCP中继"></a>DHCP中继</h5><blockquote><p>不是每个网络都需要DHCP服务器 设置一个DHCP中继 可以代理转发DHCP服务器的请求和响应(一般的路由器都有此功能)</p></blockquote><h5 id="DHCP使用和DHCP报文"><a href="#DHCP使用和DHCP报文" class="headerlink" title="DHCP使用和DHCP报文"></a>DHCP使用和DHCP报文</h5><blockquote><p>属性配置选择 $\rightarrow$ 固定IP地址&#x2F; 自动获取IP地址(选择这个就是使用DHCP)</p><p>DHCP报文和BOOTP差不多 添加了一个 FLAGS选项 让用户说明希望服务器使用广播应答还是直接应答</p></blockquote><p>由于DHCP和DNS系统不关联 对有域名计算机来说 IP地址和DNS域名的映射在从DHCP中自动获取新的IP后，计算机名字将会失效</p><hr><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="请简述自举配置协议BOOTP要解决什么问题？"><a href="#请简述自举配置协议BOOTP要解决什么问题？" class="headerlink" title="请简述自举配置协议BOOTP要解决什么问题？"></a><em><strong>请简述自举配置协议BOOTP要解决什么问题？</strong></em></h4><p>​BOOTP用于解决在自动配置协议时 需要发送多次不同协议报文带来的分散、时延等麻烦。通过广播 一次发送一个BOOTP请求包，由BOOTP服务器查找各项信息返回。</p><p><strong>标准答案：</strong></p><p><strong>第1发现协议地址，实际上我们还是可以通过RARP形式，在未知环境中获取本机参数；</strong></p><p><strong>第2获取配置服务器参数，实际上采用ICMP的掩码请求形式，以IP广播的方法请求获取</strong></p><h4 id="请简述DHCP-协议在BOOTP基础上主要改进了什么？。"><a href="#请简述DHCP-协议在BOOTP基础上主要改进了什么？。" class="headerlink" title="请简述DHCP 协议在BOOTP基础上主要改进了什么？。"></a><em><strong>请简述DHCP 协议在BOOTP基础上主要改进了什么？。</strong></em></h4><p>​DHCP可以自动获取IP地址分配(不固定)机制，也就是即插即用的联网。和BOOTP不同的地方在于，如果服务器数据库中没有发出请求的主机信息，DHCP能从IP地址缓冲池里动态选择一个IP地址分配给主机(在租期过后则回收这个地址)。</p><h4 id="请列出在使用BOOTP协议前，一台计算机在利用网络启动之前，必须在本地需要具有什么协议与参数。"><a href="#请列出在使用BOOTP协议前，一台计算机在利用网络启动之前，必须在本地需要具有什么协议与参数。" class="headerlink" title="请列出在使用BOOTP协议前，一台计算机在利用网络启动之前，必须在本地需要具有什么协议与参数。"></a><em><strong>请列出在使用BOOTP协议前，一台计算机在利用网络启动之前，必须在本地需要具有什么协议与参数。</strong></em></h4><p>​1.需要知道自己的MAC地址(硬件类型)</p><p>​2.需要支持RARP协议(能进行MAC广播)</p><p>​3.需要支持ICMP协议(用于获取地址掩码和找到默认路由)</p><p>​4.需要支持UDP协议(用于发送BOOTP数据包)</p><h4 id="比较使用绑定方案地址分配协议和DHCP动态地址分配协议，哪个更适用于广域网？"><a href="#比较使用绑定方案地址分配协议和DHCP动态地址分配协议，哪个更适用于广域网？" class="headerlink" title="比较使用绑定方案地址分配协议和DHCP动态地址分配协议，哪个更适用于广域网？"></a><em><strong>比较使用绑定方案地址分配协议和DHCP动态地址分配协议，哪个更适用于广域网？</strong></em></h4><p>​我认为DHCP动态地址分配协议更适合广域网。广域网区域大，而且用户变化大，静态的地址分配方案无法满足大量用户的需求，使用DHCP可以满足大量用户动态接入网络的需求，同时还能提高地址的利用率(不是每台主机都一直工作，如果静态分配会产生大量闲置时间)。与此同时，DHCP优化还可以减少发广播的次数。不管是从效率还是从可行性上看，都应该选择DHCP动态地址分配协议。</p><hr><h1 id="Chapter5-路由协议"><a href="#Chapter5-路由协议" class="headerlink" title="Chapter5 路由协议"></a>Chapter5 路由协议</h1><p>RIP BGP位于应用层</p><h5 id="3个概念：路由选择-路由协议-路由算法"><a href="#3个概念：路由选择-路由协议-路由算法" class="headerlink" title="3个概念：路由选择 路由协议 路由算法"></a>3个概念：路由选择 路由协议 路由算法</h5><p><strong>路由选择</strong>$\rightarrow$通过互连网络从源节点向目的节点传输信息的通道，且中间至少有一个中间节点</p><p><strong>路由协议</strong>$\rightarrow$路由指导IP数据报发送过程中事先约定好的规定和标准(规定了IP数据报在网络中存储和转发的方式)</p><p>​<em>路由协议决定了路由选择，而路由算法是路由协议的实现。</em></p><p>​<em>在一个Autonomous System内的路由协议被称为Interior Gateway Protocol</em></p><p>​<em>而AS之间的路由协议则是Exterior Gateway Protocol</em></p><p>​<em>内部网关协议：RIP IGRP EIGRP IS-IS OSPF</em></p><p>​<em>外部网关协议：EGP BGP</em></p><p><strong>路由算法</strong>$\rightarrow$提高路由协议的功能，尽量减少路由时带来的开销的算法</p><h2 id="分层的路由选择协议"><a href="#分层的路由选择协议" class="headerlink" title="分层的路由选择协议"></a>分层的路由选择协议</h2><p>实际上的Internet是由各个组织的自治域系统AS(Autonomous System)网络互连而成。</p><p>而作用在AS内部的 被称为内部网关协议IGP(RIP,OSPF)，外部的则称为外部网关协议EGP(BGP)</p><hr><h5 id="目前主要使用自适应-分布式协议，对于理想的路由协议-如何实现"><a href="#目前主要使用自适应-分布式协议，对于理想的路由协议-如何实现" class="headerlink" title="目前主要使用自适应 分布式协议，对于理想的路由协议 如何实现?"></a>目前主要使用自适应 分布式协议，对于理想的路由协议 如何实现?</h5><blockquote><p>正确性+完整性$\rightarrow$沿着路由表 肯定能到达所有主机</p><p>简洁性+合理性$\rightarrow$是保证时延最小 占有系统资源少 同时要求算法技术复杂性尽可能低</p><p>健壮性+可靠性$\rightarrow$根据结点故障，拥塞情况等进行动态的调整</p><p>稳定性$\rightarrow$网络结构稳定时避免路由表不断变化</p><p>公平性$\rightarrow$除非紧急，否则所有用户数据报进行一样的处理</p></blockquote><h2 id="内部网关协议RIP"><a href="#内部网关协议RIP" class="headerlink" title="内部网关协议RIP"></a>内部网关协议RIP</h2><h5 id="RIP简介"><a href="#RIP简介" class="headerlink" title="RIP简介"></a>RIP简介</h5><p>路由信息协议Router Information Protocol 是最早的广泛应用的分布式路由选择协议 </p><p>是比较简单的内部网关协议Interior Gateway Protocol</p><p>包括了RIP-1和RIP-2 其中2是1的扩充版</p><h5 id="最大的特点：好消息传的快-坏消息传的慢"><a href="#最大的特点：好消息传的快-坏消息传的慢" class="headerlink" title="最大的特点：好消息传的快 坏消息传的慢"></a>最大的特点：好消息传的快 坏消息传的慢</h5><blockquote><p>它的设计基于距离矢量算法(Distance-Vector)，使用Hop Count(跳数)来度量和目的网络之间的距离</p><p>与设备直连时跳数为0，这个度量值等于到达目的网络间的设备数量。</p></blockquote><p>为了限制收敛时间，RIP规定度量值取0～15之间的整数 大于等于16目的网络不可达 <strong>这也直接使得RIP不可能应用在大型网络里</strong></p><blockquote><p>ps: 什么是路由收敛，什么是收敛时间</p></blockquote><p><strong><u>路由收敛 $\rightarrow$ 所有路由器对当前的网络结构和路由转发达成一致的状态</u></strong></p><p><strong><u>收敛时间 $\rightarrow$ 从网络拓扑发生变化，到所有相关路由器都得知这个变化并作出相应改变所需要的时间</u></strong></p><h5 id="RIP如何工作"><a href="#RIP如何工作" class="headerlink" title="RIP如何工作"></a>RIP如何工作</h5><blockquote><p>路由器A只和邻居路由器交换信息(同一网段所有路由器的接口)，采用主动发送 被动接收的方式</p><p>RIP交换的信息是路由器当前所知的全部信息(路由表主体)</p><p>每<strong>30s</strong>完成一次信息交换，更新各自路由器的路由表 在更新时，RIPv1总是广播更新，而v2是组播更新</p><p>(具体的情况就是 在第一次交换之前 路由器只有直连网络的信息，在几次交换之后，会得到整个自治域的最短距离信息) 在几次交换之后，就能实现每次转发距离最小。</p></blockquote><h5 id="形成RIP路由表"><a href="#形成RIP路由表" class="headerlink" title="形成RIP路由表"></a>形成RIP路由表</h5><ul><li>RouterA启动了RIP协议，向相邻路由器广播一个Request报文</li><li>RouterB是A的邻居，受到Request报文后将自己的<strong>整个路由表</strong>封装在Response报文里，向接口对应的网络广播</li><li>RouterA根据B的报文形成自己的路由表</li></ul><h5 id="与RIPv1相比，RIPv2的不同"><a href="#与RIPv1相比，RIPv2的不同" class="headerlink" title="与RIPv1相比，RIPv2的不同"></a>与RIPv1相比，RIPv2的不同</h5><ol><li>v1是有类路由协议，v2是无类路由协议</li><li>v1不支持VLSM v2支持</li><li>v1没有认证功能，v2有明文和MD5认证</li><li>v1没有手工汇总，必须自动；v2可以关闭自动汇总</li><li><strong>V1总是广播更新，v2组播更新</strong></li><li>v1没有路由标记 不能过滤和实施策略</li><li>v1发送的updata包没有next-hop属性，这个属性可以用来进行路由更新的重定</li><li>使用v1的路由器可以接收v2的报文，而使用v2的则不能接收v1的报文</li></ol><h5 id="RIP协议-如何出现环路？"><a href="#RIP协议-如何出现环路？" class="headerlink" title="RIP协议 如何出现环路？"></a>RIP协议 如何出现环路？</h5><p>在如下的网段里，R1和C直连 跳数为1 R2到C跳数则为2</p><p>现在C网段出现故障 R1到C距离为16 不可达</p><p><code>R1</code>准备在下一个30秒内告诉<code>R2</code>这个坏消息，但是<code>R2</code>先把自己的所有信息都告诉了<code>R1</code>,<code>R1</code>一看咦？<code>R2</code>到<code>C</code>的跳数是2，我到<code>R2</code>就一跳，现在虽然我不能直接到<code>C</code>了，那么绕道<code>R2</code>不就可以了吗？说干就干，于是把自己到<code>C</code>的跳数改为<code>3</code>.好了，真相被谎言掩盖了。</p><p><code>R1</code>向<code>R2</code>这个坦白所有的信息，<code>R2</code>看到<code>R1</code>到<code>C</code>的距离变为3了，<code>R2</code>知道自己是经过<code>R1</code>才到达的<code>C</code>，于是毫不犹豫的改为4.下一次再把全部信息告诉<code>R1</code>,<code>R1</code>收到一看，咋回事啊，怎么又加一跳了呢！<code>R2</code>那边发生了什么？但是还是得根据规则，毫不犹豫的修改到C的距离跳数。<strong>就这样不断增加，直到都为16</strong>，才恍然大悟，原来大家都到不了了啊。</p><hr><h2 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h2><h5 id="OSPF简介"><a href="#OSPF简介" class="headerlink" title="OSPF简介"></a>OSPF简介</h5><p>Open Shortest Path First 开放最短路径优先协议 是为了克服RIP的缺陷而设计的。</p><p>属于典型链路状态(link-state)协议。在区域内的所有路由器维护共同的链路状态数据库。</p><p>维护的数据包括链路标号两端连接路由器链路度量(距离 费用 带宽 时延)</p><p><em><strong>可以用在较大的网络中 但路由协议和算法比较复杂</strong></em></p><blockquote><p>AS 被OSPF划分成若干个区域，每个区域路由器数量不超过200个，并由32位区域标识符描述。</p><p>在某个区域的所有路由器，只需要知道本区域的网络拓扑结构即可。这使得OSPF协议的效率比较高</p></blockquote><p>AS被划分成 Backbone Area(主干区域,0.0.0.0) 和Area，主干区域路由器就是主干路由器，区域之间设置区域边界路由器，这个路由器和主干路由器连接。</p><h5 id="OSPF工作原理"><a href="#OSPF工作原理" class="headerlink" title="OSPF工作原理"></a>OSPF工作原理</h5><blockquote><p>在区域中使用flooding(泛洪法)，由路由器所有输出接口向相邻路由器发送某个特定链路状态信息(我所知的相邻路由器的链路状态)，再由相邻路由器向其他地方转发(不会发回来) 注意：转发的是人家的包？</p><p>经过信息交换，区域中的每个路由器都保存了所有路由链路状态信息 据此组成相同链路状态数据库(LSDB)</p><p>在进行数据报的路由选择时，可以通过链路状态计算得到最短路径，并且通过链路度量，能更加灵活的处理</p><p>链路发生变化时，OSPF才使用泛洪法发送变化的信息</p></blockquote><p>分层区域设置 让交换路由信息的种类增加。随着层次增加，OSPF会逐渐变的更加复杂 但在更强大的设备加持下，OSPF能够有效的管理大规模的网络</p><p>网络按照层次结构设计时大规模网络普遍采用的设计原则。一般分为接入层、汇聚层(边缘层)、核心层；同样的设备在不同的层次时所完成的工作也是不同的。</p><h5 id="OSPF路由算法"><a href="#OSPF路由算法" class="headerlink" title="OSPF路由算法"></a>OSPF路由算法</h5><p>在建立链路状态数据库后 路由器相当于拥有了网络拓扑的完整信息，根据网络拓扑构建网络最短路径树，路由器就能建立自己的***<u>隐式路由表</u>***(只供自己使用)</p><blockquote><p>根据本区域的 链路状态数据库 计算到本区域的各个网络路由</p><p>根据本AS的 链路状态数据库 计算到AS中其他区域各个网络路由。</p><p>​主干路由器根据到区域边界路由器(ABR)距离,和ABR到区内网络的距离综合选择路由</p><p>根据到AS域边界路由器+AS边界路由器到外部目的网络的距离，计算选择的路由</p></blockquote><p>OSPF可以根据IP首部的TOS(Type Of Service服务类型)对不同的链路设置代价(1-65535) 根据链路带宽 时延来计算</p><p>如果有多个相同代价的路由，还可以作多路径间多负载均衡，支持VLSM和CIDR 健壮性、稳定性、服务质量都不错。</p><h5 id="OSPF和RIP的区别"><a href="#OSPF和RIP的区别" class="headerlink" title="OSPF和RIP的区别"></a>OSPF和RIP的区别</h5><p>RIP只关注最短路径(这个路径还是只看跳数决定的)和下一跳路由器；而OSPF则能进行链路状态计算，还有链路度量机制</p><p>RIP在进行信息交换时不是转发人家发来的包，而是根据他的人包更新，然后发送自己的包(OSPF是转发)</p><p>RIP的信息交换是定时的！而OSPF则是检测到链路变化时才发送。</p><p>OSPF虽然有着更好的服务效果，但对计算能力的要求比较高</p><p><em><strong>对于距离矢量路由协议来说交换的是路由表，每个路由器的路由表都是照搬其他人的包，并不需要计算</strong></em></p><p><em><strong>而链路状态路由协议交换链路状态</strong></em></p><h2 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h2><h5 id="BGP简介"><a href="#BGP简介" class="headerlink" title="BGP简介"></a>BGP简介</h5><p>自治域间的路由选择由外部网关协议负责。早期出现的EGP(外部网关协议)已经不再使用</p><p>Border Gateway Protocol(version 4)占有重要地位 所有的 AS都需要通过BGP-4获取彼此路由信息。</p><h5 id="在域间路由选择时面临的问题"><a href="#在域间路由选择时面临的问题" class="headerlink" title="在域间路由选择时面临的问题"></a>在域间路由选择时面临的问题</h5><blockquote><p>可扩展性 ：</p><p>域间路由器必须能转发Internet里所有可能的地址的分组。需要的路由表必须提供任何合法的IP地址分配</p><p>适应 域的自治特性：</p><p>每个自治域被允许使用自己的内部路由协议，选择一条穿越多个AS的路径的最优化是无意义的</p><p>对自治域的信任问题</p><p>在路由信息交互时，各个ISP提供的路由选择信息是否存在错误？以及域间路由的灵活策略(如一个多连接的ISP可制定通往AS1与AS3的策略 存在信任问题)</p></blockquote><h5 id="BGP的工作原理"><a href="#BGP的工作原理" class="headerlink" title="BGP的工作原理"></a>BGP的工作原理</h5><p><em><strong>首要目标是 找到任何一条 无环的 通往预定目的地的路径(可达优先，没必要最优)</strong></em></p><p>其处理特点是：</p><p><em><strong>能够进行路由优选 避免路由环路 更高效传递路由和维护大量路由信息</strong></em></p><p>跨越多跳路由器建立邻居关系(基于TCP协议) 在BGP路由里携带丰富的属性值</p><ol><li>自治域间路由，系统层次：自治域外提供路由信息，也就是边界路由器，一个AS设置一个发言人和其他AS交换信息</li><li>政策性约束，管理员可以配置BGP对某些路径不提供中转的策略，即使它知道如何到达目的地址</li><li>中转路由设施，当一个自治域同意某个业务流通过本系统转送到另外一个AS时，BGP会作为Transit System。当有一个以上的其他AS连接 但拒绝中转通信的AS称为Multihomed AS，只和一个AS连接 只传输本地业务流称为Stub System(桩AS)</li><li>可靠传输，BGP使用TCP通信。</li></ol><hr><blockquote><p>路由器中路由协议和路由算法各自完成什么作用？</p></blockquote><p>​路由协议规定和指导IP数据报在网络中的存储转发方式。路由算法则需要提高路由协议的功能(工作效率),尽量减少路由时产生的开销，并且尽可能做到快速收敛。</p><p>路由协议完成路由信息动态交换，并以此建立路由表；路由算法是根据转发IP包的目的地址，依据路由表计算出最优转发路径和端口。</p><blockquote><p>什么是跳数？RIP协议为什么将最大跳数设为16？</p></blockquote><p>​跳数(Hop Count)，从源端口到目的端口所经过的路由设备个数</p><p>​为了限制收敛时间。在网络中有一个设备出现故障时，与其直连的设备知道网络不可达，但在更新之前如果其他不知情的路由设备向故障网段发送报文，就会出现误解的情况从而出现环路，两个设备到故障网段的跳数不断增加直到达到16时才能确认不可达。</p><blockquote><p>RIP协议工作的基本思想，主要问题在那里？</p></blockquote><p>​1.只和相邻路由器交换信息 采取主动发送 被动接收到方式</p><p>​2.每30s一次交换，每次都交换整个路由表</p><p>主要的问题：</p><pre><code class="hljs">1. 规定最多16跳，所有路由器持有全部路由信息，不能用在大型网络上2. 只根据跳数来判断传输效率，不考虑链路带宽和延时等等其他因素3. 发生故障时，收敛速度慢4. 无法考虑多链路的负载均衡机制5. 不能识别服务等级和类型</code></pre><blockquote><p>目前网络路由协议主要考虑的哪些要素？</p></blockquote><p>见<code>理想路由协议如何实现</code></p><blockquote><p>简述互联网为什么要定义自治域AS，解释为什么要分层路由。</p></blockquote><p>定义自治域AS：全球有很多的公司和组织需要接入互联网，但根据其业务或条件的不同，其内部拓扑有着很大区别，并且其网络构成细节也希望不对外界公开，所以引入AS的概念来让不同的互联网实体可以无障碍沟通的同时保留自己的完整性。</p><p>分层路由：实际上的互联网是由各个AS互连而成，而由于业务等等因素的区别，每个AS的内部拓扑和使用的协议不一定相同，因此进行分层的路由，在AS内部使用IGP，只需要考虑内部的拓扑结构，而AS之间使用BGP也可以无视不同AS内部的差异。</p><blockquote><p>RIP与OSPF协议主要特点，各自处理的自治域规模一般多大？</p></blockquote><p>RIP是基于距离矢量算法设计，只考虑跳数，所以路由选择没有考虑到链路的带宽和延时，引入不可超过16跳来避免环路也让其只能用于早期的 小型的互联网。但其的算法思路简单，对路由设备算力的要求低于OSPF协议。</p><p>OSPF则属于典型链路状态协议。在区域内的所有路由器维护共同的链路状态数据库，能够考虑到各种链路因素。自治域在OSPF中被划分成了若干个区域(每区域不超过200个路由器)，这使得OSPF不仅效率高，而且也能用在较大规模的自治域中。但随着层次的增加，OSPF协议会变的更加复杂，所以对设备的配置有一定要求。</p><p>RIP只能用在小型的自治域中(如果自治域中任意两个端点的最短距离大于等于16就不能再使用RIP协议了)</p><p>OSPF可以用在大规模的自治域中。</p><blockquote><p>简单说明IGP和EGP协议主要区别。</p></blockquote><p>IGP(Interior Gateway Protocol)用在自治域的内部，用来在AS内部交换路由信息。</p><p>EGP(Exterior Gateway Protocol)用于连接不同的自治域，通过策略和过滤来控制路由信息在不同AS间的传播。</p><blockquote><p>简述自治域划分与因特网主干网、区域ISP和用户接入网的关系。</p></blockquote><p>因特网主干网作为一个自治域和多个其他主干网互连，区域ISP则可以直接接入因特网主干网，而用户接入网则作为ISP的客户接入ISP，通过ISP来访问主干网。</p><blockquote><p>BGP协议是否一定能提供最佳路径，为什么？</p></blockquote><p>我认为不是。虽然BGP协议能路由优选 避免路由环路 更高效传递路由和维护大量路由信息。但首要目标是找到任何一条无环的通往预定目的地的路径(可达性为最优先)</p><blockquote><p>简述因特网的实际结构和特点，中国因特网可能的基本组成结构是？</p></blockquote><p>​因特网实际上是由各个组织的自治域系统AS网络互连而成，并非平面结构而是层次结构。由核心层 分布层 接入层构成。主干网，城域网(ISP)和用户网(LAN)组成了其层次结构。</p><p>组成成分：</p><ol><li>网根结构是多个主干网(AS)互连</li><li>大公司和ISP直接与一个或者多个主干网连接</li><li>小公司和个人用户作为ISP的客户接入ISP</li></ol><blockquote><p>RIP为什么称为距离向量协议？</p></blockquote><p>基于距离矢量算法设计</p><blockquote><p>路由协议有什么作用？</p></blockquote><p>路由指导数据报转送方式，是传输过程中事先约定好的规定和标准</p><blockquote><p>什么是自治域？举两个例子。</p></blockquote><p>一个自治系统（Autonomous System，AS）是一组路由器的集合，它们拥有同样的选路策略、被同一技术管理部门管理运行。  </p><blockquote><p>OSPF协议交换什么信息，路径最优含义？</p></blockquote><p>交换的是链路状态信息，包括接口上的IP地址 子网码 网络类型 代价 区域</p><p>开放最短路径优先，构建一颗最短路径优先树。</p><hr><h1 id="Chapter6-C-S模式与API"><a href="#Chapter6-C-S模式与API" class="headerlink" title="Chapter6 C&#x2F;S模式与API"></a>Chapter6 C&#x2F;S模式与API</h1><h1 id="网络服务模式与API"><a href="#网络服务模式与API" class="headerlink" title="网络服务模式与API"></a>网络服务模式与API</h1><h2 id="Client-Server-模式"><a href="#Client-Server-模式" class="headerlink" title="Client&#x2F;Server 模式"></a>Client&#x2F;Server 模式</h2><h3 id="因特网的基本通信模式"><a href="#因特网的基本通信模式" class="headerlink" title="因特网的基本通信模式"></a>因特网的基本通信模式</h3><ul><li><h5 id="流模式-如-Web通信"><a href="#流模式-如-Web通信" class="headerlink" title="流模式(如: Web通信)"></a>流模式(如: Web通信)</h5></li><li><h5 id="报文模式"><a href="#报文模式" class="headerlink" title="报文模式"></a>报文模式</h5></li></ul><h3 id="C-S模式基本概念"><a href="#C-S模式基本概念" class="headerlink" title="C&#x2F;S模式基本概念"></a>C&#x2F;S模式基本概念</h3><h5 id="一种基于网络的信息交互-计算-分布模式"><a href="#一种基于网络的信息交互-计算-分布模式" class="headerlink" title="一种基于网络的信息交互/计算 分布模式"></a><code>一种基于网络的信息交互/计算 分布模式</code></h5><p><strong>网络软件被分为client和server 这两个名词直接指向通信中的两个进程，而不是主机</strong></p><h3 id="C-S模式的关系和特点"><a href="#C-S模式的关系和特点" class="headerlink" title="C&#x2F;S模式的关系和特点"></a>C&#x2F;S模式的关系和特点</h3><ul><li>对于C&#x2F;S模式 一定<strong>由客户发起请求，而服务器只被动响应</strong> $\rightarrow$ 请求&amp;应答 的分布计算(会话)模式</li><li>应用进程可以同时是服务器和客户</li></ul><blockquote><p>对于服务器软件 $\rightarrow$ <strong>主体框架 + 单个服务请求处理 + 并发服务请求处理</strong></p><ul><li>在共享计算机上首先运行，当系统启动时自动调用并不断运行</li><li>被动等待并且接受来自任意客户的通信请求 在大部分情况下 服务器软件提供单一的服务</li><li>可以同时处理多个远地&#x2F;本地客户的请求，但也需要强大的硬件和高级的操作系统支持  <strong>并发执行是服务器必须具备的</strong></li><li><strong>一个服务器软件包括 接收请求、处理单个请求和生成新线程三个部分</strong></li></ul></blockquote><blockquote><p>对于客户软件 $\rightarrow$ <strong>客户软件只是一个应用程序在进行服务器访问时的称呼</strong></p><ul><li>是任意的应用程序，它一般还能在本地做其它的事情</li><li>被用户调用 主动向远地服务器发起通信</li></ul></blockquote><h5 id="较复杂的C-S交互"><a href="#较复杂的C-S交互" class="headerlink" title="较复杂的C&#x2F;S交互"></a>较复杂的C&#x2F;S交互</h5><ul><li>客户应用不限制访问一个服务器，它需要同时和多个服务器通信。</li><li>服务器在提供服务的同时也需要作为另一个服务器的客户</li><li>服务器间可能会出现循环依赖</li></ul><p>在早期C&#x2F;S系统中 服务器计算机通常作为信息共享的设备部署(文件服务器、数据库服务器) 客户端自己来计算和跑程序</p><p>现今阶段 服务器是数据与业务功能处理中心 客户端则主要是UI界面+少量辅助功能处理</p><hr><h3 id="服务器识别"><a href="#服务器识别" class="headerlink" title="服务器识别"></a>服务器识别</h3><p><strong>Protocol Port Number 协议端口号 (OSI 术语是运输层服务访问点TSAP) 是TCP&#x2F;UDP给每种服务定义的标识</strong></p><p>对于源进程(它发起了请求)交付通信时通过 端口号明确自己的身份 还有接收方身份</p><p>收端进程会通过端口号来向目的进程交付。(很明显 这一切都发生在运输层)</p><p>对于服务器 通过端口号来明确提供的服务</p><h5 id="服务器端口号必须是唯一定义的-而客户端的端口号可以是临时指定的-只在本地有意义"><a href="#服务器端口号必须是唯一定义的-而客户端的端口号可以是临时指定的-只在本地有意义" class="headerlink" title="服务器端口号必须是唯一定义的 而客户端的端口号可以是临时指定的(只在本地有意义)"></a>服务器端口号必须是唯一定义的 而客户端的端口号可以是临时指定的(只在本地有意义)</h5><blockquote><p><strong>在使用TCP通信时 只有端口号是不够的 TCP的两个端点由Socket 插口 :(IP地址，端口号)定义</strong> (或者叫端地址)</p></blockquote><h5 id="协议端口号定义"><a href="#协议端口号定义" class="headerlink" title="协议端口号定义"></a>协议端口号定义</h5><p>TCP&#x2F;UDP定义一套16bit整数值 端口号被分为熟知端口号和一般端口号两列</p><p>熟知端口号 : FTP $\rightarrow$ 21Telnet $\rightarrow$ 23SMTP $\rightarrow$ 25DNS $\rightarrow$ 53TFTP $\rightarrow$ 69HTTP $\rightarrow$ 80SNMP $\rightarrow$ 161</p><p>一般端口号可以在规定区域内随意定义和分配</p><p>主要的端口号在1-225之间</p><p>端口号256-1023由Unix系统占用 </p><p>1024-5000作为临时端口 5000+不常出现 </p><h3 id="其他的交互模式"><a href="#其他的交互模式" class="headerlink" title="其他的交互模式"></a>其他的交互模式</h3><blockquote><p>C&#x2F;S模式比较简单 但容易造成网络瓶颈 并且负载不均衡问题也会使得服务器常常过载</p></blockquote><h5 id="P2P-peer-to-peer-：无中心服务器的流行网络技术-依赖所有参与者的计算能力和带宽-占到因特网流量的50-90"><a href="#P2P-peer-to-peer-：无中心服务器的流行网络技术-依赖所有参与者的计算能力和带宽-占到因特网流量的50-90" class="headerlink" title="P2P (peer to peer)：无中心服务器的流行网络技术 依赖所有参与者的计算能力和带宽 占到因特网流量的50%-90%"></a>P2P (peer to peer)：无中心服务器的流行网络技术 依赖所有参与者的计算能力和带宽 占到因特网流量的50%-90%</h5><hr><blockquote><p><strong>因特网通信模式和C&#x2F;S模式各自说明什么问题</strong></p><p>因特网通信模式：流模式和报文模式有着比较鲜明的特点，说明我们对因特网功能的需求是多样的，而网络技术也可以用不同的通信模式来满足不同的用户需求，但也说明想要实现稳定可能就需要牺牲效率，实现高效可能就保证不了可靠的传输。</p><p>C&#x2F;S模式：早期的C&#x2F;S模式以文件数据访问服务为主，客户程序也需要进行计算。而现今的C&#x2F;S模式在强大的服务器算力支撑下，客户端几乎不用承担计算任务，这说明C&#x2F;S模式的确得到了大规模的应用，所以服务器技术才能发展的如此迅速。</p></blockquote><blockquote><p><strong>简述客户软件和服务器软件主要特点</strong></p><p>服务器软件：</p><ol><li>专门提供某类服务的程序，一定可以并行的处理多个客户请求。</li><li>运行在共享计算机上，只要系统不关闭，就一直运行。</li><li>被动等待并且接收来自任意用户的通信请求</li><li>一般需要较强大的硬件和高级的操作系统支持</li></ol><p>客户软件：</p><ol><li>只有在进行通信时才被称为客户，它也可能可以在本地进行其他的计算并且实现其他功能。</li><li>由用户调用，在用户本地计算机上运行，在用户有需要时主动向远地服务器发起通信请求。</li><li>可以与多个服务器通信 并且一般不需要特殊硬件和复杂的操作系统</li></ol></blockquote><blockquote><p><strong>一个服务器软件通常需要包括哪些主要的功能部分？</strong></p><p>一个服务器软件主要包括：等待接收请求、处理单个请求和生成新线程</p></blockquote><blockquote><p><strong>为什么通常服务器端口号是唯一定义的，而客户端的端口号可以临时指定？</strong></p><p>服务器端口号唯一定义是为了让所有的客户都能正确找到它。因为C&#x2F;S交互的身份问题，客户端的端口号只需要做到不和自己同时运行的其他进程混淆即可，临时指定端口号也可以实现同一个端口号的复用(当某个客户软件不运行时就不占用端口号了)</p></blockquote><hr><h1 id="API-Application-Program-Interface"><a href="#API-Application-Program-Interface" class="headerlink" title="API [Application Program Interface]"></a>API [Application Program Interface]</h1><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h5 id="是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节"><a href="#是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节" class="headerlink" title="是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节"></a><code>是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节</code></h5><ul><li><strong>在应用从操作系统中获得相关服务时 通过调用API 将任务和控制权都交给操作系统，在执行完毕后，操作系统会交还控制权</strong></li><li>网络通信和数据交互调用API $\rightarrow$ 网络API(他是应用程序和TCP&#x2F;IP协议通信交互的接口)</li><li><strong>API造就了 应用和网络 的一体 和 分离 $\rightarrow$  在使用时一体，在开发时分离</strong></li></ul><p>互联网中主要有两类API 伯克利版 $\rightarrow$ Socket API 以及 A&amp;AT版 $\rightarrow$ TLI[Transport Lay Interface]</p><p>其中Socket API被主流操作系统使用，成为标准。</p><h3 id="Socket-API"><a href="#Socket-API" class="headerlink" title="Socket API"></a>Socket API</h3><ul><li>它来自Unix 由于Unix一切皆文件(open - read - write - close)的哲学影响，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</li><li><strong>在通信前 APP要向OS申请一个 套接字(也叫通信描述符)，OS返回一个小的整形数作为描述符来识别这个套接字 在通信结束后，这个代表特殊参数的套接字会被回收</strong></li><li><strong>套接字API 定义并调用多个函数来确定参数和选项 (创建套接字(返回描述符)，然后调用这些函数来完成对接)</strong></li></ul><h3 id="实现套接字API的函数"><a href="#实现套接字API的函数" class="headerlink" title="实现套接字API的函数"></a>实现套接字API的函数</h3><ol><li><p><code>Socket</code>函数 <strong>&#x2F;&#x2F; 创建套接字并返回整型描述符</strong></p><p>$Descriptor &#x3D; socket(pf,type,protocol)$ </p><p>pf $\rightarrow$ ProtocolFamily:协议栈(TCP&#x2F;IP)  Type $\rightarrow$ 连接&#x2F;无连接 protocol $\rightarrow$ 具体协议</p></li><li><p><code>Bind</code> 函数 <strong>&#x2F;&#x2F; 赋予套接字特定的端地址，实现socket和端地址的联编</strong> <strong><u><em>联编相当于 绑定</em></u></strong></p><p>$Bind(socket,locaaddr,addrlen)$ <strong>&#x2F;&#x2F; 不建立连接的话，bind函数之后就可以交互数据了</strong></p><p>loca addr $\rightarrow$ 本地端地址的一般socket地址描述结构。</p></li><li><p><code>Close</code> 函数 <strong>&#x2F;&#x2F; 告诉系统终止对一个套接字的使用(释放这个套接字)</strong></p><p>$close(socket)$ <strong>&#x2F;&#x2F; 如果面向连接，则先关闭连接，再回收套接字</strong></p></li><li><p><code>Listen</code> 函数 **&#x2F;&#x2F; (<em>只有面向连接使用) 套接字被设置为被动模式，等待连接请求</em>*</p><p>$Listen(socket,queuesize)$ Queue size $\rightarrow$ 客户请求队列长度</p></li><li><p><code>Connect</code>函数 <strong>&#x2F;&#x2F; 面向连接时使用，启动与服务器的连接(前提是服务器已经调用了listen和accept)</strong></p><p>$connect(socket,saddress,saddresslen)$  &#x2F;&#x2F;在UDP时 也可以使用 此时完成socket和目的服务器端地址联编</p></li><li><p><code>Accept</code>函数 **&#x2F;&#x2F; (<em>只有面向连接使用) 确定客户端的地址，确认连接，这时需要创建一个新的套接字，通信结束后回收</em>*</p><p>$newsock &#x3D; accept(caddress,caddresslen)$</p><p>c address$\rightarrow$按照socket地址结构描述的<strong>客户端IP地址</strong></p></li><li><p><code>Send</code>函数 <strong>&#x2F;&#x2F; 客户和服务器使用这个函数来发送消息</strong></p><p>$send(socket,data,length,flags)$ </p><p>data $\rightarrow$ 内存待发数据的地址length $\rightarrow$ 数据字节数flags $\rightarrow$ 特殊选项(用来调试系统)</p><p>$sendto(socket,data,length,flags,destaddress,addresslen)$ <strong>&#x2F;&#x2F;无连接使用sendto函数</strong></p><p>$sendmgs(socket,mgsstruct,flags)$ 作用和sendto类似</p></li><li><p><code>Recv</code>函数 <strong>&#x2F;&#x2F; 客户和服务器从套接字接收数据</strong></p><p>$recv(socket,buffer,length,flags)$</p><p>buffer $\rightarrow$ 内存中收到数据的地址length $\rightarrow$ 缓冲区大小flags$\rightarrow$特殊选项</p><p>$recvfrom(socket,buffer,length,flags,sndraddr,saddrlen)$ <strong>&#x2F;&#x2F;无连接使用recvfrom函数</strong></p><p>$recvmgs(socket,mgsstrucct,flags)$ 作用和recvfrom类似 <strong>sendmgs和recvmgs是原函数的简化参数版本</strong></p></li><li><p>其他</p><ol><li>$write(socket,buffer,length) &#x2F; read(socket,buffer,length)$ Unix的I&#x2F;O一般操作 在连接之后和send-recv一样</li><li>$getpeername$ <strong>&#x2F;&#x2F;调用accept接收连接请求后调用这个函数获取客户端地址</strong></li><li>$gethostname$ <strong>&#x2F;&#x2F;调用这个函数获取本机的完整信息，可以是域名，也可能是其他</strong></li><li>$ gethostbyname$ <strong>&#x2F;&#x2F;知道域名时 调用这个函数获取本机IP地址</strong></li><li>$getprotobyname$ <strong>&#x2F;&#x2F;知道域名时 调用这个函数获取 socket使用的二进制形式IP地址</strong></li><li>$gethostbyaddr$ <strong>&#x2F;&#x2F;知道IP地址，获取域名     这两个函数在API中完成IP地址和域名的转换</strong></li></ol></li></ol><p>备注：</p><ol><li><code>Accept</code>确认连接地址之后 需要创建一个新的socket (可以根据C&#x2F;S模式理解成，服务器创建新线程)，只要连接建立，原来的套接字就会用来和下一个客户进行连接。</li><li>服务器可以并发，服务器创建并发线程时套接字也会产生一个副本，这样就实现了并发线程都能调用所有的套接字功能</li><li><code>Listen</code>和 <code>Accept</code>函数是<em><strong>面向连接通信时</strong></em>服务器必须进行的调用</li></ol><h3 id="套接字API与C-S"><a href="#套接字API与C-S" class="headerlink" title="套接字API与C&#x2F;S"></a>套接字API与C&#x2F;S</h3><p>刚刚的程序每次收到请求都会打印一段信息(建立连接)。 </p><p>可以注意的是 <em><strong>客户端不需要 socket和端地址联编</strong></em> 因为客户端的端口号可以是临时指定的(端地址也就相当于是可变的)，如果客户端需要向服务器发送报文，那另说。</p><hr><blockquote><p><strong>API是否由TCP&#x2F;IP所定义，目前互联网最常用的API体系是什么。</strong></p><p>不是。API是宏观的概念，而网络中使用的API主要分为Socket API(它由Berkeley UNIX定义)和TLI ，其中Socket API被主流的操作系统使用，所以Socket API是互联网最常用的API体系。</p></blockquote><blockquote><p><strong>API接口与协议端口、插口有什么区别？</strong></p><p>在网络中使用的API，指的是应用程序和TCP&#x2F;IP协议通信交互的接口，它是经过抽象后定义的一组(函数)操作，由操作系统来调用它。API使得应用进程和TCP&#x2F;IP(运输层)实现透明。</p><p>协议端口是TCP&#x2F;UDP给每种服务定义的标识，在进程进行交互时协助对接。协议端口使得两端的操作系统都能识别身份和服务。</p></blockquote><blockquote><p><strong>服务器套接字API有哪些专门的函数（过程）；对一个面向连接的TCP通信，服务器端套接字API的实现要经过那些过程调用？</strong></p><ol><li>socketbindlistenacceptconnectclosesend(sendto)recv(recvfrom)getpeernamegethostnamegethostbynamegetprotobynamegethostbyaddr等</li><li>对于面向连接 服务器端API的实现要经过<ol><li>getprotobyname 获取IP地址</li><li>Socket 建立套接字</li><li>bind (socket和端口号联编)</li><li>listen 套接字设置为被动模式，等待连接请求</li><li>accept 确定客户端的地址，确认连接，并且返回一个新创建的套接字 </li><li>send&amp;recv 发送和接收数据</li><li>close 关闭连接 回收套接字</li></ol></li></ol></blockquote><blockquote><p><strong>对一个非连接通信，客户端套接字为什么不必和本地端地址绑定？</strong></p><p>因为客户端的端口号可以是临时指定的(端地址也就相当于是可变的)，这个端地址仅仅具有本地的意义，由于端地址已经可以在本地唯一的标识进程，即使不绑定套接字OS和TCP&#x2F;IP也都能通过端地址来找到应用进程。</p></blockquote><hr><h1 id="Chapter7-Web开发技术"><a href="#Chapter7-Web开发技术" class="headerlink" title="Chapter7 Web开发技术"></a>Chapter7 Web开发技术</h1><h3 id="远程过程调用-RPC-「Remote-Procedure-Call」"><a href="#远程过程调用-RPC-「Remote-Procedure-Call」" class="headerlink" title="远程过程调用 RPC 「Remote Procedure Call」"></a>远程过程调用 RPC 「Remote Procedure Call」</h3><p><strong>RPC模式 以及利用此模式制作的RPC中间件(通信插件) 旨在简化Web开发，使得程序员可以使用高级语言来建构程序(特别是网络分布式程序 如C&#x2F;S架构) 而不是利用API来调用</strong></p><ul><li><code>套接字API</code> 是底层通信过程最直接的抽象 直接面向TCP&#x2F;IP通信过程 所以即使是使用API来调用底层硬件<strong>仍然比较麻烦</strong> 并且会出现异常 好在<em><strong>API不是网络应用程序间通信实现的唯一方法</strong></em></li><li><code>procedure 过程</code> 指能解决一系列相关人物的可调用程序，(传统面向过程编程里的子程序)</li><li><code>procedure call 过程调用</code> 是面向过程编程机制 每个过程利用一组形式化参数定义，当过程被调用时 调用者要提供与形参匹配的实参(直接可以理解成 函数 和函数的调用)</li><li><code>RPC</code> <ul><li>是最早被提出和开发的C&#x2F;S通信工具的机制 </li><li>使用<strong>传统编程语言结构</strong>向开发者提供接口，而不像API那样需要利用显式通信原语</li><li>RPC允许程序员将过程适配到多个主机上，通过不同计算机间进行的远程过程调用自动生产代码并完成通信</li></ul></li></ul><h4 id="RPC模式规范"><a href="#RPC模式规范" class="headerlink" title="RPC模式规范"></a>RPC模式规范</h4><ul><li>我们需要的 RPC模式在现有的编程语言中扩展，设计了一种符合<strong>高级语言编写规范(考虑到不同计算机的适配问题 需要用高级语言 汇编不行)</strong> 并能自动处理网络通信细节</li><li>RPC允许客户端 <strong>跨过网络调用服务器过程 在这种情况下就可以使用<code>RPC工具</code>，它将生成处理所需的通信过程插件<code>communication stub/proxy</code> 真正的通信任务交给插件来完成 如下图</strong><ul><li>在使用通信插件后 程序员被允许在忽略底层通信拓扑的基础上使用高级语言和成熟的编程方法来进行架构 提高软件的可靠性<ul><li>客户端 $\Rightarrow$ 客户插件 + 客户端主程序</li><li>服务器 $\Rightarrow$ 服务器插件 + 远程过程</li></ul></li></ul></li><li><code>中间件 middleware</code> 是介于传统应用程序和系统平台(os和hardware system) 之间的通用服务工具 主要的作用是以下三点 我认为这和API有很多相似之处<ul><li>提供标准接口 ｜ 支持分布式计算(负载均衡) ｜ 支持跨平台</li></ul></li></ul><hr><h1 id="Chapter8-Multi-Media-VoIP"><a href="#Chapter8-Multi-Media-VoIP" class="headerlink" title="Chapter8 Multi-Media&amp;VoIP"></a>Chapter8 Multi-Media&amp;VoIP</h1><h2 id="互联网中的实时业务"><a href="#互联网中的实时业务" class="headerlink" title="互联网中的实时业务"></a>互联网中的实时业务</h2><ul><li>多媒体「multimedia」 一般用来指含有音频&#x2F;视频的数据，当然也适用于文本</li></ul><p>这类信号在数字化后如果按照因特网传输数据的方式到达接收方，<strong>并实时的展示出来</strong> 其结果是难以接受的</p><p>我们知道 音视频信号的传播过程 包括 抽样、编码(D&#x3D;&gt;S)、网络传输、解码</p><p>而因特网存在的 丢包 和 乱序问题</p><p>丢包 $\Rightarrow$ 抽样值丢失</p><p>乱序 $\Rightarrow$ 抽样值时延不一致！这会造成以下我们所说的 <code>抖动</code></p><ul><li><h4 id="网络吞吐率T-单位时间内-有效传输的-比特-字节数「与带宽、速率的区别在于-它们俩用来表示某条链路-而不是整个网络」"><a href="#网络吞吐率T-单位时间内-有效传输的-比特-字节数「与带宽、速率的区别在于-它们俩用来表示某条链路-而不是整个网络」" class="headerlink" title="网络吞吐率T 单位时间内 有效传输的 比特&#x2F;字节数「与带宽、速率的区别在于 它们俩用来表示某条链路 而不是整个网络」"></a>网络吞吐率T 单位时间内 有效传输的 比特&#x2F;字节数「与带宽、速率的区别在于 它们俩用来表示某条链路 而不是整个网络」</h4></li><li><h4 id="网络时延D-一个分组-通过网络需要的时间"><a href="#网络时延D-一个分组-通过网络需要的时间" class="headerlink" title="网络时延D 一个分组 通过网络需要的时间"></a>网络时延D 一个分组 通过网络需要的时间</h4></li></ul><p>处理实时业务时碰到的最大困难， 不是分组丢失 而是 <strong><code>抖动「jitter」</code></strong> 这意味着「**<code>与常规的传输协议不同，传输实时数据的协议 只需要处理抖动问题，而不需要重传丢失的分组</code>**」</p><p><em><u>抖动的定义：「信号的某特定时刻相对于其理想时间位置上的短期偏离」</u></em> 相当于“跳ping、很小的延迟变化”</p><p>因特网无法要求底层的网络具有处理实时业务的功能 所以解决方案有两个</p><ol><li><h4 id="设计等时延、无抖动的网络-PSTN-TDM电路"><a href="#设计等时延、无抖动的网络-PSTN-TDM电路" class="headerlink" title="设计等时延、无抖动的网络(PSTN\TDM电路)"></a>设计等时延、无抖动的网络(PSTN\TDM电路)</h4></li><li><h4 id="设计抖动补偿协议-实现平滑重放「playback」-这又包含了两种主要的模式"><a href="#设计抖动补偿协议-实现平滑重放「playback」-这又包含了两种主要的模式" class="headerlink" title="设计抖动补偿协议 实现平滑重放「playback」 这又包含了两种主要的模式"></a>设计抖动补偿协议 实现<em><strong>平滑重放「playback」</strong></em> 这又包含了两种主要的模式</h4><ol><li><h5 id="时间戳「timestamp」-每个小片提供一个时间戳，接收方按照时间戳重放"><a href="#时间戳「timestamp」-每个小片提供一个时间戳，接收方按照时间戳重放" class="headerlink" title="时间戳「timestamp」 每个小片提供一个时间戳，接收方按照时间戳重放"></a>时间戳「timestamp」 每个小片提供一个时间戳，接收方按照时间戳重放</h5></li><li><h5 id="抖动缓冲「jitter-buffer」缓冲收到的数据、然后推迟重放"><a href="#抖动缓冲「jitter-buffer」缓冲收到的数据、然后推迟重放" class="headerlink" title="抖动缓冲「jitter buffer」缓冲收到的数据、然后推迟重放"></a>抖动缓冲「jitter buffer」缓冲收到的数据、然后推迟重放</h5></li></ol><p>实现抖动缓冲 我们只需要维护一个cache然后延迟d个时间单位，虽然分组到达的时间略有不同，但总会在d时间之内到达，我们均匀的输出分组，就没有关系了</p></li></ol><ul><li>想要实现流式传输有两种方法 ： 实时流式传输「RTS」 和 顺序流式传输</li><li>新世纪以来，流式存储下载的局限性越来越明显，而顺序流式传输「progressive streaming」成为主流</li></ul><h2 id="实时传输协议RTP「Real-time-Transport-Protocol」"><a href="#实时传输协议RTP「Real-time-Transport-Protocol」" class="headerlink" title="实时传输协议RTP「Real-time Transport Protocol」"></a>实时传输协议RTP「Real-time Transport Protocol」</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p>来自应用层｜支持单播&#x2F;多播｜提供时间信息+实现流同步｜<strong>通常使用UDP 也可在TCP&#x2F;ATM等协议上工作</strong></p><p><strong>RTP &#x3D; RTP数据协议+RTP控制协议</strong></p><h3 id="RTP的架构如下："><a href="#RTP的架构如下：" class="headerlink" title="RTP的架构如下："></a>RTP的架构如下：</h3><ul><li>version｜P: 载荷是否为0填充｜X：是否有扩展头部 ｜ M：特殊帧标志</li><li><strong>CC「CSRC计数」：即有多少个源(媒体流被按照规则封装成一个个源)</strong><ul><li>一个多媒体文件中， 视频、音频、字幕···会来自不同的轨道 它们被封装成不同的源 然后在接收端混合输出</li></ul></li><li><strong>PT：载荷的编码特性「包括 编码算法 采样频率 承载通道」 用来指示接收端如何解码</strong></li><li><strong>序列号</strong> 每个数据分组有一个16位的序列号，每次自加1。类似TCP序列号， 用来检测<strong>是否丢包</strong> 序列号初始值是随机的 因为要防范对加密数据的攻击</li><li><strong>时间戳(时标)</strong> 32位 反映RTP数据包中第一个数据的 <strong>采样时刻</strong> 初始时间戳是随机选择的，而随后从单调且线性增加的时钟导出，以解决同步与抖动计算。 时间戳的单位不是固定的s&#x2F;ms 而是根据载荷类型确定</li></ul><blockquote><p>序列号与时间戳 是完全独立的</p><p>因为分组顺序 和 时间顺序 并不是线性相关的</p><p>「⚠️ 意思不只是 每个分组和分组到达的时间不是线性相关。 问题的关键在于 信号是数字化(离散)的，而时间戳会随着时间一直累加，而如果信号进入了空白帧，那么分组可以进入缓变状态(等到有数据了 再发送这个分组)」</p></blockquote><ul><li><strong>CSRC列表：接收端会对多个源的数据进行混合输出 以此列表作为参照</strong> </li><li>SSRC：标识多个源进行同步。 不是随机选择，每个RTP包里的每个同步源(需要同步播放)都有不同的SSRC标识</li></ul><h2 id="RTCP协议「Real-time-Transport-Control-Protocol」它和RTP是连体婴儿-不可分割"><a href="#RTCP协议「Real-time-Transport-Control-Protocol」它和RTP是连体婴儿-不可分割" class="headerlink" title="RTCP协议「Real-time Transport Control Protocol」它和RTP是连体婴儿 不可分割"></a>RTCP协议「Real-time Transport Control Protocol」它和RTP是连体婴儿 不可分割</h2><p><strong>不对实际音视频数据进行封装，是控制短分组协议</strong></p><h3 id="RTCP的任务："><a href="#RTCP的任务：" class="headerlink" title="RTCP的任务："></a>RTCP的任务：</h3><ul><li>服务质量监控和反馈<ul><li>接收端会多播发送丢包率、抖动···，发送端会多播发送 分组数、时间戳、绝对时间</li></ul></li><li>多源媒体之间的标识和同步</li></ul><h2 id="IP电话-IP-telephony-IP语音-Voice-over-IP-VoIP"><a href="#IP电话-IP-telephony-IP语音-Voice-over-IP-VoIP" class="headerlink" title="IP电话(IP telephony)&#x2F;IP语音(Voice over IP&#x2F; VoIP)"></a>IP电话(IP telephony)&#x2F;IP语音(Voice over IP&#x2F; VoIP)</h2><p>使用IP路由器取代传统电话交换机的动机很简单：💰</p><p>而且由于底层的网络设施共享，只要有了基本的设备就可以实现IP通话</p><p>IP电话的应用所面对的最大挑战就是 设计者希望IP电话能和已有的公共电话交换网络PSTN(Public Switched Telephone Network)兼容(向后兼容)，它们需要实现双向可通话。</p><h2 id="信令与VoIP标准"><a href="#信令与VoIP标准" class="headerlink" title="信令与VoIP标准"></a>信令与VoIP标准</h2><p>目前有两个组织为IP电话制定了标准：</p><p>国际电信联盟International Telecommunications Union 制定电话标准</p><p>因特网工程任务组Internet Engineering Task Force&#x2F; IETF 制定TCP&#x2F;IP标准</p><h3 id="IP电话的基础技术"><a href="#IP电话的基础技术" class="headerlink" title="IP电话的基础技术"></a>IP电话的基础技术</h3><ul><li>音频采用脉冲编码调制(PCM&#x2F; Pulse Code Modulation) 编码</li><li>数字化音频使用 RTP进行传输</li></ul><h3 id="IP电话的主要复杂之处在于-呼叫建立和呼叫管理-而我们把「建立和终止呼叫的过程-称为-信令-signaling-」"><a href="#IP电话的主要复杂之处在于-呼叫建立和呼叫管理-而我们把「建立和终止呼叫的过程-称为-信令-signaling-」" class="headerlink" title="IP电话的主要复杂之处在于 呼叫建立和呼叫管理  而我们把「建立和终止呼叫的过程 称为 信令(signaling)」"></a>IP电话的主要复杂之处在于 呼叫建立和呼叫管理  而我们把「建立和终止呼叫的过程 称为 信令(signaling)」</h3><p>电话中处理呼叫管理所采用的机制 就是<code>信令系统</code></p><p>为了和已有的电话系统兼容，我们需要和SS7(Signaling System 7)兼容 IETF剔除了 会话初启协议「Session Initiation Protocol，SIP」   </p><p><code>SDP（Session Description Protocol）是一个用来描述多媒体会话的应用层控制协议，它是一个基于文本的协议，用于会话建立过程中的媒体类型和编码方案的协商等</code></p><p><code>H.323 ITU定义的IP电话信令协议</code></p><h3 id="IP电话质量控制"><a href="#IP电话质量控制" class="headerlink" title="IP电话质量控制"></a>IP电话质量控制</h3><p>要求：</p><ul><li>使用光纤网络+特殊补偿算法 可以容忍最多30%的丢包率</li><li>电话通信端到端延时要求 &lt; 250ms。</li></ul><h2 id="SIP协议「Session-Initialization-Protocol」"><a href="#SIP协议「Session-Initialization-Protocol」" class="headerlink" title="SIP协议「Session Initialization Protocol」"></a>SIP协议「Session Initialization Protocol」</h2><p><code>用以一个或多个用户的会话建立、更改、管理、终止。不能单独完成多媒体通信的呼叫。</code></p><p>STP和SDP+RTP&#x2F;RTCP一起配合 组建完整的多媒体通信系统</p><h3 id="SIP功能："><a href="#SIP功能：" class="headerlink" title="SIP功能："></a>SIP功能：</h3><p>•用户定位：确定参加通信的终端用户位置。</p><p>•用户通信能力协商：确定通信的媒体类型和参 数。</p><p>•用户交互意愿：确定被叫加入通信的意愿。</p><p>•呼叫建立：建立主叫和被叫的会话参数。</p><p>•呼叫处理和控制：包括呼叫重定向、呼叫转移 ，终止呼叫等。</p><h3 id="SIP特点"><a href="#SIP特点" class="headerlink" title="SIP特点"></a>SIP特点</h3><ul><li>通过代理和重定向请求用户当前位置以支持用户移动性</li><li>独立于传输层协议，可以承载在不同的传输协议上 并扩展方便</li><li>只建立 更改 终止一个会话，和会话内容无关，这意味着其载体可以是任意的(甚至可以是视频和游戏)</li></ul><h3 id="SIP在网络中的主要实体："><a href="#SIP在网络中的主要实体：" class="headerlink" title="SIP在网络中的主要实体："></a>SIP在网络中的主要实体：</h3><ul><li><p>用户代理（ User Agent ）：用来发起或接收请求 的逻辑实体设备（如 IP 电话机、计算机、媒体网关等）。</p></li><li><p>用户代理客户 UAC （ User Agent Client ）：发 起请求的一方（如 SIP Phone ）；</p></li><li><p>用户代理服务器 UAS （ User Agent Server ）： 接收 请求，产生响应的一方。</p></li><li><p>定位 服务器（ Location Server ）：管理提供被 叫的位置数据库 , 如每个用户的 IP 地址集合（ IP 地址、电话号码、 email 地址）、用户订购业务 、用户偏好等，在呼叫过程中提供被叫用户的位 置信息</p></li><li><p>支持服务器（ Support Server ）：代理服务器、 重定向服务器、注册服务器，实际呼叫过程扩展 应用。 </p></li><li><p>代理服务器：作为一个实体转发用户代理客户 UAC 的请求至被叫（用户代理服务器 UAS ）或 一个代理服务器。</p></li><li><p>注册服务器：接收注册请求 , 将注册请求中的地 址映射关系更新到定位数据库中，并负责验证注 册请求和确保底层数据库一致性。</p></li><li><p>重定向服务器：为所收到的请求返回一个或多个 新的地址，用户代理客户 UAC 再向这些新的地址 发起请求。重定向服务器并不接收呼叫或拒绝呼 叫，主要完成路由重新定向，与注册过程配合可 以支持 SIP 终端的移动性</p></li></ul><h3 id="SIP协议消息类型"><a href="#SIP协议消息类型" class="headerlink" title="SIP协议消息类型"></a>SIP协议消息类型</h3><p>SIP分为请求和响应</p><hr><blockquote><p> <strong>试列举3-5种网络中可能产生的时延，什么是等时时延或非等时时延？</strong></p><p> 可能的时延有 信号传播时延、信号处理时延、路由器存储转发时延、丢包重传时延、播放时延等。</p><p> 等时时延&amp;非等时时延 ： </p><p> 以信号传输为例 就是信号总在一段固定时间后到达，这其中的时延称为等时时延</p><p> 如果每次传输信号会在不同的时间后到达，就将这段时延称为非等时时延</p></blockquote><blockquote><p><strong>在因特网丢包、乱序的状况下，分析比较对非实时email和实时IP电话所产生的影响？</strong></p><p>对于E-Mail来说，如果不使用可靠的传输协议，接收方很难收到正确、完整的信息。但由于其非实时性，借助SMTP等可靠传输协议实现差错检测和报文重传，客户发送的E-Mail几乎总能正确、完整的到达接收方处。</p><p>对于实时IP电话来说，由于音视频信号在网络上传输的特点，网络丢包、乱序导致网络抖动，使得还原出的信号产生失真。如果借助可靠传输，由于网络层丢包、乱序的状况，传输会不可避免的花费时间，会丧失实时性。如果实时传输并引入超时重传，在接收端已经收到并提取信息之后再把错误或丢失的数据包插播进来是毫无意义的。因此智能设计等时延、无抖动的网络结构 或者 设计补偿抖动的协议实现平滑重放。</p></blockquote><blockquote><p><strong>简述RTP协议中定义序列号、时标有什么作用？如何理解两者具有独立性。</strong></p><p>序列号 类似TCP序列号，用来检测是否丢包。</p><p>时间戳(时标) 反映RTP数据包中第一个数据的采样时刻，初始时间戳随机选择，随后则从单调、线性增加的时钟导出，以解决同步与抖动计算。</p><p>序列号所对应的是 分组顺序，时间戳对应的则是 时间顺序。两者之间不一定是线性相关的，因为信号的特点可能使得在一段时间内并无信号(数据帧)，或者出现可变长度视频编码(图像缓变)帧，而在这段时间内时间戳会一刻不停的累加。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>Classification Problem in CV(from CS231n)</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h1 id="Classification-Problem-in-CV-from-CS231n"><a href="#Classification-Problem-in-CV-from-CS231n" class="headerlink" title="Classification Problem in CV (from CS231n)"></a>Classification Problem in CV (from CS231n)</h1><h2 id="Image-Classification"><a href="#Image-Classification" class="headerlink" title="Image Classification"></a>Image Classification</h2><p><a href="https://zhuanlan.zhihu.com/p/20894041?refer=intelligentunit">CS231n 图像分类上</a></p><p><a href="https://zhuanlan.zhihu.com/p/20900216">CS231n 图像分类下</a></p><h5 id="Nearest-Neighbor-分类器"><a href="#Nearest-Neighbor-分类器" class="headerlink" title="Nearest Neighbor 分类器"></a>Nearest Neighbor 分类器</h5><p>平常不会使用, 只是用来理解. 顾名思义, 将测试图片和训练集里的每张图片进行比较, 找到与其L1距离最小的图片, 把这张图片的标签作为输出(认为找出来的这张图片和测试图片是同一标签)</p><h5 id="k-Nearest-Neighbor-分类器"><a href="#k-Nearest-Neighbor-分类器" class="headerlink" title="k-Nearest Neighbor 分类器"></a>k-Nearest Neighbor 分类器</h5><p>nearest neighbor分类器是k-Nearest Neighbor分类器的特殊情况(k&#x3D;1). 选取距离排前k的图片, 让它们进行投票.</p><ul><li>在评估图片距离时, 我们可以使用L1距离, 或者L2距离, 又或者使用点积来实现,  这些选择, 被称为<code>hyper-parameter 超参数</code></li><li>除了KNN训练不花时间, 但使用时缓慢这个缺点外, 利用<code>向量间距离来评估高维数据的相似度</code>这件事本身就是不合适的. 同时, 使用这种方法时, <code>图像的相似度也是被背景主导的</code>,而不是语义.</li></ul><p>总结来说 KNN分类器</p><ul><li>必须记住所有训练数据并存储它们</li><li>每个测试图像需要和所有的训练图像作比较, 算法计算资源耗费大</li></ul><h2 id="Liner-Classification"><a href="#Liner-Classification" class="headerlink" title="Liner Classification"></a>Liner Classification</h2><p><a href="https://zhuanlan.zhihu.com/p/20918580?refer=intelligentunit">CS231n 线性分类1</a></p><p><a href="https://zhuanlan.zhihu.com/p/20945670?refer=intelligentunit">CS231n 线性分类2</a></p><p><a href="https://zhuanlan.zhihu.com/p/21102293?refer=intelligentunit">CS231n 线性分类3</a></p><p>$f(x_i,W,b)&#x3D;Wx_i+b$  其中W是weights <code>权重</code>, b是bias vector <code>偏差向量</code></p><p>$每个图像数据被拉长为一个列向量 x_i, 其shape为[D*1]$</p><p>$W的shape为[K<em>D],b的shape为[K</em>1]$</p><p>咱们以2*2的图像为例</p><img src="https://pic3.zhimg.com/80/7c204cd1010c0af1e7b50000bfff1d8e_1440w.jpg" alt="preview" style="zoom:80%;" /><p>权重W的另一种理解就是: 每一行对应一个分类的模板(原型)</p><p>图像被拉长成向量之后, 就可以看作是高维空间中的一个点. 如果你把线性分类器压缩到二维中<img src="https://pic2.zhimg.com/80/cfcb46408daa5353c38cb37e9bb6eb01_1440w.jpg" alt="img"></p><p>这个图就非常好理解了, W改变时, classifier旋转, b改变时, classifier平移.</p><p>权重和偏差是可以合并的, 这也是为什么日常使用时 它们有时会混淆.</p><p><img src="https://pic2.zhimg.com/80/3c69a5c87a43bfb07e2b59bfcbd2f149_1440w.jpg" alt="img"></p><p>在线性代数的角度上, 这个合并是显然无误的.</p><blockquote><p><strong>图像数据预处理</strong>：在上面的例子中，所有图像都是使用的原始像素值（从0到255）。在机器学习中，对于输入的特征做归一化（normalization）处理是常见的套路。而在图像分类的例子中，图像上的每个像素可以看做一个特征。在实践中，对每个特征减去平均值来<strong>中心化</strong>数据是非常重要的。在这些图片的例子中，该步骤意味着根据训练集中所有的图像计算出一个平均图像值，然后每个图像都减去这个平均值，这样图像的像素值就大约分布在[-127, 127]之间了。下一个常见步骤是，让所有数值分布的区间变为[-1, 1]。<strong>零均值的中心化</strong>是很重要的，等我们理解了梯度下降后再来详细解释。</p></blockquote><hr><h4 id="Loss"><a href="#Loss" class="headerlink" title="Loss"></a>Loss</h4><p>$x_i, y_i都是确定的,我们只能调整权重矩阵W$</p><ul><li><p>多类支持向量机Loss (Multiclass Support Vector Machine Loss)</p><ul><li>希望SVM在正确分类上的得分始终比不正确分类上的得分高出一个∆以上. 可以去线性分类2中查看具体逻辑.</li><li>下图能够很清楚的描述SVMLoss的思想</li></ul><p><img src="https://pic1.zhimg.com/80/f254bd8d072128f1088c8cc47c3dff58_1440w.jpg" alt="img"></p><ul><li>只要 <code>错误的分类</code>的得分达到了红色的区间 甚至更高, Loss Function就开始工作</li></ul><p>正则化损失(用来处理权重矩阵的等效放大问题)和SVMLoss的具体工作函数, 移步<a href="https://zhuanlan.zhihu.com/p/20945670?refer=intelligentunit">CS231n 线性分类2</a></p></li><li><p>Softmax分类器</p><ul><li>有点难, 移步<a href="https://zhuanlan.zhihu.com/p/21102293?refer=intelligentunit">CS231n 线性分类3</a></li></ul></li></ul><hr>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme=auto><head>  <meta charset="UTF-8">  <link rel="apple-touch-icon" sizes="76x76" href="/banner&amp;index_img/avatar1.png">  <link rel="icon" href="/banner&amp;index_img/avatar1.png">  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">  <meta http-equiv="x-ua-compatible" content="ie=edge">      <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">    <meta name="theme-color" content="#2f4154">  <meta name="author" content="Natsumi">  <meta name="keywords" content="">      <meta name="description" content="This is the personal blog of natsumi, welcome"><meta property="og:type" content="website"><meta property="og:title" content="Natsumi&#39;s Mementos"><meta property="og:url" content="https://www.mementos.top/index.html"><meta property="og:site_name" content="Natsumi&#39;s Mementos"><meta property="og:description" content="This is the personal blog of natsumi, welcome"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="Natsumi"><meta name="twitter:card" content="summary_large_image">        <title>Natsumi&#39;s Mementos</title>  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" /><!-- 主题依赖的图标库，不要自行修改 --><!-- Do not modify the link that theme dependent icons --><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link  rel="stylesheet" href="/css/main.css" />  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />      <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/scroll.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/gradient.css">  <script id="fluid-configs">    var Fluid = window.Fluid || {};    Fluid.ctx = Object.assign({}, Fluid.ctx)    var CONFIG = {"hostname":"www.mementos.top","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/banner&index_img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};    if (CONFIG.web_analytics.follow_dnt) {      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));    }  </script>  <script  src="/js/utils.js" ></script>  <script  src="/js/color-schema.js" ></script>    <meta name="generator" content="Hexo 7.3.0"></head><body>    <header>    <div class="header-inner" style="height: 100vh;">  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">  <div class="container">    <a class="navbar-brand" href="/">      <strong>Natsumi&#39;s Mementos</strong>    </a>    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"            data-target="#navbarSupportedContent"            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">      <div class="animated-icon"><span></span><span></span><span></span></div>    </button>    <!-- Collapsible content -->    <div class="collapse navbar-collapse" id="navbarSupportedContent">      <ul class="navbar-nav ml-auto text-center">                                                            <li class="nav-item">              <a class="nav-link" href="/" target="_self">                <i class="iconfont icon-home-fill"></i>                <span>HOME</span>              </a>            </li>                                                                      <li class="nav-item">              <a class="nav-link" href="/categories/" target="_self">                <i class="iconfont icon-category-fill"></i>                <span>分类</span>              </a>            </li>                                                                      <li class="nav-item">              <a class="nav-link" href="/tags/" target="_self">                <i class="iconfont icon-tags-fill"></i>                <span>标签</span>              </a>            </li>                                                                      <li class="nav-item">              <a class="nav-link" href="/about/" target="_self">                <i class="iconfont icon-user-fill"></i>                <span>关于</span>              </a>            </li>                                                                      <li class="nav-item">              <a class="nav-link" href="/links/" target="_self">                <i class="iconfont icon-link-fill"></i>                <span>友链</span>              </a>            </li>                                                                      <li class="nav-item">              <a class="nav-link" href="/Road2AI/" target="_self">                <i class="iconfont icon-link-fill"></i>                <span>Rad2AI</span>              </a>            </li>                                    <li class="nav-item" id="search-btn">            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">              <i class="iconfont icon-search"></i>            </a>          </li>                                    <li class="nav-item" id="color-toggle-btn">            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">              <i class="iconfont icon-dark" id="color-toggle-icon"></i>            </a>          </li>              </ul>    </div>  </div></nav>  <div id="banner" class="banner" parallax=true     style="background: url('/banner&index_img/p1.jpg') no-repeat center center; background-size: cover;">  <div class="full-bg-img">    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">      <div class="banner-text text-center fade-in-up">        <div class="h2">                      <span id="subtitle" data-typed-text="Don&#39;t be sorry, be better."></span>                  </div>              </div>              <div class="scroll-down-bar">          <i class="iconfont icon-arrowdown"></i>        </div>          </div>  </div></div></div>  </header>  <main>          <div class="container nopadding-x-md">        <div id="board"          style="margin-top: 0">                    <div class="container">            <div class="row">              <div class="col-12 col-md-10 m-auto">                  <div class="row mx-auto index-card">              <div class="col-12 col-md-4 m-auto index-img">        <a href="/2021/11/24/ComSec&amp;Crypto%20%E7%BB%BC%E8%BF%B0/" target="_self">          <img src="/banner&amp;index_img/default.png" srcset="/banner&index_img/loading.gif" lazyload alt="ComSec &amp; Crypto 综述">        </a>      </div>        <article class="col-12 col-md-8 mx-auto index-info">      <h2 class="index-header">                <a href="/2021/11/24/ComSec&amp;Crypto%20%E7%BB%BC%E8%BF%B0/" target="_self">          ComSec &amp; Crypto 综述        </a>      </h2>            <a class="index-excerpt " href="/2021/11/24/ComSec&amp;Crypto%20%E7%BB%BC%E8%BF%B0/" target="_self">        <div>                  </div>      </a>      <div class="index-btm post-metas">                  <div class="post-meta mr-3">            <i class="iconfont icon-date"></i>            <time datetime="2021-11-24 20:46" pubdate>              2021-11-24            </time>          </div>                          <div class="post-meta mr-3 d-flex align-items-center">            <i class="iconfont icon-category"></i>            <span class="category-chains">              <span class="category-chain">          <a href="/categories/ComSec/" class="category-chain-item">ComSec</a>        <span>></span>      <a href="/categories/ComSec/Crypto/" class="category-chain-item">Crypto</a>            </span>      </span>          </div>                          <div class="post-meta">            <i class="iconfont icon-tags"></i>                          <a href="/tags/ComSec/">#ComSec</a>                      </div>              </div>    </article>  </div>  <div class="row mx-auto index-card">              <div class="col-12 col-md-4 m-auto index-img">        <a href="/2013/07/13/rebirth/" target="_self">          <img src="/banner&amp;index_img/default.png" srcset="/banner&index_img/loading.gif" lazyload alt="rebirth">        </a>      </div>        <article class="col-12 col-md-8 mx-auto index-info">      <h2 class="index-header">                <a href="/2013/07/13/rebirth/" target="_self">          rebirth        </a>      </h2>            <a class="index-excerpt " href="/2013/07/13/rebirth/" target="_self">        <div>                  </div>      </a>      <div class="index-btm post-metas">                  <div class="post-meta mr-3">            <i class="iconfont icon-date"></i>            <time datetime="2013-07-13 20:46" pubdate>              2013-07-13            </time>          </div>                          <div class="post-meta mr-3 d-flex align-items-center">            <i class="iconfont icon-category"></i>            <span class="category-chains">              <span class="category-chain">          <a href="/categories/1/" class="category-chain-item">1</a>        <span>></span>      <a href="/categories/1/2/" class="category-chain-item">2</a>            </span>      </span>          </div>                          <div class="post-meta">            <i class="iconfont icon-tags"></i>                          <a href="/tags/1/">#1</a>                          <a href="/tags/2/">#2</a>                      </div>              </div>    </article>  </div>  <div class="row mx-auto index-card">              <div class="col-12 col-md-4 m-auto index-img">        <a href="/1976/04/01/Convolutional-Nerual-Network(Andrew%20Ng)/" target="_self">          <img src="/banner&amp;index_img/default.png" srcset="/banner&index_img/loading.gif" lazyload alt="Convolutional Nerual Network(Andrew Ng)">        </a>      </div>        <article class="col-12 col-md-8 mx-auto index-info">      <h2 class="index-header">                <a href="/1976/04/01/Convolutional-Nerual-Network(Andrew%20Ng)/" target="_self">          Convolutional Nerual Network(Andrew Ng)        </a>      </h2>            <a class="index-excerpt " href="/1976/04/01/Convolutional-Nerual-Network(Andrew%20Ng)/" target="_self">        <div>                  </div>      </a>      <div class="index-btm post-metas">                  <div class="post-meta mr-3">            <i class="iconfont icon-date"></i>            <time datetime="1976-04-01 15:53" pubdate>              1976-04-01            </time>          </div>                          <div class="post-meta mr-3 d-flex align-items-center">            <i class="iconfont icon-category"></i>            <span class="category-chains">              <span class="category-chain">          <a href="/categories/Deep-Learning/" class="category-chain-item">Deep Learning</a>          </span>      </span>          </div>                          <div class="post-meta">            <i class="iconfont icon-tags"></i>                          <a href="/tags/Deep-Learning/">#Deep Learning</a>                          <a href="/tags/Image-Processing/">#Image Processing</a>                      </div>              </div>    </article>  </div>  <div class="row mx-auto index-card">              <div class="col-12 col-md-4 m-auto index-img">        <a href="/1976/04/01/2022%20GameList/" target="_self">          <img src="/img/p5_futaba.jpg" srcset="/banner&index_img/loading.gif" lazyload alt="GameList">        </a>      </div>        <article class="col-12 col-md-8 mx-auto index-info">      <h2 class="index-header">                <a href="/1976/04/01/2022%20GameList/" target="_self">          GameList        </a>      </h2>            <a class="index-excerpt " href="/1976/04/01/2022%20GameList/" target="_self">        <div>                  </div>      </a>      <div class="index-btm post-metas">                  <div class="post-meta mr-3">            <i class="iconfont icon-date"></i>            <time datetime="1976-04-01 15:53" pubdate>              1976-04-01            </time>          </div>                          <div class="post-meta mr-3 d-flex align-items-center">            <i class="iconfont icon-category"></i>            <span class="category-chains">              <span class="category-chain">          <a href="/categories/Game/" class="category-chain-item">Game</a>          </span>      </span>          </div>                      </div>    </article>  </div>  <div class="row mx-auto index-card">              <div class="col-12 col-md-4 m-auto index-img">        <a href="/1976/04/01/Deep%20Learning(Andrew%20Ng)/" target="_self">          <img src="/banner&amp;index_img/default.png" srcset="/banner&index_img/loading.gif" lazyload alt="Deep Learning(Andrew Ng)">        </a>      </div>        <article class="col-12 col-md-8 mx-auto index-info">      <h2 class="index-header">                <a href="/1976/04/01/Deep%20Learning(Andrew%20Ng)/" target="_self">          Deep Learning(Andrew Ng)        </a>      </h2>            <a class="index-excerpt " href="/1976/04/01/Deep%20Learning(Andrew%20Ng)/" target="_self">        <div>                  </div>      </a>      <div class="index-btm post-metas">                  <div class="post-meta mr-3">            <i class="iconfont icon-date"></i>            <time datetime="1976-04-01 15:53" pubdate>              1976-04-01            </time>          </div>                          <div class="post-meta mr-3 d-flex align-items-center">            <i class="iconfont icon-category"></i>            <span class="category-chains">              <span class="category-chain">          <a href="/categories/Deep-Learning/" class="category-chain-item">Deep Learning</a>          </span>      </span>          </div>                          <div class="post-meta">            <i class="iconfont icon-tags"></i>                          <a href="/tags/Deep-Learning/">#Deep Learning</a>                          <a href="/tags/AI/">#AI</a>                      </div>              </div>    </article>  </div>  <div class="row mx-auto index-card">              <div class="col-12 col-md-4 m-auto index-img">        <a href="/1976/04/01/Introduction%20to%20Machine%20Learning/" target="_self">          <img src="/banner&amp;index_img/default.png" srcset="/banner&index_img/loading.gif" lazyload alt="Introduction to Machine Learning">        </a>      </div>        <article class="col-12 col-md-8 mx-auto index-info">      <h2 class="index-header">                <a href="/1976/04/01/Introduction%20to%20Machine%20Learning/" target="_self">          Introduction to Machine Learning        </a>      </h2>            <a class="index-excerpt " href="/1976/04/01/Introduction%20to%20Machine%20Learning/" target="_self">        <div>                  </div>      </a>      <div class="index-btm post-metas">                  <div class="post-meta mr-3">            <i class="iconfont icon-date"></i>            <time datetime="1976-04-01 15:53" pubdate>              1976-04-01            </time>          </div>                                  <div class="post-meta">            <i class="iconfont icon-tags"></i>                          <a href="/tags/AI/">#AI</a>                          <a href="/tags/Computation-tech/">#Computation tech</a>                      </div>              </div>    </article>  </div>  <div class="row mx-auto index-card">              <div class="col-12 col-md-4 m-auto index-img">        <a href="/1976/04/01/Leetcode%20Data%20Structure%20Note/" target="_self">          <img src="/banner&amp;index_img/default.png" srcset="/banner&index_img/loading.gif" lazyload alt="Leetcode Data Structure Note">        </a>      </div>        <article class="col-12 col-md-8 mx-auto index-info">      <h2 class="index-header">                <a href="/1976/04/01/Leetcode%20Data%20Structure%20Note/" target="_self">          Leetcode Data Structure Note        </a>      </h2>            <a class="index-excerpt " href="/1976/04/01/Leetcode%20Data%20Structure%20Note/" target="_self">        <div>                  </div>      </a>      <div class="index-btm post-metas">                  <div class="post-meta mr-3">            <i class="iconfont icon-date"></i>            <time datetime="1976-04-01 15:53" pubdate>              1976-04-01            </time>          </div>                                  <div class="post-meta">            <i class="iconfont icon-tags"></i>                          <a href="/tags/Programming/">#Programming</a>                          <a href="/tags/Data-Structure/">#Data Structure</a>                      </div>              </div>    </article>  </div>  <div class="row mx-auto index-card">              <div class="col-12 col-md-4 m-auto index-img">        <a href="/1976/04/01/Introduction%20to%20Database/" target="_self">          <img src="/banner&amp;index_img/default.png" srcset="/banner&index_img/loading.gif" lazyload alt="Introduction to database">        </a>      </div>        <article class="col-12 col-md-8 mx-auto index-info">      <h2 class="index-header">                <a href="/1976/04/01/Introduction%20to%20Database/" target="_self">          Introduction to database        </a>      </h2>            <a class="index-excerpt " href="/1976/04/01/Introduction%20to%20Database/" target="_self">        <div>                  </div>      </a>      <div class="index-btm post-metas">                  <div class="post-meta mr-3">            <i class="iconfont icon-date"></i>            <time datetime="1976-04-01 15:53" pubdate>              1976-04-01            </time>          </div>                                  <div class="post-meta">            <i class="iconfont icon-tags"></i>                          <a href="/tags/Computation-tech/">#Computation tech</a>                          <a href="/tags/Database/">#Database</a>                      </div>              </div>    </article>  </div>  <div class="row mx-auto index-card">              <div class="col-12 col-md-4 m-auto index-img">        <a href="/1976/04/01/VSCode%20Debug/" target="_self">          <img src="/banner&amp;index_img/default.png" srcset="/banner&index_img/loading.gif" lazyload alt="VSCode Debug">        </a>      </div>        <article class="col-12 col-md-8 mx-auto index-info">      <h2 class="index-header">                <a href="/1976/04/01/VSCode%20Debug/" target="_self">          VSCode Debug        </a>      </h2>            <a class="index-excerpt " href="/1976/04/01/VSCode%20Debug/" target="_self">        <div>                  </div>      </a>      <div class="index-btm post-metas">                  <div class="post-meta mr-3">            <i class="iconfont icon-date"></i>            <time datetime="1976-04-01 15:53" pubdate>              1976-04-01            </time>          </div>                                  <div class="post-meta">            <i class="iconfont icon-tags"></i>                          <a href="/tags/Programming/">#Programming</a>                      </div>              </div>    </article>  </div>  <div class="row mx-auto index-card">              <div class="col-12 col-md-4 m-auto index-img">        <a href="/1976/04/01/LeetcodeNotes/" target="_self">          <img src="/banner&amp;index_img/default.png" srcset="/banner&index_img/loading.gif" lazyload alt="Leetcode Notes">        </a>      </div>        <article class="col-12 col-md-8 mx-auto index-info">      <h2 class="index-header">                <a href="/1976/04/01/LeetcodeNotes/" target="_self">          Leetcode Notes        </a>      </h2>            <a class="index-excerpt " href="/1976/04/01/LeetcodeNotes/" target="_self">        <div>                  </div>      </a>      <div class="index-btm post-metas">                  <div class="post-meta mr-3">            <i class="iconfont icon-date"></i>            <time datetime="1976-04-01 15:53" pubdate>              1976-04-01            </time>          </div>                                  <div class="post-meta">            <i class="iconfont icon-tags"></i>                          <a href="/tags/Programming/">#Programming</a>                          <a href="/tags/Algorithm/">#Algorithm</a>                      </div>              </div>    </article>  </div>  <nav aria-label="navigation">    <span class="pagination" id="pagination">      <span class="page-number current">1</span><a class="page-number" href="/page/2/#board">2</a><a class="page-number" href="/page/3/#board">3</a><a class="extend next" rel="next" href="/page/2/#board"><i class="iconfont icon-arrowright"></i></a>    </span>  </nav>              </div>            </div>          </div>        </div>      </div>              <a id="scroll-top-button" aria-label="TOP" href="#" role="button">        <i class="iconfont icon-arrowup" aria-hidden="true"></i>      </a>              <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"     aria-hidden="true">  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">    <div class="modal-content">      <div class="modal-header text-center">        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">          <span aria-hidden="true">&times;</span>        </button>      </div>      <div class="modal-body mx-3">        <div class="md-form mb-5">          <input type="text" id="local-search-input" class="form-control validate">          <label data-error="x" data-success="v" for="local-search-input">关键词</label>        </div>        <div class="list-group" id="local-search-result"></div>      </div>    </div>  </div></div>          </main>  <footer>    <div class="footer-inner">      <div class="footer-content">       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>powered by Hexo</span></a>     </div>        </div>  </footer>  <!-- Scripts -->    <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />  <script>    NProgress.configure({"showSpinner":false,"trickleSpeed":100})    NProgress.start()    window.addEventListener('load', function() {      NProgress.done();    })  </script><script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script><script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script><script  src="/js/events.js" ></script><script  src="/js/plugins.js" ></script>  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>  <script>    (function (window, document) {      var typing = Fluid.plugins.typing;      var subtitle = document.getElementById('subtitle');      if (!subtitle || !typing) {        return;      }      var text = subtitle.getAttribute('data-typed-text');              typing(text);          })(window, document);  </script>      <script  src="/js/img-lazyload.js" ></script>    <script  src="/js/local-search.js" ></script>  <script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/DynamicRibbon.min.js"></script><!-- 主题的启动项，将它保持在最底部 --><!-- the boot of the theme, keep it at the bottom --><script  src="/js/boot.js" ></script>    <noscript>    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>  </noscript></body></html>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>实习trivial</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/182baeb82c71">CS231n 面向视觉识别的卷积神经网络｜笔记翻译</a></p><p><a href="http://t.zoukankan.com/limitlessun-p-9455015.html">笔记精简版</a></p><p><a href="https://www.scihub.net.cn/sci-hub/">SciHub文献库(DOI&#x2F;URL, 不支持检索)</a></p><hr><h2 id="目标检测-Object-Detection"><a href="#目标检测-Object-Detection" class="headerlink" title="目标检测 Object Detection"></a>目标检测 Object Detection</h2><ul><li>评估标准 <ul><li>IoU((Intersection over Union,  交并比)) &#x3D; Area of Overlap &#x2F; Area of Union</li><li>神经网络会输出很多个bonding box, 要做的事情是选出IOU最大的框</li></ul></li><li>目标检测的框 &#x3D;&gt;  bonding box<ul><li>通过回归算法完成, 线性回归box 的高、宽、中心点,  来确认box的位置</li></ul></li><li>目标检测中的 anchor<ul><li>最早在Faster R-CNN中提出</li><li>目标检测系统通过anchor来找到bonding box的位置. 和anchor之间的距离, 就能定位到bonding box</li></ul></li><li>目标检测中的AP: Average Precision </li><li><a href="https://www.cnblogs.com/makefile/p/nms.html">非极大值抑制, Non-Maximum Suppression</a><ul><li>局部最大搜索.  还是比对IOU, 找到得分最高的框</li></ul></li></ul><hr><h2 id="语义分割-Semantic-Segmentation"><a href="#语义分割-Semantic-Segmentation" class="headerlink" title="语义分割 Semantic Segmentation"></a>语义分割 Semantic Segmentation</h2><p><a href="https://arxiv.org/pdf/1505.04597.pdf">U-Net</a></p><p><a href="https://www.jiqizhixin.com/articles/2018-06-04-17">语义分割: 逐像素级的语义类别分类</a></p><ul><li>语义分割的流程：<ul><li>Input $\rightarrow$ Classifier $\rightarrow$ Post-Processing $\rightarrow$ Final Result</li></ul></li></ul><h2 id="实例分割-Instance-Segmentation"><a href="#实例分割-Instance-Segmentation" class="headerlink" title="实例分割 Instance Segmentation"></a>实例分割 Instance Segmentation</h2><p><a href="https://blog.csdn.net/qq_42722197/article/details/119901995?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-119901995.nonecase&spm=1018.2226.3001.4187">Instance Segmentation 综述</a></p><p>在我看来, 实例分割融合了两个问题: 语义分割(Semantic Segmentation) 和 目标检测(Object Detection) .  因此也衍生出了两种实例分割方法</p><ul><li><p>先进行目标检测, 找出实例所在区域, 然后再框内进行语义分割</p></li><li><p>先进行像素级的语义分割, 再通过聚类、度量学习等方式区分实例</p></li><li><p>在实例分割里, 我们需要将图片分割成不同的类, 还要区分出同一类中不同的实例. </p></li><li><p>在分割中 神经网络输出是mask, 它的每个通道(如果把它分离)就是一张单通道图片(类似掩码, 但像素值只有0&#x2F;255),  将mask和原图片异或, 就可以得到结果.</p></li></ul><hr><p>YOLO(you only look once) </p><ul><li>Redmon等在2016年提出的one-stage 目标检测算法. </li><li>将<code>目标检测问题</code>转化成了regression问题, 之前是分类问题. 提升了算法的精度</li><li>使用CNN直接从输入图像上预测目标所在位置和概率, 是end2end 算法.</li></ul><hr><p>FPN(feature pyramid networks)</p><ul><li>2017 CVPR发表. 采用特征金字塔来进行目标检测</li><li>之前的目标检测算法 一般只采用顶层特征做预测, 或者采用多尺度特征融合, 利用融合后的特征来预测. (说白了 只预测一次)</li><li>FPN的不同之处在于, 不同特征层之间独立进行预测. 利用特征的方式为: 顶层特征通过上采样和低层特征融合, 然后每层独立预测.</li></ul><hr><h2 id="科普"><a href="#科普" class="headerlink" title="科普"></a>科普</h2><h4 id="数据增强-Data-Augmentation"><a href="#数据增强-Data-Augmentation" class="headerlink" title="数据增强 Data Augmentation"></a>数据增强 Data Augmentation</h4><p>人工扩展数据集的技术. 是克服训练数据不足的有效手段. 但由于并不是真实的数据, 所以会产生一定的噪声.</p><ul><li>在CV中 对图片集进行数据增强是容易的, 只需引入噪声&#x2F;裁剪图像等, 也有专门的 imgaug库来完成这类工作. 而在NLP里, 数据增强主要是在落地时验证模型有效性时使用.</li></ul><h4 id="CV中的数据增强"><a href="#CV中的数据增强" class="headerlink" title="CV中的数据增强"></a>CV中的数据增强</h4><ul><li><h5 id="基于图像处理技术的数据增强"><a href="#基于图像处理技术的数据增强" class="headerlink" title="基于图像处理技术的数据增强"></a>基于图像处理技术的数据增强</h5><ul><li>Geometric Tranformations</li><li>Color Space: 图片被编码为张量后输入模型, 编码逻辑是(高x宽xRGB通道), 如果关闭某个颜色通道, 或者改变亮度, 就是数据增强</li><li>Rotation&#x2F;Reflection(反射变换) : 旋转图像, 这可以改变图像的内容朝向, 注意角度最好控制在1~20度</li><li>Noise Injection: 从高斯分布中采样出的随机值矩阵, 将它加入到RGB像素中, 这样可以给图像添加噪点</li><li>Kernel Filters: 锐化、模糊等. 将特定功能的内核滤镜与图像进行卷积, 就可以得到增强后的数据. </li><li>Mix: 平均图像像素值, 将图像混合在一起. 这种方法相当的counter-intuitive, 因为形成的图像在人看来是无意义的图像. 但确实有时能发挥作用</li><li>Random Erasing: 有些类似Dropout机制,  提升了图像被部分遮挡时的性能, 同时也可以确保网络关注的整个图像, 而非其中局部.</li><li>Translation(移动): 避免位置偏差. 注意诸如人脸数据集, 就不适合使用这种方法.</li><li>Cropping(裁剪) : 如果输入数据的大小是变化的, Cropping可以成为预处理的手段之一. 裁剪图像的中央色块, 得到新的数据</li></ul></li><li><h5 id="基于深度学习的数据增强算法-没看特别懂"><a href="#基于深度学习的数据增强算法-没看特别懂" class="headerlink" title="基于深度学习的数据增强算法(没看特别懂)"></a>基于深度学习的数据增强算法(没看特别懂)</h5><ul><li>Feature Space Augmentation: 神经网络可以将图像映射为低维向量, 所以可以在特征空间对特征向量进行操作.  比如将k个最近邻居合并来形成新的实例来缓解不平衡问题.</li><li>Adversarial Training(对抗攻击)</li><li>GAN-based Data Augmentation</li><li>Neural Style Transfer 神经风格转换</li></ul></li></ul><hr><p>测试集</p><ul><li>超参数的选取涉及到调优, 但要注意的是不应该使用测试集来调优, 这样会导致过拟合的问题, 只有最后才使用测试集, 模型的表现才能近似泛化性能.</li><li>超参数调优应该使用验证集</li></ul><p>Tensor</p><ul><li>多重线性映射或函数. 使得一个量在改变坐标系的时候仍然不变(只改变分量, 但物理量本身是不变的)</li><li>在我看来, 基向量有几个下标, 张量就是几阶张量.</li><li>scaler是0阶张量, 向量是一阶张量, 而比如应力(先决定力作用的平面, 再决定力的方向) 就属于二阶张量.</li></ul><p>stage </p><ul><li>是基于输入图片的shape改变来人为划分的, 每次下采样改变分辨率就可以进行stage的划分</li></ul><p>鲁棒性 ≈ Robust </p><ul><li>L1距离与L2距离(欧氏距离)  L2相比L1距离更能接受不那么大的差距，整体的相似容忍度要低于L1距离.</li></ul><p>SOTA 世界上最牛逼的 「state-of-the-art  」</p><p>nvidia-smi 查看当前显卡占用</p><p><a href="https://www.zhihu.com/question/30750849">敏感性、特异性</a></p><p>敏感性 上升 &#x3D;&gt; 绝不放过一个坏人(可能抓到好人)</p><p>特异性 上升 &#x3D;&gt; 绝不抓错一个好人(抓到的全是坏人) </p><p>python的数据处理</p><p>files &#x3D; os.listdir()</p><p>然后利用for循环遍历整个文件夹</p><p>记得使用os.path.join 文件名和文件相加</p><h3 id="pytorch的报错问题"><a href="#pytorch的报错问题" class="headerlink" title="pytorch的报错问题"></a>pytorch的报错问题</h3><p>加载&#x2F;调用模型时出现的问题</p><ul><li>PytorchStreamReader failed reading zip archive: failed finding central directory<ul><li>模型在传输中损坏了，即使文件完全一样大，也可能会出现这样的问题(猜测是提前分配好了磁盘空间，但文件并没有完全写入)</li></ul></li><li>AttributeError: Colletor 没有各种各样的属性<ul><li>下载pytorch官方的模型时，下载下的pth文件其实是只包含参数的，print一下就知道了。 所以先save(不使用state_dict 而是直接save), 这样就能得到包含网络结构的模型，即可成功调用</li></ul></li><li>ValueError: num_samples should be a positive integer value, but got num_samples&#x3D;0<ul><li>发生在dataloader函数的使用上，这是因为你的input_size可能设置的不对，导致没有可以满足的图片. 或者可能是shuffle的问题，不shuffle才行</li></ul></li></ul><hr><h2 id="To-do-list"><a href="#To-do-list" class="headerlink" title="To do list"></a>To do list</h2><h5 id="阅读经典-「重点看研究方法」"><a href="#阅读经典-「重点看研究方法」" class="headerlink" title="阅读经典 「重点看研究方法」"></a>阅读经典 「重点看研究方法」</h5><ul><li>RCNN,  YOLO</li><li>DEEPLEAB </li><li>UNet, (++)</li><li>ResNet</li></ul><h2 id="Log-SOLOv2"><a href="#Log-SOLOv2" class="headerlink" title="Log(SOLOv2)"></a>Log(SOLOv2)</h2><h4 id="5-20"><a href="#5-20" class="headerlink" title="5.20"></a>5.20</h4><p><a href="https://zhuanlan.zhihu.com/p/379249152">https://zhuanlan.zhihu.com/p/379249152</a></p><p>官方的SOLOv2 没有windows版</p><ul><li>配置所需环境<ul><li>环境需要VisualStudio， 要添加vs的环境变量</li><li>mmcv bug实在太多，放弃， 转而尝试用</li></ul></li><li>下载labelme  准备对coco数据集进行处理<ul><li>PyQt5 下不下来</li></ul></li></ul><h4 id="5-23"><a href="#5-23" class="headerlink" title="5.23"></a>5.23</h4><p>决定使用ubuntu 16.04来完成项目</p><p>系统账户名：natsumi-MS-7c98</p><p>系统初始化流程：</p><ul><li>下载NV显卡驱动和cuda（这部分最容易崩溃）<ul><li><a href="https://blog.csdn.net/CAIYUNFREEDOM/article/details/97616855">安装驱动</a></li><li><a href="https://blog.csdn.net/huohuotu/article/details/77504215?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0-77504215-blog-50095409.pc_relevant_default&spm=1001.2101.3001.4242.1&utm_relevant_index=3">解决tyy模式下乱码问题</a><ul><li>原来的内容： “zh_CN.UTF-8”   |   “zh_CN:zh” </li><li>说白了，中文编码错了。 你可以强行把要去的地方给改成英文</li></ul></li></ul></li><li>下载anaconda、vscode等工具<ul><li><a href="https://blog.csdn.net/marleylee/article/details/70739131">安装.sh文件</a></li></ul></li></ul><h4 id="5-24"><a href="#5-24" class="headerlink" title="5.24"></a>5.24</h4><p><a href="https://blog.csdn.net/weixin_43776003/article/details/117740648">复现蓝本</a></p><p>显卡驱动、cuda、anaconda、opencv、pytorch环境搭建完毕</p><p>需要等待github open出来之后再git </p><p>pip install ‘git+<a href="https://github.com/cocodataset/cocoapi.git#subdirectory=PythonAPI">https://github.com/cocodataset/cocoapi.git#subdirectory=PythonAPI</a>‘</p><p>pip install importlib</p><p>下载detectron 失败</p><p>git clone <a href="https://github.com/facebookresearch/detectron2.git">https://github.com/facebookresearch/detectron2.git</a></p><p>cd detectron2</p><p>python setup.py build develop</p><h4 id="5-26"><a href="#5-26" class="headerlink" title="5.26"></a>5.26</h4><ul><li>安装完毕detectron和AdelaiDet</li><li>跑了demo</li></ul><h4 id="5-27"><a href="#5-27" class="headerlink" title="5.27"></a>5.27</h4><ul><li><p>尝试使用自己的数据集训练</p><ul><li><p>注意在评估时需要提供json，命名为 instances_line_val.json</p></li><li><p>修改文件：</p><ul><li>AdelaiDat&#x2F;adet&#x2F;data -&gt; builtin.py </li><li>AdelaiDat&#x2F;configs&#x2F;SOLOv2 -&gt; Base-SOLOv2.yaml<ul><li>修改了训练和测试的文件路径</li></ul></li></ul></li><li><p>缺少google protobuf包，在编译python包之前 还需要下载protoc ，并且直接使用apt-get下载的protoc版本不对，需要手动下载（必须下载32位的），不过使用apt-get下载的protoc不是完全没用，用cp命令 将我们下载的低版本exe换成我们下载出的新版本exe</p></li></ul></li><li><p>修改完成后 训练开始</p></li></ul><h4 id="5-31"><a href="#5-31" class="headerlink" title="5.31"></a>5.31</h4><ul><li>测试时有一个数据集注册问题。是text生成问题</li><li>控制分类类别的地方是 &#x2F;adet&#x2F;data  builtin.py  其中的metadata_pic结构</li><li>由于原来的训练集类别标注顺序有问题，所以以A24测试集作为范本来训练</li></ul><h4 id="6-1"><a href="#6-1" class="headerlink" title="6.1"></a>6.1</h4><ul><li>发现将A23和原来的训练集合并之后生成的json可以对的上分类类别，因此把合并之后的作为训练集，总共550张图片</li><li>使用labelme时，发现无法打开。本质上是没安装qt的一个库<ul><li><a href="https://www.jb51.net/article/193024.htm">解决方案</a></li></ul></li></ul><h4 id="6-8"><a href="#6-8" class="headerlink" title="6.8"></a>6.8</h4><ul><li>原来的模型效果不好，所以更换为参数数量更多，模型更复杂的R101_3x。 但由于第一天的训练未使得loss收敛，因此合并训练和测试集来增加数据量，看看是否能够达到收敛。</li></ul>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="92106dee377e6fd51581420ae03321098c54e7764b6ae591e2453eac5c0e5d5d">d5a264002618c049c19ffd39573eb47198420f2cb9a893abac62c394e807740ba230d03f2be02ebe8c32a8baa2bfb0b93515978466f6478aa28e4bf9672a4b1f58e946394eb96e8e6f1fb5983c6acb8174733521001b776cde9d45f3375db0ef8bd9b3dbdc262e545309aaf7353b448122700d7adfa3dd551c9456e0a2a8480b1f1c7d4b481d4021249216e495d74641bbc31089e2e2e996194c2ceb32e8abbf1da374bc4a05108576cc126fefe972afec4b64606415f9ae441f02141e8a565bad3c18f63d23835c94c90a3e1a5e0a739e556791812b407f23144a304dcdba566526b5dd8f1d540c29f8162a48929d3f359e1f99e1571e8fecd4629603df8adb0681ea84d58de7fce3c576c2f3280b0cbc937bb05f62d7a5ba4360781af2ea43b16f25951000abb4fa67004758c12ec3980fd5b3abad6900807c62e5470b81b2ed2beb9f055e8c738920fad556db9897</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
  </entry>
  
  
  
</search>
