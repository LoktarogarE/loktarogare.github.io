

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar1.png">
  <link rel="icon" href="/img/avatar1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Natsumi">
  <meta name="keywords" content="">
  
    <meta name="description" content="#SP edition 信息社会传奇 信息网络 能源 交通 是现代社会的三大基础 数据$\Rightarrow$  传输和存储的 可识别的数字符号 信息交互 (一对一 一对多 多对多) 有效性 安全性   计算机网络$\Rightarrow$ 将计算机或外部设备连接在一起，实现 信息交互和应用服务的设备 通信链路 通信规约和软件的集合   因特网 $\Rightarrow$ 特指由美国创建和管理的">
<meta property="og:type" content="article">
<meta property="og:title" content="互联网原理">
<meta property="og:url" content="https://www.mementos.top/1976/04/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Natsumi&#39;s Mementos">
<meta property="og:description" content="#SP edition 信息社会传奇 信息网络 能源 交通 是现代社会的三大基础 数据$\Rightarrow$  传输和存储的 可识别的数字符号 信息交互 (一对一 一对多 多对多) 有效性 安全性   计算机网络$\Rightarrow$ 将计算机或外部设备连接在一起，实现 信息交互和应用服务的设备 通信链路 通信规约和软件的集合   因特网 $\Rightarrow$ 特指由美国创建和管理的">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="1976-04-01T07:53:17.000Z">
<meta property="article:modified_time" content="2022-06-02T08:41:02.000Z">
<meta property="article:author" content="Natsumi">
<meta property="article:tag" content="Computer Network">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>互联网原理 - Natsumi&#39;s Mementos</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/scroll.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/gradient.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.mementos.top","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Natsumi&#39;s Mementos</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>🏠</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="互联网原理"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="1976-04-01 15:53" pubdate>
          1976年4月1日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          23k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          229 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">互联网原理</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="SP-edition-信息社会传奇"><a href="#SP-edition-信息社会传奇" class="headerlink" title="#SP edition 信息社会传奇"></a>#SP edition 信息社会传奇</h1><ul>
<li><strong>信息网络 能源 交通 是现代社会的三大基础</strong></li>
<li><strong>数据$\Rightarrow$  传输和存储的 可识别的数字符号</strong></li>
<li>信息交互 (一对一 一对多 多对多)<ul>
<li>有效性</li>
<li>安全性</li>
</ul>
</li>
<li><strong>计算机网络$\Rightarrow$ 将计算机或外部设备连接在一起，实现 <u>信息交互和应用服务</u>的设备 通信链路 通信规约和软件的集合</strong></li>
</ul>
<ul>
<li>因特网 $\Rightarrow$ 特指由美国创建和管理的全球互联网</li>
</ul>
<hr>
<h4 id="计算机网络发展-Web发展-快速发展期"><a href="#计算机网络发展-Web发展-快速发展期" class="headerlink" title="计算机网络发展(Web发展&#x2F;快速发展期)"></a>计算机网络发展(Web发展&#x2F;快速发展期)</h4><ul>
<li>Tim Berners-Lee 1989年提出了 Web， 1991年开通了第一个 WWW网站<a target="_blank" rel="noopener" href="https://info.cern.ch/">https://info.cern.ch/</a>  1993年制定了全球信息浏览的Web规范</li>
<li>1994年8月11日 netMarket公司 建立了第一个电子商务网站并完成了全球第一笔网络零售交易</li>
<li>1995年 杰夫·贝佐斯创建了 Amazon</li>
<li>1994年4月20日 中国科学技术网成功和Internet连接(64k&#x2F;s)</li>
<li>1994年10月 Grand Juction公司推出第一套快速以太网</li>
<li>1995年3月 IEEE宣布了快速以太网标准 Fast Ethernet LAN进入100M时代</li>
<li>1997年6月 IEEE802.11标准出台 无线网络代替了有线网络实现高效 高速的联网方案 (WIFI)</li>
<li>1998～1999 高速以太网标准形成 </li>
<li>1998年9月7日 Google成立 &#x2F; qq出现</li>
<li>2001年 万兆以太网出现(有线)(用于组网核心 城域网)</li>
<li>2004年 Mark Zuckerberg 建立Facebook</li>
<li>2006年 Twitter出现</li>
<li>2007年6月29日 Steve Jobs的iPhone上市 移动互联网时代开启</li>
<li>2007年11月 Google发起的手机联盟推出Android 以Apache开源许可证的授权方式开放源代码</li>
</ul>
<hr>
<h4 id="计算机网络提供的服务"><a href="#计算机网络提供的服务" class="headerlink" title="计算机网络提供的服务"></a>计算机网络提供的服务</h4><p><strong><u>三大核心$\Rightarrow$应用 交互 管理</u></strong></p>
<ol>
<li>网络应用服务</li>
<li>具体联网和信息交互(解决不同速率 距离 成本需要的组网技术) 1973年 Vinton Cerf&#x2F;Robert Kahn指出不可能存在能满足所有需求的单一分组网络技术</li>
<li>大规模的组网和信息交互技术</li>
<li>网络辅助技术 解决网络运行时的问题</li>
</ol>
<hr>
<h4 id="计算机网络应用"><a href="#计算机网络应用" class="headerlink" title="计算机网络应用"></a>计算机网络应用</h4><p>互联网网络应用(服务) 建立在TCP&#x2F;IP协议之上的应用服务</p>
<p>连接 $\Rightarrow$ 联合</p>
<p>早期的Internet应用 Telnet(远程计算机访问) Email FTP(文件传送) Newsgroup(新闻组) BBS论坛</p>
<h5 id="应用的发展过程"><a href="#应用的发展过程" class="headerlink" title="应用的发展过程"></a>应用的发展过程</h5><p>E-mail FTP $\Rightarrow$ 静态网页 $\Rightarrow$ 动态网页 $\Rightarrow$ 网上营销 $\Rightarrow$ 电子商务 $\Rightarrow$ 移动应用服务</p>
<p>宏观来看 信息交互 $\Rightarrow$ 综合业务应用 多媒体应用 $\Rightarrow$ 物联网 云计算应用</p>
<h5 id="万维网-World-Wide-Web"><a href="#万维网-World-Wide-Web" class="headerlink" title="万维网 World Wide Web"></a>万维网 World Wide Web</h5><p>万维网起源于欧洲粒子物理研究中心CERN </p>
<p>核心创新： 广泛关联 文档定位 文档快速传输 多格式文档阅读</p>
<p>网页(超文本) 表达的不再是线性的信息 而是非线性 联想式 信息关联的信息网。 Web表示这种由超文本连接起来的信息网</p>
<p>网址 $\Rightarrow$ 统一资源定位符 URL (Uniform Resource Locator)</p>
<p><a target="_blank" rel="noopener" href="http://www.baidu.com/view/25482.htm">http://www.baidu.com/view/25482.htm</a></p>
<p> $\Uparrow$                     $\Uparrow$                              $\Uparrow$</p>
<p>Protocol       Name of Computer    Index and File name</p>
<p>支持缺省输入(支持默认)</p>
<h6 id="指定URL后-如何传输？"><a href="#指定URL后-如何传输？" class="headerlink" title="指定URL后 如何传输？"></a>指定URL后 如何传输？</h6><p>浏览器按URL链接服务器 请求服务 $\Rightarrow$ 网页服务器应答 返回 $\Rightarrow$ 浏览器完成解析之后显示网页</p>
<p>使用超文本传输协议HTTP 让网站和浏览器协商进行网页传输</p>
<h6 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h6><p>基本功能 $\Rightarrow$ 输入选取URL时 向Web服务器发送请求 接收文档 进行解析和显示</p>
<hr>
<h1 id="Chapter1-E-mail-WWW"><a href="#Chapter1-E-mail-WWW" class="headerlink" title="Chapter1 E-mail &amp;&amp; WWW"></a>Chapter1 E-mail &amp;&amp; WWW</h1><h1 id="E-MAIL-系统概述"><a href="#E-MAIL-系统概述" class="headerlink" title="E-MAIL 系统概述"></a>E-MAIL 系统概述</h1><h3 id="⚠️-邮件系统-在大型机上不同邮箱移动报文时-就已经出现了-它的出现至少不晚于Internet"><a href="#⚠️-邮件系统-在大型机上不同邮箱移动报文时-就已经出现了-它的出现至少不晚于Internet" class="headerlink" title="⚠️ 邮件系统 在大型机上不同邮箱移动报文时 就已经出现了 (它的出现至少不晚于Internet)"></a>⚠️ 邮件系统 在大型机上不同邮箱移动报文时 就已经出现了 (它的出现至少不晚于Internet)</h3><h5 id="而我们使用的-所谓-E-Mail-则是-特指通过计算机网络进行通信的-电子化信息传递系统"><a href="#而我们使用的-所谓-E-Mail-则是-特指通过计算机网络进行通信的-电子化信息传递系统" class="headerlink" title="而我们使用的 所谓 E-Mail 则是 特指通过计算机网络进行通信的 电子化信息传递系统"></a>而我们使用的 所谓 E-Mail 则是 特指通过计算机网络进行通信的 电子化信息传递系统</h5><h5 id="E-Mail-是-Internet上-使用最广泛的应用"><a href="#E-Mail-是-Internet上-使用最广泛的应用" class="headerlink" title="E-Mail 是 Internet上 使用最广泛的应用"></a>E-Mail 是 Internet上 使用最广泛的应用</h5><p>E-Mail定义了SMTP 和 MIME </p>
<h5 id="电子邮件需要实现以下的几个功能"><a href="#电子邮件需要实现以下的几个功能" class="headerlink" title="电子邮件需要实现以下的几个功能"></a>电子邮件需要实现以下的几个功能</h5><ol>
<li>创建电子邮件</li>
<li>发送和接收邮件</li>
<li>管理邮件 「管理：包括回复 转发 删除 存储 等等」</li>
<li>保证邮箱的私有性质 「虽然任何人都可以在邮箱里放入邮件 但只有邮箱的拥有者可以查看」</li>
</ol>
<h3 id="E-Mail的地址结构"><a href="#E-Mail的地址结构" class="headerlink" title="E-Mail的地址结构"></a>E-Mail的地址结构</h3><p>一般认为 邮箱地址要保证唯一  需要 <strong>邮箱名+存放邮箱的主机域名</strong></p>
<p><a href="mailto:&#x31;&#51;&#53;&#x37;&#48;&#48;&#48;&#x32;&#55;&#52;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#x6d;">&#x31;&#51;&#53;&#x37;&#48;&#48;&#48;&#x32;&#55;&#52;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#x6d;</a> $\Rightarrow$ 1357000274 为邮箱名 ｜  qq.com 存放邮箱的主机域名</p>
<h2 id="SMTP-Simple-Mail-Transfer-Protocol"><a href="#SMTP-Simple-Mail-Transfer-Protocol" class="headerlink" title="SMTP Simple Mail Transfer Protocol"></a>SMTP Simple Mail Transfer Protocol</h2><ul>
<li>1981年出现 **它只能传输字符 信息主体被限制为 ASCII码 **</li>
<li>SMTP 规定相互通信的 C&#x2F;S端两个 SMTP进程间如何进行信息交互</li>
<li>⚠️ SMTP没有定义 邮件采用何种格式 以及 如何存储邮件 发送和递交邮件</li>
</ul>
<h3 id="SMTP传送的过程"><a href="#SMTP传送的过程" class="headerlink" title="SMTP传送的过程"></a>SMTP传送的过程</h3><ul>
<li>类似上图 用户按照格式填装邮件 输入发送命令后 电子邮件接口软件 首先将这个邮件放在 邮件暂存队列里</li>
<li>对邮件的控制权此时来到了 <strong>邮件传输程序</strong>这里。 它将判断这封邮件发往哪里。「可以发送给 本地的计算机」</li>
<li>如果要向互联网远程用户发送邮件 在确认连接互联网后 <strong>邮件传输软件作为客户 和 邮件服务器进行通信(它在远程计算机上)， 传输软件会将 邮件的 一个<em>副本</em>发送到邮件服务器上</strong></li>
<li>邮件现在来到了邮件缓存区 发送方SMTP软件会定时(几分钟或几时分钟)扫描缓冲区队列</li>
<li>如果SMTP软件检测到了待发邮件 它就会 <strong>作为客户和目的计算机SMTP服务器端口(25)建立TCP连接</strong><ul>
<li>服务器发出 220 Service ready  客户端发送 helo + 邮箱+主机名；</li>
<li>服务器如果可以接收 会应答 250 OK 否则返回代码 421 Service not available | 451 &#x2F; 452 等异常命令<ul>
<li>SMTP定义了 14条命令(由4个字母组成) 和 21种应答(由3个数字开始)</li>
</ul>
</li>
<li>开始传输邮件副本</li>
</ul>
</li>
<li><strong>由客户端在发送结束后 通过 QUIT 命令释放TCP连接</strong></li>
</ul>
<h3 id="SMTP-是复杂的协商交互协议-通常会在后台工作-因为邮件系统从来就不是一个实时传输新系统"><a href="#SMTP-是复杂的协商交互协议-通常会在后台工作-因为邮件系统从来就不是一个实时传输新系统" class="headerlink" title="SMTP 是复杂的协商交互协议 通常会在后台工作(因为邮件系统从来就不是一个实时传输新系统)"></a>SMTP 是复杂的协商交互协议 通常会在后台工作(因为邮件系统从来就不是一个实时传输新系统)</h3><h3 id="SMTP可以用在两个用户之间-但主流情况下-使用-邮局和中转的概念「分发-转发-列表-按照列表分发-多重接收-同一个计算机上的多个邮箱-只建立一个TCP连接-」"><a href="#SMTP可以用在两个用户之间-但主流情况下-使用-邮局和中转的概念「分发-转发-列表-按照列表分发-多重接收-同一个计算机上的多个邮箱-只建立一个TCP连接-」" class="headerlink" title="SMTP可以用在两个用户之间 但主流情况下 使用 邮局和中转的概念「分发 转发 列表(按照列表分发) 多重接收(同一个计算机上的多个邮箱 只建立一个TCP连接)」"></a>SMTP可以用在两个用户之间 但主流情况下 使用 邮局和中转的概念「分发 转发 列表(按照列表分发) 多重接收(同一个计算机上的多个邮箱 只建立一个TCP连接)」</h3><p><strong>邮件中继：</strong> 当需要进行 <strong>大量的</strong>的邮件转发&#x2F;分发时 一个独立且能力更强的计算机<strong>E-Mail Gateway &#x2F; E-Mail Relay</strong> 出现了</p>
<p>组织地址：它帮助每个自己管理下的计算机完成邮件的收发「这个组织通常会运行一个组织网关来管理」</p>
<p><strong>邮件网关实际隔离外部邮件地址与内部邮件地址(计算机与用户)</strong></p>
<h2 id="MIME-Multipurpose-Internet-Mail-Extension"><a href="#MIME-Multipurpose-Internet-Mail-Extension" class="headerlink" title="MIME Multipurpose Internet Mail Extension"></a>MIME Multipurpose Internet Mail Extension</h2><h3 id="邮件在这个协议里-被允许-分成几个部分-每个部分可以通过不同的格式来传送"><a href="#邮件在这个协议里-被允许-分成几个部分-每个部分可以通过不同的格式来传送" class="headerlink" title="邮件在这个协议里 被允许 分成几个部分 每个部分可以通过不同的格式来传送"></a>邮件在这个协议里 被允许 分成几个部分 每个部分可以通过不同的格式来传送</h3><ul>
<li>头部 「发、收地址 日期 主题等条目  每个头部行开始是 行关键字和冒号 + 信息」</li>
<li>空行 用来分割 头部和信息文本</li>
<li>信息文本   包含了 多媒体二进制信息 可以实现任意编辑</li>
</ul>
<h2 id="存储传送方式-非端到端直接传送-｜-POP-IMAP"><a href="#存储传送方式-非端到端直接传送-｜-POP-IMAP" class="headerlink" title="存储传送方式(非端到端直接传送) ｜ POP &amp; IMAP"></a>存储传送方式(非端到端直接传送) ｜ POP &amp; IMAP</h2><p>在目前邮箱通常被放在电子邮件系统服务器计算机上 接受者要自己去邮件服务器 读自己的邮件 而不是它主动发给你</p>
<h3 id="常用的-远程读取的邮局协议POP-Post-Office-Protocol-1996-POP3-IMAP-Internet-Mail-Access-Protocol"><a href="#常用的-远程读取的邮局协议POP-Post-Office-Protocol-1996-POP3-IMAP-Internet-Mail-Access-Protocol" class="headerlink" title="常用的 远程读取的邮局协议POP(Post Office Protocol)(1996 POP3) | IMAP(Internet Mail Access Protocol)"></a>常用的 远程读取的邮局协议POP(Post Office Protocol)(1996 POP3) | IMAP(Internet Mail Access Protocol)</h3><p>用户计算机的电子邮件软件作为POP服务器的客户 来存取</p>
<h3 id="POP相比SMTP的优越性-rightarrow-POP不进行传输交互"><a href="#POP相比SMTP的优越性-rightarrow-POP不进行传输交互" class="headerlink" title="POP相比SMTP的优越性 $\rightarrow$ POP不进行传输交互"></a>POP相比SMTP的优越性 $\rightarrow$ POP不进行传输交互</h3><p>pop主要完成 创建连接 用户认证 事务操作(列出 取回并删除等等) ｜ 邮件将在被读取后的不久被POP删除</p>
<h3 id="IMAP-2003-IMAP4-和POP3一样采用C-S方式来工作-但比POP3复杂-用户能进行更多的操作-比如只看首部-并且在不下令删除的情况下保留用户的邮件"><a href="#IMAP-2003-IMAP4-和POP3一样采用C-S方式来工作-但比POP3复杂-用户能进行更多的操作-比如只看首部-并且在不下令删除的情况下保留用户的邮件" class="headerlink" title="IMAP (2003 IMAP4) 和POP3一样采用C&#x2F;S方式来工作 但比POP3复杂(用户能进行更多的操作 比如只看首部) 并且在不下令删除的情况下保留用户的邮件"></a>IMAP (2003 IMAP4) 和POP3一样采用C&#x2F;S方式来工作 但比POP3复杂(用户能进行更多的操作 比如只看首部) 并且在不下令删除的情况下保留用户的邮件</h3><h3 id="目前-具有大邮箱数据库和SMTP-POP服务器-中继功能的计算机-相当于电子邮局"><a href="#目前-具有大邮箱数据库和SMTP-POP服务器-中继功能的计算机-相当于电子邮局" class="headerlink" title="目前 具有大邮箱数据库和SMTP&#x2F;POP服务器+中继功能的计算机 相当于电子邮局"></a>目前 具有大邮箱数据库和SMTP&#x2F;POP服务器+中继功能的计算机 相当于电子邮局</h3><h2 id="E-Mail传递的发展"><a href="#E-Mail传递的发展" class="headerlink" title="E-Mail传递的发展"></a>E-Mail传递的发展</h2><ol>
<li>两个主机间点对点的 SMTP邮件直接收发</li>
<li>邮件网关(中继) 和组织邮件地址 出现中间管理服务</li>
<li>电子邮局出现 形成现今的电子邮件系统框架</li>
<li>SMTP完成发送 POP&#x2F;IMAP完成电子邮局登陆 读取和管理邮件</li>
</ol>
<h2 id="MIME协议和实现"><a href="#MIME协议和实现" class="headerlink" title="MIME协议和实现"></a>MIME协议和实现</h2><p>现在使用的 是多用途Internet邮件扩充MIME协议</p>
<h3 id="MIME完成的是传输-ASCII码之外的-二进制信息-声音-图像-影视信号也可以发送了"><a href="#MIME完成的是传输-ASCII码之外的-二进制信息-声音-图像-影视信号也可以发送了" class="headerlink" title="MIME完成的是传输 ASCII码之外的 二进制信息(声音 图像 影视信号也可以发送了)"></a>MIME完成的是传输 ASCII码之外的 二进制信息(声音 图像 影视信号也可以发送了)</h3><p>MIME的设计思路是不推翻SMTP架构而对其微调</p>
<p>做法是：</p>
<blockquote>
<p>将所有不同类型的二进制数据<strong>分段编码</strong>为7位ASCII码 然后用SMTP作为一般的文本来发送 然后在接收端转换回去</p>
</blockquote>
<p>在使用MIME时发送方会在邮件头部增加附加行 这一行将会指明这个报文遵循的MIME格式 数据类型和编码算法</p>
<p>比如 MIME-Version:1.0 </p>
<p>MIME还允许发送方将报文分成多个部分(它们可以使用不一样的编码方法) 实际上就是 粘贴多个附件</p>
<h3 id="MIME具有-兼容性「SMTP不需要解析MIME的编码-所以和早期的SMTP兼容」-和-灵活性「不规定编码方法和名称-」"><a href="#MIME具有-兼容性「SMTP不需要解析MIME的编码-所以和早期的SMTP兼容」-和-灵活性「不规定编码方法和名称-」" class="headerlink" title="MIME具有 兼容性「SMTP不需要解析MIME的编码 所以和早期的SMTP兼容」 和 灵活性「不规定编码方法和名称 」"></a>MIME具有 兼容性「SMTP不需要解析MIME的编码 所以和早期的SMTP兼容」 和 灵活性「不规定编码方法和名称 」</h3><hr>
<blockquote>
<p><strong>1、为什么说电子邮件的使用超过了因特网的范围</strong></p>
<p>电子邮件用户计算机完全可以不是Internet用户(没有因特网域名或IP地址) 而可以是在某个Internet计算机上注册了邮箱的普通计算机。 甚至还可以只和本地的传输邮件。</p>
</blockquote>
<blockquote>
<p><strong>2、当你发送电子邮件给不同电子邮局用户时，需要经过哪些必要的环节?请画图 示意。</strong></p>
</blockquote>
<blockquote>
<p><strong>3、早期电子邮件直接在收发计算机之间传输完成，试说明这种模式的优缺点。</strong></p>
<p>优点：效率高 是即时的传输 实现简单</p>
<p>缺点：</p>
<ol>
<li><p>接收的计算机需要开着(并且要么连接互联网，要么和发送计算机直接相连)， 这意味着接收方需要事先知道要接收邮件，也就丧失了邮件系统的非实时性。</p>
</li>
<li><p>常用的个人计算机无法配置邮件服务器，这使得利用邮件服务器完成的功能(如 分发 转发 列表) 收发计算机都无法完成，使得邮件系统可用性大幅下降</p>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong>4、通过目前电子邮件系统发往某邮件，常常发现传输时间是不确定的，有时快而 有时慢，为什么?</strong></p>
<p>因为用户邮件在发端是定时扫描、建立连接和批处理传输的；且发送到目的邮局服务器的邮箱后，需要用户登陆后取回；即E-mail系统工作过程不是一个实际收发的端到端连接通信，而是中间邮局的非实时处理，所以邮件传递快慢取决于个环节等待时间。</p>
</blockquote>
<blockquote>
<p> <strong>5、一个组织的电子邮件系统网关，通常具有什么功能</strong></p>
<ol>
<li>分发和管理组织内的电子邮件地址和电子邮箱</li>
<li>实现组织内部和组织内外之间进行大批量邮件分发或转发功能</li>
<li>对邮件进行一定的过滤和筛选(去除垃圾和病毒邮件)</li>
</ol>
</blockquote>
<blockquote>
<p><strong>6、SMTP的主要作用</strong></p>
<p>电子邮件客户软件定时扫描邮件暂存队列，有待发邮件时，SMTP客户和目的地计算机SMTP服务器建立TCP连接。然后SMTP协议进行通过ASCII码命令和应答逐步协商，最后客户发出邮件副本，服务器接收副本。</p>
</blockquote>
<blockquote>
<p><strong>7、POP的主要作用</strong> 见POP介绍</p>
</blockquote>
<blockquote>
<p><strong>8、SMTP可以传递非ASCII码信息吗</strong> 当然可以了。。MIME</p>
</blockquote>
<hr>
<h1 id="WWW-概述"><a href="#WWW-概述" class="headerlink" title="WWW 概述"></a>WWW 概述</h1><h2 id="World-Wide-Web-是Internet上最受欢迎-应用-其思路来自CERN-欧洲粒子物理研究中心"><a href="#World-Wide-Web-是Internet上最受欢迎-应用-其思路来自CERN-欧洲粒子物理研究中心" class="headerlink" title="World Wide Web 是Internet上最受欢迎 应用  其思路来自CERN(欧洲粒子物理研究中心)"></a>World Wide Web 是Internet上最受欢迎 应用  其思路来自CERN(欧洲粒子物理研究中心)</h2><p>Tim Berners-Lee 在1990年开发了第一个基于超文本的分布式信息系统  1991年Gopher在Internet上运行</p>
<p>第一个图形界面的浏览器产生于1993年「Mosaic」</p>
<p><strong>www的设计基于超文本 HTML HTTP和浏览器</strong></p>
<h2 id="超文本-一般文本-到其他文档的链接-「其数据结构是指针链接的-网状结构-⚠️和树状区分-」"><a href="#超文本-一般文本-到其他文档的链接-「其数据结构是指针链接的-网状结构-⚠️和树状区分-」" class="headerlink" title="超文本 &#x3D;  一般文本 + 到其他文档的链接 「其数据结构是指针链接的 网状结构(⚠️和树状区分)」"></a>超文本 &#x3D;  一般文本 + 到其他文档的链接 「其数据结构是指针链接的 网状结构(⚠️和树状区分)」</h2><ul>
<li><p>超媒体 $\Rightarrow$ 超文本 + 图像、声音、视频的链接 (即把超文本扩展为更多的媒体) 「它们被总称为 Web文档」</p>
<ul>
<li><em>所谓的 Web文档IE(也被称为HTML文档) $\Rightarrow$ 网页</em></li>
</ul>
</li>
<li><p><em><strong>超文本和超媒体 决定了WWW是 非线性、联想式的文档集合 和一个布满链接的信息网</strong></em></p>
</li>
<li><h3 id="所谓的-Web-指的是由超文本-连接而成的信息集合-而WWW则是指-在世界范围内分布的Web服务器的集合"><a href="#所谓的-Web-指的是由超文本-连接而成的信息集合-而WWW则是指-在世界范围内分布的Web服务器的集合" class="headerlink" title="所谓的 Web 指的是由超文本 连接而成的信息集合  而WWW则是指 在世界范围内分布的Web服务器的集合"></a>所谓的 Web 指的是由超文本 连接而成的信息集合  而WWW则是指 在世界范围内分布的Web服务器的集合</h3><ul>
<li>WWW &#x3D;&gt; 建立在超文本和超媒体基础上的 全球分布的 <strong>在线式</strong>的信息网 (这一概念有时会和Web混用)</li>
<li>Web服务器同时也集成了E-Mail FTP TELNET等服务</li>
</ul>
</li>
</ul>
<h2 id="HTML-Hypertext-MakeUp-Language-超文本标记语言-用来创建和识别标准的-Web文档"><a href="#HTML-Hypertext-MakeUp-Language-超文本标记语言-用来创建和识别标准的-Web文档" class="headerlink" title="HTML Hypertext MakeUp Language 超文本标记语言      用来创建和识别标准的 Web文档"></a>HTML Hypertext MakeUp Language 超文本标记语言      用来创建和识别标准的 Web文档</h2><ul>
<li><h3 id="标记语言-Rightarrow-在文本中嵌入一系列-控制符号-使得文件按照作者的想法-显示或者打印"><a href="#标记语言-Rightarrow-在文本中嵌入一系列-控制符号-使得文件按照作者的想法-显示或者打印" class="headerlink" title="标记语言 $\Rightarrow$ 在文本中嵌入一系列 控制符号 使得文件按照作者的想法 显示或者打印"></a>标记语言 $\Rightarrow$ 在文本中嵌入一系列 控制符号 使得文件按照作者的想法 显示或者打印</h3></li>
<li><h3 id="HTML和普通的标记语言区别-Rightarrow-在它们的基础上-扩展了-超文本引用-通过点击实现自动跳转"><a href="#HTML和普通的标记语言区别-Rightarrow-在它们的基础上-扩展了-超文本引用-通过点击实现自动跳转" class="headerlink" title="HTML和普通的标记语言区别$\Rightarrow$在它们的基础上 扩展了 超文本引用(通过点击实现自动跳转)"></a>HTML和普通的标记语言区别$\Rightarrow$在它们的基础上 扩展了 <strong><u><em>超文本引用</em></u></strong>(通过点击实现自动跳转)</h3></li>
<li><p>「Web文档的格式 一般情况下 就是 HTML格式  当然也支持HTML以外的格式」</p>
<ul>
<li>超文本引用的原理：文本中被预先设置指向另一个文档的被动指针(被动是指 需要用户主动选择)</li>
<li><strong><em>任何内容</em>都可以作为超文本引用可选项</strong>(声音 图像也是可以的) 而这种机制 被称为 anchor <em><strong>锚</strong></em></li>
</ul>
</li>
<li><p>当然 除了利用<strong>超文本引用</strong>来实现定位之外  URL的应用也十分广泛</p>
</li>
</ul>
<h2 id="通过-URL-Uniform-精确-Resource-Locater-实现网页的定位-「见sp-edition-互联网传奇」"><a href="#通过-URL-Uniform-精确-Resource-Locater-实现网页的定位-「见sp-edition-互联网传奇」" class="headerlink" title="通过 URL Uniform(精确) Resource Locater 实现网页的定位 「见sp edition 互联网传奇」"></a>通过 URL Uniform(精确) Resource Locater 实现网页的定位 「见sp edition 互联网传奇」</h2><p>找到存放Web的计算机 $\Rightarrow$ 找到是这个计算机中存放的哪个网页 $\Rightarrow$ 确认访问此网页需要的协议 $\Rightarrow$ 对接网页显示的格式</p>
<p>URL的一般格式：</p>
<p>$$<br>协议:&#x2F;&#x2F;计算机域名:端口号(optional)&#x2F;路径&#x2F;Web文档名称<br>$$<br>「端口号 http&#x2F;Web &#x3D;&gt; 80 ； FTP &#x3D;&gt; 21 在采用默认端口号时 可以省略」</p>
<p><em><strong>值得注意的是 虽然URL输入时 可以大小写， 但实际上URL不区分大小写</strong></em></p>
<p><strong>使用URL定位时 因为必须指明特定的主机 如果访问量太大 会炸。 这时只能 就近访问和负载均衡。 而正在发展的URI(Universal Resource Indentifier) 尝试将资源名称和主机位置分离开</strong></p>
<h2 id="网页传输-和-HTTP-协议"><a href="#网页传输-和-HTTP-协议" class="headerlink" title="网页传输 和 HTTP 协议"></a>网页传输 和 HTTP 协议</h2><h3 id="我们先把浏览器和客户等同起来，-这时浏览器和Web服务器的交流就属于典型的C-S模式-但连接时间短-不记忆状态"><a href="#我们先把浏览器和客户等同起来，-这时浏览器和Web服务器的交流就属于典型的C-S模式-但连接时间短-不记忆状态" class="headerlink" title="我们先把浏览器和客户等同起来， 这时浏览器和Web服务器的交流就属于典型的C&#x2F;S模式(但连接时间短 不记忆状态)"></a>我们先把浏览器和客户等同起来， 这时浏览器和Web服务器的交流就属于典型的C&#x2F;S模式(但连接时间短 不记忆状态)</h3><blockquote>
<ul>
<li>浏览器作为客户 根据URL指定的域名 向DNS服务器请求解析 $\Rightarrow$ 得到目的IP地址</li>
<li>浏览器作为客户 和目的IP对应的计算机(和这个计算机上的 Web服务器) 建立TCP连接</li>
<li>浏览器作为客户 向Web服务器发送请求获取Web文档命令 (GET)</li>
<li>Web服务器响应请求 然后返回网页(Web文档)</li>
<li>浏览器接收完成并释放TCP连接， 在这之后显示网页</li>
</ul>
<p>我们也把HTTP的这种连接方式称为 「无状态连接」它可以实现快速的传输和调用 缺点在于如果访问同一个计算机上的多个网页，需要多次连接 产生额外的开销</p>
</blockquote>
<h3 id="HTTP的请求和响应格式"><a href="#HTTP的请求和响应格式" class="headerlink" title="HTTP的请求和响应格式"></a>HTTP的请求和响应格式</h3><p>这是一条HTTP请求命令</p>
<p>以下是HTTP的某些响应命令</p>
<h3 id="HTTP具有以下的特点"><a href="#HTTP具有以下的特点" class="headerlink" title="HTTP具有以下的特点"></a>HTTP具有以下的特点</h3><blockquote>
<ol>
<li><h4 id="可以-高速处理-大量请求。-「包含6种请求方式-URL格式化信息-服务器简单应答」-从开销上看HTTP优于FTP"><a href="#可以-高速处理-大量请求。-「包含6种请求方式-URL格式化信息-服务器简单应答」-从开销上看HTTP优于FTP" class="headerlink" title="可以 高速处理 大量请求。 「包含6种请求方式(URL格式化信息) 服务器简单应答」  (从开销上看HTTP优于FTP)"></a>可以 高速处理 大量请求。 「包含6种请求方式(URL格式化信息) 服务器简单应答」  (<strong>从开销上看HTTP优于FTP</strong>)</h4></li>
<li><h4 id="可以传输任意类型的数据-并且-采用-C-S模式-支持全球访问-支持所有的超文本和超媒体"><a href="#可以传输任意类型的数据-并且-采用-C-S模式-支持全球访问-支持所有的超文本和超媒体" class="headerlink" title="可以传输任意类型的数据 并且 采用 C&#x2F;S模式 支持全球访问    支持所有的超文本和超媒体"></a>可以传输任意类型的数据 并且 采用 C&#x2F;S模式 支持全球访问    支持所有的超文本和超媒体</h4></li>
<li><h4 id="短连接-无状态-「一次请求-一次应答-并不记忆任何状态」"><a href="#短连接-无状态-「一次请求-一次应答-并不记忆任何状态」" class="headerlink" title="短连接 + 无状态 「一次请求 一次应答 并不记忆任何状态」"></a>短连接 + 无状态 「一次请求 一次应答 并不记忆任何状态」</h4></li>
<li><h4 id="可协商。-客户请求可以指明可接受的响应类型。"><a href="#可协商。-客户请求可以指明可接受的响应类型。" class="headerlink" title="可协商。 客户请求可以指明可接受的响应类型。"></a>可协商。 客户请求可以指明可接受的响应类型。</h4></li>
</ol>
</blockquote>
<h2 id="分布式Web-普通-与非分布式Web-公司内-｜-Web代理服务"><a href="#分布式Web-普通-与非分布式Web-公司内-｜-Web代理服务" class="headerlink" title="分布式Web(普通)与非分布式Web(公司内) ｜  Web代理服务"></a>分布式Web(普通)与非分布式Web(公司内) ｜  Web代理服务</h2><p>普通的Web文档被存放在不同的计算机上 由不同人员独立管理 由于管理人员之间信息不一定互通 所以可能会出现无效网页 错误定位等意外情况。</p>
<p><strong>而非分布式的 Web系统会将每个Web文档集中存放在某个计算机上，其Web文档的超链接也是本地的 并且由专门的人员统一管理， 相比分布式Web 更能保证链接的有效性和一致性</strong></p>
<h3 id="Web代理服务-「大量的Web访问可能占满Internet的带宽-所以做一个cache」"><a href="#Web代理服务-「大量的Web访问可能占满Internet的带宽-所以做一个cache」" class="headerlink" title="Web代理服务 「大量的Web访问可能占满Internet的带宽 所以做一个cache」"></a>Web代理服务 「大量的Web访问可能占满Internet的带宽 所以做一个cache」</h3><p>Web Proxy&#x2F;Cache Server 会用一个高速缓存存储被大量访问的Web文档</p>
<p>如果你连接了校园网 一般在访问WWW时 先被校园网出口的路由器重定向到Web Cache 如果里面没有再进行访问(同时把结果存在Proxy中)</p>
<h2 id="浏览器-Browser-Web系统最重要部分-是用户进入Internet的主要入口「本质上是Web系统的客户端」"><a href="#浏览器-Browser-Web系统最重要部分-是用户进入Internet的主要入口「本质上是Web系统的客户端」" class="headerlink" title="浏览器 Browser  Web系统最重要部分 是用户进入Internet的主要入口「本质上是Web系统的客户端」"></a>浏览器 Browser  Web系统最重要部分 是用户进入Internet的主要入口「本质上是Web系统的客户端」</h2><h3 id="浏览器实现的功能-「为了满足多功能客户端桌面的需求-」"><a href="#浏览器实现的功能-「为了满足多功能客户端桌面的需求-」" class="headerlink" title="浏览器实现的功能 「为了满足多功能客户端桌面的需求 」"></a>浏览器实现的功能 「为了满足多功能客户端桌面的需求 」</h3><blockquote>
<ol>
<li>网页浏览</li>
<li>作为HTTP客户 通过TCP&#x2F;IP网络 完成用户对选择URL的请求和文档接受</li>
<li>解析Web文档(HTML文档)  这个功能也包括控制外设来显示这个Web文档</li>
<li>提供额外的服务 支持多格式文档(比如flash服务)  从实际设计角度上看 Browser甚至比Web服务器更加的复杂</li>
</ol>
<ul>
<li>这一项同时也意味着 浏览器可以包含支持其他服务的客户端软件(FTP&#x2F;E-Mail等)</li>
<li>所以 Browser&#x2F;Web Server 「B&#x2F;S」已经逐渐发展为互联网应用的统一形式</li>
</ul>
</blockquote>
<h2 id="Web体系结构-｜-Browser-Web-Server模式-B-S模式｜Web技术的发展"><a href="#Web体系结构-｜-Browser-Web-Server模式-B-S模式｜Web技术的发展" class="headerlink" title="Web体系结构 ｜ Browser&#x2F;Web Server模式 B&#x2F;S模式｜Web技术的发展"></a>Web体系结构 ｜ Browser&#x2F;Web Server模式 B&#x2F;S模式｜Web技术的发展</h2><p>浏览器通过URL 在TCP基础上 HTTP协议规定B&#x2F;S之间遵循的规则和需要进行的操作</p>
<p><strong><u>这也体现出WWW的核心： 超文本｜HTML&#x2F;URL结构｜HTTP｜浏览器</u></strong></p>
<h3 id="B-S体系结构-是作为C-S的后继发展类型"><a href="#B-S体系结构-是作为C-S的后继发展类型" class="headerlink" title="B&#x2F;S体系结构    是作为C&#x2F;S的后继发展类型"></a>B&#x2F;S体系结构    是作为C&#x2F;S的后继发展类型</h3><p>Browser在90年代中期开始逐渐成为主流 其客户端采用标准化浏览器(Java虚拟机 多媒体解析显示+简单逻辑操作)</p>
<p>Web服务器要做的事 解决应用开发 逻辑计算 网页封装和管理 使网络应用系统的升级 扩展和维护更加方便</p>
<p>在现在的B&#x2F;S服务器端 Web服务器演变为新的 <strong>MVC</strong>结构「WebSever+应用服务器+数据库服务器」</p>
<p>M $\Rightarrow$ 业务逻辑   V $\Rightarrow$ 展示    C $\Rightarrow$ 控制  这种结构是目前电子商务、政务广泛流行的架构</p>
<h3 id="Web技术的发展"><a href="#Web技术的发展" class="headerlink" title="Web技术的发展"></a>Web技术的发展</h3><h4 id="1-HTML-Rightarrow-XML-表示数据时-HTML的个性化不够-所以需要建立一种具有理解数据格式和结构的规则和方法"><a href="#1-HTML-Rightarrow-XML-表示数据时-HTML的个性化不够-所以需要建立一种具有理解数据格式和结构的规则和方法" class="headerlink" title="1. HTML $\Rightarrow$ XML  表示数据时 HTML的个性化不够 所以需要建立一种具有理解数据格式和结构的规则和方法"></a>1. HTML $\Rightarrow$ XML  表示数据时 HTML的个性化不够 所以需要建立一种具有理解数据格式和结构的规则和方法</h4><h4 id="2-Web2-0和语义Web"><a href="#2-Web2-0和语义Web" class="headerlink" title="2. Web2.0和语义Web"></a>2. Web2.0和语义Web</h4><hr>
<blockquote>
<p><strong>什么是超媒体、HTML 与Web？</strong></p>
<p>超媒体：在超文本中加入了图像、声音和视频的链接。可调出指针指向多媒体的信息</p>
<p>HTML：超文本标记语言，在普通标记语言的基础上扩展了超文本引用</p>
<p>Web：由超文本(超媒体)连接而成的信息集合</p>
</blockquote>
<blockquote>
<p><strong>为什么有时链接打开一个网页会发现无效？</strong></p>
<p>WWW是基于互联网的分布式的超媒体(超文本), 每个Web文档存放在不同的计算机上，并由不同的人员独立管理，其修改、删除、增加或者重命名等不会(实际上是无法) 通知相连的其他节点。因此会出现链接无效 或者链接不一致的情况。</p>
</blockquote>
<blockquote>
<p><strong>如何区分分布式Web和非分布式Web系统，试说明两者的可能的应用场合。</strong></p>
<p>相比分布式Web系统，非分布式Web系统将所有的Web文档集中存放在某一个计算机上，通常通常其Web文档的超链也是本地的，并由专门人员统一管理，能够很好的保持链接的一致性和有效性。</p>
<p>分布式的Web将Web服务器散布在Internet的各处，所有Internet上的Web服务器构成了万维网，是Internet上最受欢迎的应用，</p>
<p>非分布式的Web系统可以应用在公司或组织的内部资料库中，由专门的人员管理，也只有公司本地网段的计算机可以访问。</p>
</blockquote>
<blockquote>
<p><strong>试说明C&#x2F;S结构和B&#x2F;S结构的异同。</strong></p>
<p>B&#x2F;S结构是由C&#x2F;S结构演变而来的，采用了客户层｜中间层｜服务器 的三层结构，是基于WWW产生的。</p>
<p>不同之处：</p>
<p>B&#x2F;S的设计目的是为了满足接入Internet的普通用户需求，而C&#x2F;S则更多的由专业用户使用，同时有一定的门槛</p>
<p>B&#x2F;S建立在WWW(Internet)上，而C&#x2F;S则常常被部署在局域网上</p>
<p>B&#x2F;S的兼容性强 部署容易，而C&#x2F;S的部署比较复杂</p>
<p>B&#x2F;S系统的开发和维护开销都比较小，而C&#x2F;S相对来说更大一些</p>
<p>B&#x2F;S建立在广域网上，相比C&#x2F;S结构对于安全性的要求更低</p>
</blockquote>
<blockquote>
<p><strong>B&#x2F;S架构是互联网应用基本形式，什么类应用不适合B&#x2F;S架构？</strong></p>
<p>B&#x2F;S的架构开发和维护都相对简单 但由于是基于WWW而设计，只需要和本地服务器交互，不需要连接互联网的应用，不适合用B&#x2F;S架构。</p>
<p>另外，由于其无状态连接的特点，需要点对点高强度交互的应用，不适合使用B&#x2F;S架构。</p>
<p>虽然浏览器的功能非常强大，但如果用户需要某些特定的功能(比如游玩大型的网络游戏)，就需要专门的客户端软件，而不适合B&#x2F;S架构。</p>
</blockquote>
<hr>
<h2 id="Chapter2-DNS"><a href="#Chapter2-DNS" class="headerlink" title="Chapter2 DNS"></a>Chapter2 DNS</h2><h2 id="域名服务系统-DNS-Domain-Name-System"><a href="#域名服务系统-DNS-Domain-Name-System" class="headerlink" title="域名服务系统 DNS[Domain Name System]"></a>域名服务系统 DNS[Domain Name System]</h2><h3 id="DNS系统概述"><a href="#DNS系统概述" class="headerlink" title="DNS系统概述"></a>DNS系统概述</h3><p>我们显然可以通过输入 IP地址来访问网站。 使用DNS只是为了 让字符化的计算机域名 能够起到 特征标示的作用。</p>
<p><em><strong>DNS 的作用是 将 用户使用的域名 和 计算机使用的IP地址 互相转换(translation)</strong></em></p>
<p><strong>备注：</strong></p>
<p><strong>1. DNS 同时也表示 Domain Name Server</strong></p>
<p><strong>2. DNS所实现的转换是 双向的</strong></p>
<p><strong>3. 域名的翻译是自动完成的 依赖分布在全球的一系列服务器完成， DNS实现的翻译 属于C&#x2F;S交互</strong></p>
<h3 id="Internet-域名构造"><a href="#Internet-域名构造" class="headerlink" title="Internet 域名构造"></a>Internet 域名构造</h3><p><strong>因特网将这些域名划分成 树状体系 最高级的域名一般是通用域名&#x2F;国家&#x2F;基础结构域类。 在这些最高级域名下划分子类 逐渐延伸</strong></p>
<p>我们的高级域名<code>.cn</code> 之下 定义了7个2级域名 ac(研究机构)  com	edu	gov	mil	net	org	以及34个行政区域名</p>
<p><strong>如果你想要使用最高级域名， 必须向Internet管理机构ICANN(或其授权管理机构 比如中国的CCNIC)登记，层层递进</strong></p>
<h3 id="DNS层次结构和服务器分布模型"><a href="#DNS层次结构和服务器分布模型" class="headerlink" title="DNS层次结构和服务器分布模型"></a>DNS层次结构和服务器分布模型</h3><ul>
<li>每个DNS服务器 都是域名体系中部分域名的实际管理者，要负责具有某后缀的所有计算机权威管理</li>
<li>每个计算机域名也必须在对应的DNS组织(服务器)登记</li>
<li>DNS具有命名 和 服务器设置的 自治性</li>
<li>每个DNS服务器 只能完成部分计算机域名的处理，因此因特网所有的DNS服务器宏观上被连接成了一个系统。<ul>
<li>这意味着：<strong>每个DNS服务器都知道如何找到根DNS服务器，以及如何找到下级的DNS服务器</strong></li>
</ul>
</li>
<li>对大型组织集中单一DNS服务很困难。但由于DNS服务具有 <strong>局部访问性原理</strong> 我们可以按照层次制定分布DNS服务策略</li>
</ul>
<h3 id="DNS记录和协议报文格式"><a href="#DNS记录和协议报文格式" class="headerlink" title="DNS记录和协议报文格式"></a>DNS记录和协议报文格式</h3><h5 id="DNS的拓扑"><a href="#DNS的拓扑" class="headerlink" title="DNS的拓扑"></a>DNS的拓扑</h5><p>一般组织使用单一DNS服务器，小型公司作为用户，和提供DNS的ISP连接，DNS服务也由和其连接的ISP完成</p>
<hr>
<blockquote>
<p><strong>试解释中文域名可能的工作原理</strong></p>
<p>我认为现在的DNS系统已经比较成熟，所以中文域名的工作可以从从用户角度入手，即将用户输入的中文域名，翻译成英文域名，然后接入现有的DNS体系框架内。</p>
<p>在用户使用的浏览器中添加扩展，使得浏览器能够实现汉字输入转换，并考虑使用缺省和机器学习来优化</p>
<p>如输入 百度 则浏览器转化为 <a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a> 实际上仍然使用现有的DNS服务</p>
</blockquote>
<blockquote>
<p><strong>试说明DNS服务器怎样获取请求客户主机域名的？</strong></p>
<ol>
<li>客户机想要查询时首先在本地计算机缓存中查找，如果无法获得查询信息，则向本地DNS服务器发送查询请求</li>
<li>本地DNS服务器收到请求，首先在其管理区域记录里查询，如果找到了，则直接解析并返回，没找到则执行3</li>
<li>本地DNS服务器将客户的请求发送到根域名DNS服务器。根域名服务器解析请求的根域部分，并以此获知管理下一级域名的DNS服务器地址，并将这个地址返回给本地DNS服务器。</li>
<li>本地DNS服务器利用上一级域名服务器给出的地址访问下一级DNS服务器，得到更下一级的DNS服务器地址，同样，这个地址被返回给本地DNS服务器。</li>
<li>返回递归执行步骤4 直到本地DNS服务器获取到知道域名对应IP的DNS服务器传回的IP地址</li>
<li>本地DNS服务器将查询结果返回客户 完成解析过程</li>
</ol>
<p><strong>两个DNS服务器包含完全相同的域名有意义吗？为什么？</strong></p>
<p>是有意义的。因为DNS的解析是递归的过程，如果有两个不同的DNS服务器都包含这个域名，说不定可以减少递归的次数，提高DNS服务的效率。</p>
<p><strong>试分析DNS体系的层次数对域名解析速度是否有影响？</strong></p>
<p><strong>有影响</strong>。如果你要访问的域名离自己的本地DNS服务器太远，你的访问请求将被迫一级一级的不断上传，同时一级一级的向下返回，虽然传输的时延不长，但处理和排队的时延累加起来就很长了。比如我们访问国外的网站，即使没有被屏蔽也会很慢。</p>
<p><strong>DNS系统为什么要优化，优化措施主要有哪些？</strong></p>
<p><strong>无论是递归还是迭代</strong>的请求方式，本质上其实<strong>效率都很糟糕</strong>，特别是根服务器的负载非常大，并且根服务器作为枢纽一旦下线，非本地访问的DNS服务几乎就中断了。</p>
<h5 id="但由于一台计算机经常访问本地域名或重复访问同样的域名，所以可以进行以下的优化处理："><a href="#但由于一台计算机经常访问本地域名或重复访问同样的域名，所以可以进行以下的优化处理：" class="headerlink" title="但由于一台计算机经常访问本地域名或重复访问同样的域名，所以可以进行以下的优化处理："></a>但由于一台计算机经常访问本地域名或重复访问同样的域名，所以可以进行以下的优化处理：</h5><ol>
<li>复制。复制多个根服务器副本，按照地域分布，实现就地DNS域名服务</li>
<li>缓存。每次查找新域名 本地DNS服务器将地址联编副本进行缓存 实际上客户的浏览器也有类似的 域名缓存措施</li>
</ol>
</blockquote>
<hr>
<h1 id="Chapter3-FTP-File-Transfer-Protocol"><a href="#Chapter3-FTP-File-Transfer-Protocol" class="headerlink" title="Chapter3 FTP [File Transfer Protocol]"></a>Chapter3 FTP [File Transfer Protocol]</h1><h3 id="FTP-概述"><a href="#FTP-概述" class="headerlink" title="FTP 概述"></a>FTP 概述</h3><p>FTP的产生 $\rightarrow$ 早期Internet(ARPANET) 的工作主要是 信息交互 (特别是文件交互共享)</p>
<p><strong>从历史上讲 FTP的产生要早于TCP (现在则是使用新的FTP协议 ) 在95年之前 FTP占据因特网通信量的 1&#x2F;3</strong></p>
<h2 id="FTP需要解决-在异构计算机之间的-通用文件传递-这需要克服不同文件系统的差异："><a href="#FTP需要解决-在异构计算机之间的-通用文件传递-这需要克服不同文件系统的差异：" class="headerlink" title="FTP需要解决 在异构计算机之间的 通用文件传递 这需要克服不同文件系统的差异："></a>FTP需要解决 在<em><strong>异构计算机之间的 通用文件传递</strong></em> 这需要克服不同文件系统的差异：</h2><ol>
<li>通用性 </li>
<li>跨平台特性</li>
<li>传输和控制 $\rightarrow$ 控制 上传 下载</li>
<li><strong>FTP可以支持 任意类型的数据文件</strong></li>
<li>FTP可以加密 可以控制访问</li>
</ol>
<h5 id="FTP主要提供2种交互方式-即-实时交互-和-批处理"><a href="#FTP主要提供2种交互方式-即-实时交互-和-批处理" class="headerlink" title="FTP主要提供2种交互方式 即  实时交互 和 批处理"></a>FTP主要提供2种交互方式 即  实时交互 和 批处理</h5><p>值得注意的是 可以建立一种 同时实现两种方式的 服务</p>
<h2 id="FTP只有-文本-和-binary-两种格式「FTP传输的是-文件的副本-而不是文件本身」"><a href="#FTP只有-文本-和-binary-两种格式「FTP传输的是-文件的副本-而不是文件本身」" class="headerlink" title="FTP只有 文本 和 binary 两种格式「FTP传输的是 文件的副本 而不是文件本身」"></a>FTP只有 文本 和 binary 两种格式「<em><strong>FTP传输的是 文件的副本 而不是文件本身</strong></em>」</h2><p>视频 浮点数 图形… 只要不是文本 全部都使用binary 传输</p>
<p>当然 二进制会出现在FTP两边格式不一样的情况 这FTP不管</p>
<h3 id="FTP工作原理-「两条连接-控制和数据传输分离」"><a href="#FTP工作原理-「两条连接-控制和数据传输分离」" class="headerlink" title="FTP工作原理 「两条连接 控制和数据传输分离」"></a>FTP工作原理 「两条连接 控制和数据传输分离」</h3><p><strong>两端的进程会分别启动 控制和数据传送进程(它们是主进程的从属进程 并且相互独立)</strong></p>
<ol>
<li><strong>客户通过临时端口号N 和 FTP服务器(端口号 21 这是个熟知端口)  建立TCP链接</strong><ul>
<li><strong>这条连接 只是用来控制 由客户发起 服务器接受。 客户端输入的命令从这里发到服务器中</strong></li>
</ul>
</li>
<li><strong>服务器并不会马上 建立传输连接，而是在客户发起命令 确认一个文件之后</strong> </li>
<li><strong>服务器通过 <em>端口号20</em> 与<em>客户端口号N+1</em> 建立TCP连接</strong><ul>
<li>*<em>这条连接 只是用来传输 <em>由服务器发起 也会由服务器结束</em>。</em>*</li>
</ul>
</li>
</ol>
<h3 id="FTP交互方式的特点"><a href="#FTP交互方式的特点" class="headerlink" title="FTP交互方式的特点"></a>FTP交互方式的特点</h3><ol>
<li>两个不同的端口号分别建立控制连接和数据连接 目的是让命令交互 和 文件数据交互 之间不互相干扰</li>
<li>服务器在完成文件传递后 关闭数据连接 给客户端一个 文件结束条件</li>
<li>FTP命令可以控制远程计算机上的文件操作 就好像在操作本地文件一样</li>
</ol>
<h3 id="FTP登陆-和-常用命令"><a href="#FTP登陆-和-常用命令" class="headerlink" title="FTP登陆 和 常用命令"></a>FTP登陆 和 常用命令</h3><ol>
<li>输入 Open计算机域名 和这个计算机建立TCP连接。 使用Close 来关闭连接(并不是关闭FTP程序！)</li>
<li>对于私有的FTP服务 需要输入用户名+口令； 而有些开放的FTP服务 使用anonymous(guest) &#x2F; 电邮账户 即可实现访问了</li>
</ol>
<p><strong>FTP 一般使用命令行进行交互 客户端有约50条命令</strong></p>
<p>通用标准化处理(解决跨平台(OS)传输)</p>
<p>我们想要做到OS对FTP的C&#x2F;S透明。因此定义了 <strong>Telnet NVT(Network Vietual Terminal)网络虚拟终端</strong></p>
<p>这样 FTP和OS就不进行直接的交互了 而是通过NVT标准格式接口 在传输过程中 实际上就是</p>
<p>本地终端格式 $\rightarrow$转换为 NVT格式 $\rightarrow$ 传输 $\rightarrow$ NVT转换为本地主机格式 $\rightarrow$ 本地主机格式</p>
<p>NVT格式 统一使用8bit通信 7位ASCII码 最高位 为1 $\rightarrow$ 控制命令</p>
<h3 id="NFS-Network-File-System"><a href="#NFS-Network-File-System" class="headerlink" title="NFS(Network File System)"></a>NFS(Network File System)</h3><p>一般被集成在一个大的文件系统里</p>
<p>和FTP类似 但不传输文件副本 一般只传递 复制&#x2F;改变 文件的小片段</p>
<p>使用TCP和UDP 实现不同操作系统的各种终端和主机间远程登录和文件命令操作</p>
<blockquote>
<p><strong>1、怎样理解NVT？</strong></p>
</blockquote>
<blockquote>
<p><strong>2、FTP目前主要使用在什么场合，为什么不十分流行？</strong></p>
<p>FTP目前一般在公司或单位的内部进行公开的文件传输时使用。</p>
<p>不流行的原因：<br>\1. 使用命令行进行交互 没有图形界面 这意味着使用FTP的门槛要更高。</p>
<p>\2. 安全性不够高，FTP的信息在信道上可能被劫持 这样信息就全部泄漏了。</p>
<p>\3. FTP诞生时间太早，不适合现在的网络架构。使用两条TCP连接比较浪费，虽然是稳定的传输，但效率不够高，会浪费一些网络资源。</p>
</blockquote>
<blockquote>
<p><strong>3、在一条传输链路连接的网络两端，用FTP传输一个大文件，然后根据文件字节数和传输的时间测量链路的数据传输容量，是否准确？试说明理由。</strong></p>
<p>不准确。因为FTP的底层是TCP传输(TCP传输又需要进行IP层的封装)，这意味着大文件 会被封装成TCP报文段。大文件长度很可能大大超过了MTU，这意味着需要很多个TCP报文段来传输这个文件。如果只算文件字节数而忽略TCP报文头和IP报文头，算出的数据传输容量会有较大的偏差(会偏小)。</p>
</blockquote>
<blockquote>
<p><strong>4、二进制模式和文本模式下传输同一个文本文件，试说明两种模式传输时间哪个大？为什么？</strong></p>
<p>文本模式下 会花费更长时间。 FTP的文本使用ASCII&#x2F;EBCDIC 字符集，在FTP发送和接收前需要经过转换(本地文本文件$\rightarrow$ ASCII&#x2F;EBCDIC $\rightarrow$ 本地文本文件)，并且还需要加入控制字符。而二进制是不进行任何表达转换处理，直接传输文件副本。</p>
</blockquote>
<hr>
<h1 id="Chapter4-NAT-DHCP"><a href="#Chapter4-NAT-DHCP" class="headerlink" title="Chapter4 NAT&amp;DHCP"></a>Chapter4 NAT&amp;DHCP</h1><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>对于TCP&#x2F;IP的每一层， 有些是协议 有些是技术。</p>
<p>宏观来看，IPv4的地址空间不够用，导致了大量的问题</p>
<blockquote>
<p>IPv6 (128bits)</p>
<p>NAT &#x2F; Network Address Translation</p>
<p>VLSM 可变长 subnet mask</p>
<p>CIDR 无类域间路由</p>
</blockquote>
<h3 id="NAT-简介"><a href="#NAT-简介" class="headerlink" title="NAT 简介"></a>NAT 简介</h3><p>Network Address Translation 发明于1994年</p>
<p>其思路是 <strong>内网域内使用私有的IP地址空间</strong> 10网段 172.16网段 192.168网段</p>
<blockquote>
<p>10.0.0.0—10.255.255.255 A<br>172.16.0.0—172.31.255.255 B<br>192.168.0.0—192.168.255.255 C</p>
</blockquote>
<p>私有IP只在局域网里使用 互联网上不会出现这些ip</p>
<p>NAT的普及程度 $\rightarrow$ 70%的P2P用户位于NAT网关以内 由于P2P主要运行在PC上，这意味着大部分的PC都是通过NAT网关连接到Internet</p>
<ul>
<li>NAT技术没有公认的发明者</li>
</ul>
<h3 id="NAT工作模型"><a href="#NAT工作模型" class="headerlink" title="NAT工作模型"></a>NAT工作模型</h3><p>NAT 通常被部署在一个局域网的网络出口位置 通过**<u><em>将内部网络IP地址 替换成出口的IP地址</em></u><strong>提供</strong>公网可达性<strong>和</strong>上层协议连接能力**</p>
<p>目的$\rightarrow$提供一种虚拟的寻址机制</p>
<p>正常情况下 使用私有IP地址不需要向IANA提出申请 但是这些地址 不能作为源地址和目的地址</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul>
<li>在组织的出口部署 NAT gateway  其功能是：<ul>
<li>报文离开局域网进入Internet时 将源地址替换成公网地址(一般是出口设备的interface地址)</li>
<li>对访问目标来说，访问源地址自然就是NAT gateway，target会回复给NAT gateway</li>
<li>收到回复后 NAT gateway再把目的地址<strong>替换成私有IP地址</strong></li>
</ul>
</li>
<li>显然 对通信的双方来说 NAT gateway是<strong>透明</strong>的 数量庞大的内网主机 也不需要公有的IP地址了</li>
</ul>
<h4 id="注意⚠️"><a href="#注意⚠️" class="headerlink" title="注意⚠️"></a>注意⚠️</h4><ol>
<li><p>外网 一般无法通过IP地址访问内网主机 想要访问有两种方法</p>
</li>
<li><blockquote>
<p>一个全局地址 可以让不同PC同时访问<em><strong>不同</strong></em>服务器吗？$\rightarrow$ 可以 离开站点前的私有IP地址映射不一样</p>
<p><strong>一个全局地址 可以让不同PC同时访问<em>相同</em>服务器吗？$\rightarrow$ 不可以 因为在NAT Gateway收到服务器传回的报文时 不知道是哪个PC发送的(这个报文的源地址是服务器 目的地址是NAT Gateway的IP地址)</strong></p>
</blockquote>
</li>
<li><p>为实现双方的持续交流，NAT gateway需要维护一张关联表 $\rightarrow$ 地址转换表(translation table) 存储重写地址时所需的信息来实现地址转换 具体实现方法：</p>
<ul>
<li>当数据报离开站点 NAT将目的地址和发送方的私有地址记录在一起。</li>
<li>当数据报到达站点 NAT查询translation table 来确认哪台站内计算机接收这个相应。</li>
</ul>
</li>
<li><p>全局地址数量M一般远小于主机数 一个一般对应4000个内部地址</p>
<ul>
<li>内网轮流使用NAT地址池里的全局地址 当NAT地址池的全局地址被用完时 主机对外部的因特网访问将必须等待</li>
</ul>
</li>
<li><p>NAT gateway对交流双方是透明的</p>
</li>
</ol>
<h3 id="NAPT-网络地址与端口转换"><a href="#NAPT-网络地址与端口转换" class="headerlink" title="NAPT 网络地址与端口转换"></a>NAPT 网络地址与端口转换</h3><p>与NAT的区别在于 NAT是一对一转换 而NAPT则在转换时把端口号也作为参数 实现多对一转换</p>
<p>用于以下的两种情况 解决了 收到应答不知道给谁的问题。</p>
<blockquote>
<p>内网里两台不同主机 要同一时间 访问同一个服务器 </p>
<p>内网里 一台主机的 多个不同进程 要同时访问同一个服务器</p>
</blockquote>
<p>生成一个本地的端口号(临时生成 只用来区分不同主机或进程)</p>
<h5 id="NAPT的负载均衡器功能"><a href="#NAPT的负载均衡器功能" class="headerlink" title="NAPT的负载均衡器功能"></a>NAPT的负载均衡器功能</h5><p>外到内网服务器的访问 表的静态记录项 通过服务端口区分不同服务器的访问</p>
<p>接受外部主机的请求时 NAT根据已有的NAPT表 把全局地址翻译成不同内部地址 建立与多部主机的连接。根据NAPT表 转发数据包到多个内部服务器 实现服务器负载均衡(访问的是单个服务器 多个一起处理) 或不同服务器的访问</p>
<h5 id="外部通过NAT的访问内网-NART表项动态建立"><a href="#外部通过NAT的访问内网-NART表项动态建立" class="headerlink" title="外部通过NAT的访问内网 NART表项动态建立"></a>外部通过NAT的访问内网 NART表项动态建立</h5><p>如果是一般主机非固定的服务器，由于NAPT表中一般主机和NAT公有地址只是内到外访问时临时建立的，即NAPT表无法自动构建转换映射表，所以外部访问一般无法根据IP地址访问内网主机。一种方法通过域名访问，即建立内网域名DNS（二级域名）和NAT联用机制，由DNS触发建立NAT表的一个记录项。这时NAPT动态建立对应表项，IP地址利用率更高</p>
<h3 id="NAT的优缺点"><a href="#NAT的优缺点" class="headerlink" title="NAT的优缺点"></a>NAT的优缺点</h3><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><blockquote>
<p>节约Internet地址</p>
<p>解决相同IP地址的负载扩展(均衡)</p>
<p>消除重新编址 (现有方案能继续使用)</p>
</blockquote>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><blockquote>
<p>延迟增加</p>
<p>降低地址的 Traceability</p>
<p>某些应用功能交互更加复杂或失效(FTP TCP要解决NAT穿越问题 而要求特定的源端口和源地址的应用无法工作)</p>
</blockquote>
<hr>
<h2 id="因特网系统初始化设置-BOOTP-DHCP"><a href="#因特网系统初始化设置-BOOTP-DHCP" class="headerlink" title="因特网系统初始化设置 BOOTP &amp; DHCP"></a>因特网系统初始化设置 BOOTP &amp; DHCP</h2><ul>
<li>TCP&#x2F;IP 协议参数和配置 需要参数：<ul>
<li>硬件地址</li>
<li>使用协议类型</li>
<li>IP地址</li>
<li>默认IP路由器地址(下一跳地址)</li>
<li>地址掩码(地址类型)</li>
<li>DNS服务器地址</li>
</ul>
</li>
</ul>
<h5 id="协议配置-：-协议软件被-协议通用性原则-约束。-需要协议软件参数化，所以要在编译之前对参数赋值"><a href="#协议配置-：-协议软件被-协议通用性原则-约束。-需要协议软件参数化，所以要在编译之前对参数赋值" class="headerlink" title="协议配置 ： 协议软件被 协议通用性原则 约束。 需要协议软件参数化，所以要在编译之前对参数赋值"></a>协议配置 ： 协议软件被 协议通用性原则 约束。 需要协议软件参数化，所以要在编译之前对参数赋值</h5><p>如何配置协议？ <em><u><strong>在不知道IP地址情况下交流的核心思路$\rightarrow$使用广播</strong></u></em></p>
<blockquote>
<p>人工配置 手动录入(仍然是常用的方法)</p>
<p>存储文件配置 打开配置文件进行配置(因为系统只在启动时读取配置文件 所以修改参数配置需要重启)</p>
<p>自动协议配置 只要出现大量设备或者频繁修改 前两种几乎都行不通</p>
</blockquote>
<h5 id="自动协议配置方法"><a href="#自动协议配置方法" class="headerlink" title="自动协议配置方法"></a>自动协议配置方法</h5><p>要克服单机分散配置问题 在<strong>服务器端进行集中配置</strong> 然后通过请求&#x2F;应答形式 当计算机启动入网前发出请求 网络服务器返回适当配置响应</p>
<ol>
<li>配置协议前 使用RARP 用MAC多播(主要使用RARP的是无盘工作站 存储不了自己的IP地址 MAC地址在网卡上)</li>
<li>此时不知道默认网关 使用ICMP 掩码请求&#x2F;网关发现 用IP广播方式获取路由器参数(获取地址掩码&#x2F;默认网关地址)<ul>
<li><strong>地址屏蔽码</strong>(掩码)请求&#x2F;应答Address Mask Request&#x2F; Reply:主机启动时，会广播一个地址屏蔽码请求报文。服务器或路由器收到地址屏蔽码请求报文后，回送一个<strong>包含本网使用的32位地址屏蔽码</strong>的应答报文。</li>
</ul>
</li>
</ol>
<p><em>总的来说 协议从底层到高层进行配置 通过底层广播协议&#x2F;单播的方式逐步获得高层参数信息。</em></p>
<h5 id="自举的过程如下"><a href="#自举的过程如下" class="headerlink" title="自举的过程如下"></a>自举的过程如下</h5><blockquote>
<p>MAC 广播RARP request 获取IP地址</p>
<p>等待RARP reply 如果T1时间内无响应 返回1</p>
<p>广播ICMP地址掩码请求 获取IP地址掩码</p>
<p>等待回复 如果T2时间无响应 返回3</p>
<p>利用ICMP网关发现 找到默然路由器的IP地址 并将其加入路由表中</p>
</blockquote>
<p>可以注意到 需要至少3次分散的协议过程 会出现分散 延时 报文不同</p>
<h3 id="自举协议BOOTP-Bootstrap-Protocol"><a href="#自举协议BOOTP-Bootstrap-Protocol" class="headerlink" title="自举协议BOOTP(Bootstrap Protocol)"></a>自举协议BOOTP(Bootstrap Protocol)</h3><p>Bootstrap $\rightarrow$ pull or drag oneself by one’s own </p>
<h5 id="功能：一次广播一个BOOTP协议请求包-BOOTP服务器查找各项信息返回"><a href="#功能：一次广播一个BOOTP协议请求包-BOOTP服务器查找各项信息返回" class="headerlink" title="功能：一次广播一个BOOTP协议请求包 BOOTP服务器查找各项信息返回"></a>功能：一次广播一个BOOTP协议请求包 BOOTP服务器查找各项信息返回</h5><p><strong>注意： BOOTP协议由于尚未配置参数 所以进行了特殊的地址定义 IP广播地址全1 作为目的地址 全0作为源地址</strong></p>
<p><strong>BOOTP服务器可使用MAC地址进行单播(此时工作站还不知道自己的IP地址 所以IP单播无效) 或者全1广播地址回送 自举协议使用UDP发送(68&#x2F;67 端口)</strong></p>
<h5 id="自举协议的报文格式"><a href="#自举协议的报文格式" class="headerlink" title="自举协议的报文格式"></a>自举协议的报文格式</h5><h5 id="BOOTP的局限性"><a href="#BOOTP的局限性" class="headerlink" title="BOOTP的局限性"></a>BOOTP的局限性</h5><blockquote>
<p>在工作前 需要对BOOTP服务器上配置相关主机参数数据库 且是固定设置值。只能满足小区域固定IP配置和PC的静态接入网络需求。在大区域或不固定IP配置的情况下 很难实现。</p>
</blockquote>
<h3 id="DHCP-Dynamic-Host-Configuration-Protocol"><a href="#DHCP-Dynamic-Host-Configuration-Protocol" class="headerlink" title="DHCP&#x2F;Dynamic Host Configuration Protocol"></a>DHCP&#x2F;Dynamic Host Configuration Protocol</h3><p>1997年 IETF设计了动态主机配置协议 这个协议是在BOOTP基础上的扩展改进 </p>
<p><strong>DHCP的最大特点就是 可以自动获取IP地址分配(不固定)机制，也就是即插即用的联网</strong></p>
<blockquote>
<p>仍然使用IP广播地址全1作为目的地址 全0作为源地址 </p>
<p>DHCP服务器也可使用MAC地址进行单播 或者全1广播地址回送 (和BOOTP是一样的端口)</p>
<p>不同的是 如果有数据库中该主机的指定信息(这和BOOTP一致)就取出返回 <strong>如果没有(新增)从IP地址缓冲池动态选择一个IP地址分配给主机</strong></p>
</blockquote>
<h5 id="IP租借：由于DHCP是一个IP地址按需分配的-不固定机制-DHCP需要地址租期的概念。产生的地址在过了有效期-1s-136years-后就会被回收。"><a href="#IP租借：由于DHCP是一个IP地址按需分配的-不固定机制-DHCP需要地址租期的概念。产生的地址在过了有效期-1s-136years-后就会被回收。" class="headerlink" title="IP租借：由于DHCP是一个IP地址按需分配的 不固定机制 DHCP需要地址租期的概念。产生的地址在过了有效期(1s-136years)后就会被回收。"></a>IP租借：由于DHCP是一个IP地址按需分配的 不固定机制 DHCP需要地址租期的概念。产生的地址在过了有效期(1s-136years)后就会被回收。</h5><ul>
<li>DHCP通过IP地址缓冲池和租借IP按需分配的形式 形成对移动计算机入网的动态配置信息，不需要管理员对配置数据库进行任何修改。</li>
</ul>
<h5 id="DHCP优化"><a href="#DHCP优化" class="headerlink" title="DHCP优化"></a>DHCP优化</h5><blockquote>
<p>使用DHCP的主机首先随机广播发送 DHCP发现报文(短报) 减少冲撞的概率，在确认DHCP服务器后再发送请求报文。DHCP服务器地址通常会被永久保存，以后会单播(类似我们的记住已经连接过的WIFI密码)</p>
</blockquote>
<h5 id="DHCP中继"><a href="#DHCP中继" class="headerlink" title="DHCP中继"></a>DHCP中继</h5><blockquote>
<p>不是每个网络都需要DHCP服务器 设置一个DHCP中继 可以代理转发DHCP服务器的请求和响应(一般的路由器都有此功能)</p>
</blockquote>
<h5 id="DHCP使用和DHCP报文"><a href="#DHCP使用和DHCP报文" class="headerlink" title="DHCP使用和DHCP报文"></a>DHCP使用和DHCP报文</h5><blockquote>
<p>属性配置选择 $\rightarrow$ 固定IP地址&#x2F; 自动获取IP地址(选择这个就是使用DHCP)</p>
<p>DHCP报文和BOOTP差不多 添加了一个 FLAGS选项 让用户说明希望服务器使用广播应答还是直接应答</p>
</blockquote>
<p>由于DHCP和DNS系统不关联 对有域名计算机来说 IP地址和DNS域名的映射在从DHCP中自动获取新的IP后，计算机名字将会失效</p>
<hr>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="请简述自举配置协议BOOTP要解决什么问题？"><a href="#请简述自举配置协议BOOTP要解决什么问题？" class="headerlink" title="请简述自举配置协议BOOTP要解决什么问题？"></a><em><strong>请简述自举配置协议BOOTP要解决什么问题？</strong></em></h4><p>​	BOOTP用于解决在自动配置协议时 需要发送多次不同协议报文带来的分散、时延等麻烦。通过广播 一次发送一个BOOTP请求包，由BOOTP服务器查找各项信息返回。</p>
<p><strong>标准答案：</strong></p>
<p><strong>第1发现协议地址，实际上我们还是可以通过RARP形式，在未知环境中获取本机参数；</strong></p>
<p><strong>第2获取配置服务器参数，实际上采用ICMP的掩码请求形式，以IP广播的方法请求获取</strong></p>
<h4 id="请简述DHCP-协议在BOOTP基础上主要改进了什么？。"><a href="#请简述DHCP-协议在BOOTP基础上主要改进了什么？。" class="headerlink" title="请简述DHCP 协议在BOOTP基础上主要改进了什么？。"></a><em><strong>请简述DHCP 协议在BOOTP基础上主要改进了什么？。</strong></em></h4><p>​	DHCP可以自动获取IP地址分配(不固定)机制，也就是即插即用的联网。和BOOTP不同的地方在于，如果服务器数据库中没有发出请求的主机信息，DHCP能从IP地址缓冲池里动态选择一个IP地址分配给主机(在租期过后则回收这个地址)。</p>
<h4 id="请列出在使用BOOTP协议前，一台计算机在利用网络启动之前，必须在本地需要具有什么协议与参数。"><a href="#请列出在使用BOOTP协议前，一台计算机在利用网络启动之前，必须在本地需要具有什么协议与参数。" class="headerlink" title="请列出在使用BOOTP协议前，一台计算机在利用网络启动之前，必须在本地需要具有什么协议与参数。"></a><em><strong>请列出在使用BOOTP协议前，一台计算机在利用网络启动之前，必须在本地需要具有什么协议与参数。</strong></em></h4><p>​	1.需要知道自己的MAC地址(硬件类型)</p>
<p>​	2.需要支持RARP协议(能进行MAC广播)</p>
<p>​	3.需要支持ICMP协议(用于获取地址掩码和找到默认路由)</p>
<p>​	4.需要支持UDP协议(用于发送BOOTP数据包)</p>
<h4 id="比较使用绑定方案地址分配协议和DHCP动态地址分配协议，哪个更适用于广域网？"><a href="#比较使用绑定方案地址分配协议和DHCP动态地址分配协议，哪个更适用于广域网？" class="headerlink" title="比较使用绑定方案地址分配协议和DHCP动态地址分配协议，哪个更适用于广域网？"></a><em><strong>比较使用绑定方案地址分配协议和DHCP动态地址分配协议，哪个更适用于广域网？</strong></em></h4><p>​	我认为DHCP动态地址分配协议更适合广域网。广域网区域大，而且用户变化大，静态的地址分配方案无法满足大量用户的需求，使用DHCP可以满足大量用户动态接入网络的需求，同时还能提高地址的利用率(不是每台主机都一直工作，如果静态分配会产生大量闲置时间)。与此同时，DHCP优化还可以减少发广播的次数。不管是从效率还是从可行性上看，都应该选择DHCP动态地址分配协议。</p>
<hr>
<h1 id="Chapter5-路由协议"><a href="#Chapter5-路由协议" class="headerlink" title="Chapter5 路由协议"></a>Chapter5 路由协议</h1><p>RIP BGP位于应用层</p>
<h5 id="3个概念：路由选择-路由协议-路由算法"><a href="#3个概念：路由选择-路由协议-路由算法" class="headerlink" title="3个概念：路由选择 路由协议 路由算法"></a>3个概念：路由选择 路由协议 路由算法</h5><p><strong>路由选择</strong>$\rightarrow$通过互连网络从源节点向目的节点传输信息的通道，且中间至少有一个中间节点</p>
<p><strong>路由协议</strong>$\rightarrow$路由指导IP数据报发送过程中事先约定好的规定和标准(规定了IP数据报在网络中存储和转发的方式)</p>
<p>​	<em>路由协议决定了路由选择，而路由算法是路由协议的实现。</em></p>
<p>​	<em>在一个Autonomous System内的路由协议被称为Interior Gateway Protocol</em></p>
<p>​	<em>而AS之间的路由协议则是Exterior Gateway Protocol</em></p>
<p>​	<em>内部网关协议：RIP IGRP EIGRP IS-IS OSPF</em></p>
<p>​	<em>外部网关协议：EGP BGP</em></p>
<p><strong>路由算法</strong>$\rightarrow$提高路由协议的功能，尽量减少路由时带来的开销的算法</p>
<h2 id="分层的路由选择协议"><a href="#分层的路由选择协议" class="headerlink" title="分层的路由选择协议"></a>分层的路由选择协议</h2><p>实际上的Internet是由各个组织的自治域系统AS(Autonomous System)网络互连而成。</p>
<p>而作用在AS内部的 被称为内部网关协议IGP(RIP,OSPF)，外部的则称为外部网关协议EGP(BGP)</p>
<hr>
<h5 id="目前主要使用自适应-分布式协议，对于理想的路由协议-如何实现"><a href="#目前主要使用自适应-分布式协议，对于理想的路由协议-如何实现" class="headerlink" title="目前主要使用自适应 分布式协议，对于理想的路由协议 如何实现?"></a>目前主要使用自适应 分布式协议，对于理想的路由协议 如何实现?</h5><blockquote>
<p>正确性+完整性$\rightarrow$沿着路由表 肯定能到达所有主机</p>
<p>简洁性+合理性$\rightarrow$是保证时延最小 占有系统资源少 同时要求算法技术复杂性尽可能低</p>
<p>健壮性+可靠性$\rightarrow$根据结点故障，拥塞情况等进行动态的调整</p>
<p>稳定性$\rightarrow$网络结构稳定时避免路由表不断变化</p>
<p>公平性$\rightarrow$除非紧急，否则所有用户数据报进行一样的处理</p>
</blockquote>
<h2 id="内部网关协议RIP"><a href="#内部网关协议RIP" class="headerlink" title="内部网关协议RIP"></a>内部网关协议RIP</h2><h5 id="RIP简介"><a href="#RIP简介" class="headerlink" title="RIP简介"></a>RIP简介</h5><p>路由信息协议Router Information Protocol 是最早的广泛应用的分布式路由选择协议 </p>
<p>是比较简单的内部网关协议Interior Gateway Protocol</p>
<p>包括了RIP-1和RIP-2 其中2是1的扩充版</p>
<h5 id="最大的特点：好消息传的快-坏消息传的慢"><a href="#最大的特点：好消息传的快-坏消息传的慢" class="headerlink" title="最大的特点：好消息传的快 坏消息传的慢"></a>最大的特点：好消息传的快 坏消息传的慢</h5><blockquote>
<p>它的设计基于距离矢量算法(Distance-Vector)，使用Hop Count(跳数)来度量和目的网络之间的距离</p>
<p>与设备直连时跳数为0，这个度量值等于到达目的网络间的设备数量。</p>
</blockquote>
<p>为了限制收敛时间，RIP规定度量值取0～15之间的整数 大于等于16目的网络不可达 <strong>这也直接使得RIP不可能应用在大型网络里</strong></p>
<blockquote>
<p>ps: 什么是路由收敛，什么是收敛时间</p>
</blockquote>
<p><strong><u>路由收敛 $\rightarrow$ 所有路由器对当前的网络结构和路由转发达成一致的状态</u></strong></p>
<p><strong><u>收敛时间 $\rightarrow$ 从网络拓扑发生变化，到所有相关路由器都得知这个变化并作出相应改变所需要的时间</u></strong></p>
<h5 id="RIP如何工作"><a href="#RIP如何工作" class="headerlink" title="RIP如何工作"></a>RIP如何工作</h5><blockquote>
<p>路由器A只和邻居路由器交换信息(同一网段所有路由器的接口)，采用主动发送 被动接收的方式</p>
<p>RIP交换的信息是路由器当前所知的全部信息(路由表主体)</p>
<p>每<strong>30s</strong>完成一次信息交换，更新各自路由器的路由表 在更新时，RIPv1总是广播更新，而v2是组播更新</p>
<p>(具体的情况就是 在第一次交换之前 路由器只有直连网络的信息，在几次交换之后，会得到整个自治域的最短距离信息) 在几次交换之后，就能实现每次转发距离最小。</p>
</blockquote>
<h5 id="形成RIP路由表"><a href="#形成RIP路由表" class="headerlink" title="形成RIP路由表"></a>形成RIP路由表</h5><ul>
<li>RouterA启动了RIP协议，向相邻路由器广播一个Request报文</li>
<li>RouterB是A的邻居，受到Request报文后将自己的<strong>整个路由表</strong>封装在Response报文里，向接口对应的网络广播</li>
<li>RouterA根据B的报文形成自己的路由表</li>
</ul>
<h5 id="与RIPv1相比，RIPv2的不同"><a href="#与RIPv1相比，RIPv2的不同" class="headerlink" title="与RIPv1相比，RIPv2的不同"></a>与RIPv1相比，RIPv2的不同</h5><ol>
<li>v1是有类路由协议，v2是无类路由协议</li>
<li>v1不支持VLSM v2支持</li>
<li>v1没有认证功能，v2有明文和MD5认证</li>
<li>v1没有手工汇总，必须自动；v2可以关闭自动汇总</li>
<li><strong>V1总是广播更新，v2组播更新</strong></li>
<li>v1没有路由标记 不能过滤和实施策略</li>
<li>v1发送的updata包没有next-hop属性，这个属性可以用来进行路由更新的重定</li>
<li>使用v1的路由器可以接收v2的报文，而使用v2的则不能接收v1的报文</li>
</ol>
<h5 id="RIP协议-如何出现环路？"><a href="#RIP协议-如何出现环路？" class="headerlink" title="RIP协议 如何出现环路？"></a>RIP协议 如何出现环路？</h5><p>在如下的网段里，R1和C直连 跳数为1 R2到C跳数则为2</p>
<p>现在C网段出现故障 R1到C距离为16 不可达</p>
<p><code>R1</code>准备在下一个30秒内告诉<code>R2</code>这个坏消息，但是<code>R2</code>先把自己的所有信息都告诉了<code>R1</code>,<code>R1</code>一看咦？<code>R2</code>到<code>C</code>的跳数是2，我到<code>R2</code>就一跳，现在虽然我不能直接到<code>C</code>了，那么绕道<code>R2</code>不就可以了吗？说干就干，于是把自己到<code>C</code>的跳数改为<code>3</code>.好了，真相被谎言掩盖了。</p>
<p><code>R1</code>向<code>R2</code>这个坦白所有的信息，<code>R2</code>看到<code>R1</code>到<code>C</code>的距离变为3了，<code>R2</code>知道自己是经过<code>R1</code>才到达的<code>C</code>，于是毫不犹豫的改为4.下一次再把全部信息告诉<code>R1</code>,<code>R1</code>收到一看，咋回事啊，怎么又加一跳了呢！<code>R2</code>那边发生了什么？但是还是得根据规则，毫不犹豫的修改到C的距离跳数。<strong>就这样不断增加，直到都为16</strong>，才恍然大悟，原来大家都到不了了啊。</p>
<hr>
<h2 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h2><h5 id="OSPF简介"><a href="#OSPF简介" class="headerlink" title="OSPF简介"></a>OSPF简介</h5><p>Open Shortest Path First 开放最短路径优先协议 是为了克服RIP的缺陷而设计的。</p>
<p>属于典型链路状态(link-state)协议。在区域内的所有路由器维护共同的链路状态数据库。</p>
<p>维护的数据包括	链路标号	两端连接路由器	链路度量(距离 费用 带宽 时延)</p>
<p><em><strong>可以用在较大的网络中 但路由协议和算法比较复杂</strong></em></p>
<blockquote>
<p>AS 被OSPF划分成若干个区域，每个区域路由器数量不超过200个，并由32位区域标识符描述。</p>
<p>在某个区域的所有路由器，只需要知道本区域的网络拓扑结构即可。这使得OSPF协议的效率比较高</p>
</blockquote>
<p>AS被划分成 Backbone Area(主干区域,0.0.0.0) 和Area，主干区域路由器就是主干路由器，区域之间设置区域边界路由器，这个路由器和主干路由器连接。</p>
<h5 id="OSPF工作原理"><a href="#OSPF工作原理" class="headerlink" title="OSPF工作原理"></a>OSPF工作原理</h5><blockquote>
<p>在区域中使用flooding(泛洪法)，由路由器所有输出接口向相邻路由器发送某个特定链路状态信息(我所知的相邻路由器的链路状态)，再由相邻路由器向其他地方转发(不会发回来) 注意：转发的是人家的包？</p>
<p>经过信息交换，区域中的每个路由器都保存了所有路由链路状态信息 据此组成相同链路状态数据库(LSDB)</p>
<p>在进行数据报的路由选择时，可以通过链路状态计算得到最短路径，并且通过链路度量，能更加灵活的处理</p>
<p>链路发生变化时，OSPF才使用泛洪法发送变化的信息</p>
</blockquote>
<p>分层区域设置 让交换路由信息的种类增加。随着层次增加，OSPF会逐渐变的更加复杂 但在更强大的设备加持下，OSPF能够有效的管理大规模的网络</p>
<p>网络按照层次结构设计时大规模网络普遍采用的设计原则。一般分为接入层、汇聚层(边缘层)、核心层；同样的设备在不同的层次时所完成的工作也是不同的。</p>
<h5 id="OSPF路由算法"><a href="#OSPF路由算法" class="headerlink" title="OSPF路由算法"></a>OSPF路由算法</h5><p>在建立链路状态数据库后 路由器相当于拥有了网络拓扑的完整信息，根据网络拓扑构建网络最短路径树，路由器就能建立自己的***<u>隐式路由表</u>***(只供自己使用)</p>
<blockquote>
<p>根据本区域的 链路状态数据库 计算到本区域的各个网络路由</p>
<p>根据本AS的 链路状态数据库 计算到AS中其他区域各个网络路由。</p>
<p>​	主干路由器根据到区域边界路由器(ABR)距离,和ABR到区内网络的距离综合选择路由</p>
<p>根据到AS域边界路由器+AS边界路由器到外部目的网络的距离，计算选择的路由</p>
</blockquote>
<p>OSPF可以根据IP首部的TOS(Type Of Service服务类型)对不同的链路设置代价(1-65535) 根据链路带宽 时延来计算</p>
<p>如果有多个相同代价的路由，还可以作多路径间多负载均衡，支持VLSM和CIDR 健壮性、稳定性、服务质量都不错。</p>
<h5 id="OSPF和RIP的区别"><a href="#OSPF和RIP的区别" class="headerlink" title="OSPF和RIP的区别"></a>OSPF和RIP的区别</h5><p>RIP只关注最短路径(这个路径还是只看跳数决定的)和下一跳路由器；而OSPF则能进行链路状态计算，还有链路度量机制</p>
<p>RIP在进行信息交换时不是转发人家发来的包，而是根据他的人包更新，然后发送自己的包(OSPF是转发)</p>
<p>RIP的信息交换是定时的！而OSPF则是检测到链路变化时才发送。</p>
<p>OSPF虽然有着更好的服务效果，但对计算能力的要求比较高</p>
<p><em><strong>对于距离矢量路由协议来说交换的是路由表，每个路由器的路由表都是照搬其他人的包，并不需要计算</strong></em></p>
<p><em><strong>而链路状态路由协议交换链路状态</strong></em></p>
<h2 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h2><h5 id="BGP简介"><a href="#BGP简介" class="headerlink" title="BGP简介"></a>BGP简介</h5><p>自治域间的路由选择由外部网关协议负责。	早期出现的EGP(外部网关协议)已经不再使用</p>
<p>Border Gateway Protocol(version 4)占有重要地位 所有的 AS都需要通过BGP-4获取彼此路由信息。</p>
<h5 id="在域间路由选择时面临的问题"><a href="#在域间路由选择时面临的问题" class="headerlink" title="在域间路由选择时面临的问题"></a>在域间路由选择时面临的问题</h5><blockquote>
<p>可扩展性 ：</p>
<p>域间路由器必须能转发Internet里所有可能的地址的分组。需要的路由表必须提供任何合法的IP地址分配</p>
<p>适应 域的自治特性：</p>
<p>每个自治域被允许使用自己的内部路由协议，选择一条穿越多个AS的路径的最优化是无意义的</p>
<p>对自治域的信任问题</p>
<p>在路由信息交互时，各个ISP提供的路由选择信息是否存在错误？以及域间路由的灵活策略(如一个多连接的ISP可制定通往AS1与AS3的策略 存在信任问题)</p>
</blockquote>
<h5 id="BGP的工作原理"><a href="#BGP的工作原理" class="headerlink" title="BGP的工作原理"></a>BGP的工作原理</h5><p><em><strong>首要目标是 找到任何一条 无环的 通往预定目的地的路径(可达优先，没必要最优)</strong></em></p>
<p>其处理特点是：</p>
<p><em><strong>能够进行路由优选 避免路由环路 更高效传递路由和维护大量路由信息</strong></em></p>
<p>跨越多跳路由器建立邻居关系(基于TCP协议) 在BGP路由里携带丰富的属性值</p>
<ol>
<li>自治域间路由，系统层次：自治域外提供路由信息，也就是边界路由器，一个AS设置一个发言人和其他AS交换信息</li>
<li>政策性约束，管理员可以配置BGP对某些路径不提供中转的策略，即使它知道如何到达目的地址</li>
<li>中转路由设施，当一个自治域同意某个业务流通过本系统转送到另外一个AS时，BGP会作为Transit System。当有一个以上的其他AS连接 但拒绝中转通信的AS称为Multihomed AS，只和一个AS连接 只传输本地业务流称为Stub System(桩AS)</li>
<li>可靠传输，BGP使用TCP通信。</li>
</ol>
<hr>
<blockquote>
<p>路由器中路由协议和路由算法各自完成什么作用？</p>
</blockquote>
<p>​	路由协议规定和指导IP数据报在网络中的存储转发方式。路由算法则需要提高路由协议的功能(工作效率),尽量减少路由时产生的开销，并且尽可能做到快速收敛。</p>
<p>路由协议完成路由信息动态交换，并以此建立路由表；路由算法是根据转发IP包的目的地址，依据路由表计算出最优转发路径和端口。</p>
<blockquote>
<p>什么是跳数？RIP协议为什么将最大跳数设为16？</p>
</blockquote>
<p>​	跳数(Hop Count)，从源端口到目的端口所经过的路由设备个数</p>
<p>​	为了限制收敛时间。在网络中有一个设备出现故障时，与其直连的设备知道网络不可达，但在更新之前如果其他不知情的路由设备向故障网段发送报文，就会出现误解的情况从而出现环路，两个设备到故障网段的跳数不断增加直到达到16时才能确认不可达。</p>
<blockquote>
<p>RIP协议工作的基本思想，主要问题在那里？</p>
</blockquote>
<p>​	1.只和相邻路由器交换信息 采取主动发送 被动接收到方式</p>
<p>​	2.每30s一次交换，每次都交换整个路由表</p>
<p>主要的问题：</p>
<pre><code class="hljs">1. 规定最多16跳，所有路由器持有全部路由信息，不能用在大型网络上

2. 只根据跳数来判断传输效率，不考虑链路带宽和延时等等其他因素
3. 发生故障时，收敛速度慢
4. 无法考虑多链路的负载均衡机制
5. 不能识别服务等级和类型
</code></pre>
<blockquote>
<p>目前网络路由协议主要考虑的哪些要素？</p>
</blockquote>
<p>见<code>理想路由协议如何实现</code></p>
<blockquote>
<p>简述互联网为什么要定义自治域AS，解释为什么要分层路由。</p>
</blockquote>
<p>定义自治域AS：全球有很多的公司和组织需要接入互联网，但根据其业务或条件的不同，其内部拓扑有着很大区别，并且其网络构成细节也希望不对外界公开，所以引入AS的概念来让不同的互联网实体可以无障碍沟通的同时保留自己的完整性。</p>
<p>分层路由：实际上的互联网是由各个AS互连而成，而由于业务等等因素的区别，每个AS的内部拓扑和使用的协议不一定相同，因此进行分层的路由，在AS内部使用IGP，只需要考虑内部的拓扑结构，而AS之间使用BGP也可以无视不同AS内部的差异。</p>
<blockquote>
<p>RIP与OSPF协议主要特点，各自处理的自治域规模一般多大？</p>
</blockquote>
<p>RIP是基于距离矢量算法设计，只考虑跳数，所以路由选择没有考虑到链路的带宽和延时，引入不可超过16跳来避免环路也让其只能用于早期的 小型的互联网。但其的算法思路简单，对路由设备算力的要求低于OSPF协议。</p>
<p>OSPF则属于典型链路状态协议。在区域内的所有路由器维护共同的链路状态数据库，能够考虑到各种链路因素。自治域在OSPF中被划分成了若干个区域(每区域不超过200个路由器)，这使得OSPF不仅效率高，而且也能用在较大规模的自治域中。但随着层次的增加，OSPF协议会变的更加复杂，所以对设备的配置有一定要求。</p>
<p>RIP只能用在小型的自治域中(如果自治域中任意两个端点的最短距离大于等于16就不能再使用RIP协议了)</p>
<p>OSPF可以用在大规模的自治域中。</p>
<blockquote>
<p>简单说明IGP和EGP协议主要区别。</p>
</blockquote>
<p>IGP(Interior Gateway Protocol)用在自治域的内部，用来在AS内部交换路由信息。</p>
<p>EGP(Exterior Gateway Protocol)用于连接不同的自治域，通过策略和过滤来控制路由信息在不同AS间的传播。</p>
<blockquote>
<p>简述自治域划分与因特网主干网、区域ISP和用户接入网的关系。</p>
</blockquote>
<p>因特网主干网作为一个自治域和多个其他主干网互连，区域ISP则可以直接接入因特网主干网，而用户接入网则作为ISP的客户接入ISP，通过ISP来访问主干网。</p>
<blockquote>
<p>BGP协议是否一定能提供最佳路径，为什么？</p>
</blockquote>
<p>我认为不是。虽然BGP协议能路由优选 避免路由环路 更高效传递路由和维护大量路由信息。但首要目标是找到任何一条无环的通往预定目的地的路径(可达性为最优先)</p>
<blockquote>
<p>简述因特网的实际结构和特点，中国因特网可能的基本组成结构是？</p>
</blockquote>
<p>​	因特网实际上是由各个组织的自治域系统AS网络互连而成，并非平面结构而是层次结构。由核心层 分布层 接入层构成。主干网，城域网(ISP)和用户网(LAN)组成了其层次结构。</p>
<p>组成成分：</p>
<ol>
<li>网根结构是多个主干网(AS)互连</li>
<li>大公司和ISP直接与一个或者多个主干网连接</li>
<li>小公司和个人用户作为ISP的客户接入ISP</li>
</ol>
<blockquote>
<p>RIP为什么称为距离向量协议？</p>
</blockquote>
<p>基于距离矢量算法设计</p>
<blockquote>
<p>路由协议有什么作用？</p>
</blockquote>
<p>路由指导数据报转送方式，是传输过程中事先约定好的规定和标准</p>
<blockquote>
<p>什么是自治域？举两个例子。</p>
</blockquote>
<p>一个自治系统（Autonomous System，AS）是一组路由器的集合，它们拥有同样的选路策略、被同一技术管理部门管理运行。  </p>
<blockquote>
<p>OSPF协议交换什么信息，路径最优含义？</p>
</blockquote>
<p>交换的是链路状态信息，包括接口上的IP地址 子网码 网络类型 代价 区域</p>
<p>开放最短路径优先，构建一颗最短路径优先树。</p>
<hr>
<h1 id="Chapter6-C-S模式与API"><a href="#Chapter6-C-S模式与API" class="headerlink" title="Chapter6 C&#x2F;S模式与API"></a>Chapter6 C&#x2F;S模式与API</h1><h1 id="网络服务模式与API"><a href="#网络服务模式与API" class="headerlink" title="网络服务模式与API"></a>网络服务模式与API</h1><h2 id="Client-Server-模式"><a href="#Client-Server-模式" class="headerlink" title="Client&#x2F;Server 模式"></a>Client&#x2F;Server 模式</h2><h3 id="因特网的基本通信模式"><a href="#因特网的基本通信模式" class="headerlink" title="因特网的基本通信模式"></a>因特网的基本通信模式</h3><ul>
<li><h5 id="流模式-如-Web通信"><a href="#流模式-如-Web通信" class="headerlink" title="流模式(如: Web通信)"></a>流模式(如: Web通信)</h5></li>
<li><h5 id="报文模式"><a href="#报文模式" class="headerlink" title="报文模式"></a>报文模式</h5></li>
</ul>
<h3 id="C-S模式基本概念"><a href="#C-S模式基本概念" class="headerlink" title="C&#x2F;S模式基本概念"></a>C&#x2F;S模式基本概念</h3><h5 id="一种基于网络的信息交互-计算-分布模式"><a href="#一种基于网络的信息交互-计算-分布模式" class="headerlink" title="一种基于网络的信息交互/计算 分布模式"></a><code>一种基于网络的信息交互/计算 分布模式</code></h5><p><strong>网络软件被分为client和server 这两个名词直接指向通信中的两个进程，而不是主机</strong></p>
<h3 id="C-S模式的关系和特点"><a href="#C-S模式的关系和特点" class="headerlink" title="C&#x2F;S模式的关系和特点"></a>C&#x2F;S模式的关系和特点</h3><ul>
<li>对于C&#x2F;S模式 一定<strong>由客户发起请求，而服务器只被动响应</strong> $\rightarrow$ 请求&amp;应答 的分布计算(会话)模式</li>
<li>应用进程可以同时是服务器和客户</li>
</ul>
<blockquote>
<p>对于服务器软件 $\rightarrow$ <strong>主体框架 + 单个服务请求处理 + 并发服务请求处理</strong></p>
<ul>
<li>在共享计算机上首先运行，当系统启动时自动调用并不断运行</li>
<li>被动等待并且接受来自任意客户的通信请求 在大部分情况下 服务器软件提供单一的服务</li>
<li>可以同时处理多个远地&#x2F;本地客户的请求，但也需要强大的硬件和高级的操作系统支持  <strong>并发执行是服务器必须具备的</strong></li>
<li><strong>一个服务器软件包括 接收请求、处理单个请求和生成新线程三个部分</strong></li>
</ul>
</blockquote>
<blockquote>
<p>对于客户软件 $\rightarrow$ <strong>客户软件只是一个应用程序在进行服务器访问时的称呼</strong></p>
<ul>
<li>是任意的应用程序，它一般还能在本地做其它的事情</li>
<li>被用户调用 主动向远地服务器发起通信</li>
</ul>
</blockquote>
<h5 id="较复杂的C-S交互"><a href="#较复杂的C-S交互" class="headerlink" title="较复杂的C&#x2F;S交互"></a>较复杂的C&#x2F;S交互</h5><ul>
<li>客户应用不限制访问一个服务器，它需要同时和多个服务器通信。</li>
<li>服务器在提供服务的同时也需要作为另一个服务器的客户</li>
<li>服务器间可能会出现循环依赖</li>
</ul>
<p>在早期C&#x2F;S系统中 服务器计算机通常作为信息共享的设备部署(文件服务器、数据库服务器) 客户端自己来计算和跑程序</p>
<p>现今阶段 服务器是数据与业务功能处理中心 客户端则主要是UI界面+少量辅助功能处理</p>
<hr>
<h3 id="服务器识别"><a href="#服务器识别" class="headerlink" title="服务器识别"></a>服务器识别</h3><p><strong>Protocol Port Number 协议端口号 (OSI 术语是运输层服务访问点TSAP) 是TCP&#x2F;UDP给每种服务定义的标识</strong></p>
<p>对于源进程(它发起了请求)交付通信时通过 端口号明确自己的身份 还有接收方身份</p>
<p>收端进程会通过端口号来向目的进程交付。(很明显 这一切都发生在运输层)</p>
<p>对于服务器 通过端口号来明确提供的服务</p>
<h5 id="服务器端口号必须是唯一定义的-而客户端的端口号可以是临时指定的-只在本地有意义"><a href="#服务器端口号必须是唯一定义的-而客户端的端口号可以是临时指定的-只在本地有意义" class="headerlink" title="服务器端口号必须是唯一定义的 而客户端的端口号可以是临时指定的(只在本地有意义)"></a>服务器端口号必须是唯一定义的 而客户端的端口号可以是临时指定的(只在本地有意义)</h5><blockquote>
<p><strong>在使用TCP通信时 只有端口号是不够的 TCP的两个端点由Socket 插口 :(IP地址，端口号)定义</strong> (或者叫端地址)</p>
</blockquote>
<h5 id="协议端口号定义"><a href="#协议端口号定义" class="headerlink" title="协议端口号定义"></a>协议端口号定义</h5><p>TCP&#x2F;UDP定义一套16bit整数值 端口号被分为熟知端口号和一般端口号两列</p>
<p>熟知端口号 : FTP $\rightarrow$ 21	Telnet $\rightarrow$ 23	SMTP $\rightarrow$ 25	DNS $\rightarrow$ 53	TFTP $\rightarrow$ 69	HTTP $\rightarrow$ 80	SNMP $\rightarrow$ 161</p>
<p>一般端口号可以在规定区域内随意定义和分配</p>
<p>主要的端口号在1-225之间</p>
<p>端口号256-1023由Unix系统占用 </p>
<p>1024-5000作为临时端口 5000+不常出现 </p>
<h3 id="其他的交互模式"><a href="#其他的交互模式" class="headerlink" title="其他的交互模式"></a>其他的交互模式</h3><blockquote>
<p>C&#x2F;S模式比较简单 但容易造成网络瓶颈 并且负载不均衡问题也会使得服务器常常过载</p>
</blockquote>
<h5 id="P2P-peer-to-peer-：无中心服务器的流行网络技术-依赖所有参与者的计算能力和带宽-占到因特网流量的50-90"><a href="#P2P-peer-to-peer-：无中心服务器的流行网络技术-依赖所有参与者的计算能力和带宽-占到因特网流量的50-90" class="headerlink" title="P2P (peer to peer)：无中心服务器的流行网络技术 依赖所有参与者的计算能力和带宽 占到因特网流量的50%-90%"></a>P2P (peer to peer)：无中心服务器的流行网络技术 依赖所有参与者的计算能力和带宽 占到因特网流量的50%-90%</h5><hr>
<blockquote>
<p><strong>因特网通信模式和C&#x2F;S模式各自说明什么问题</strong></p>
<p>因特网通信模式：流模式和报文模式有着比较鲜明的特点，说明我们对因特网功能的需求是多样的，而网络技术也可以用不同的通信模式来满足不同的用户需求，但也说明想要实现稳定可能就需要牺牲效率，实现高效可能就保证不了可靠的传输。</p>
<p>C&#x2F;S模式：早期的C&#x2F;S模式以文件数据访问服务为主，客户程序也需要进行计算。而现今的C&#x2F;S模式在强大的服务器算力支撑下，客户端几乎不用承担计算任务，这说明C&#x2F;S模式的确得到了大规模的应用，所以服务器技术才能发展的如此迅速。</p>
</blockquote>
<blockquote>
<p><strong>简述客户软件和服务器软件主要特点</strong></p>
<p>服务器软件：</p>
<ol>
<li>专门提供某类服务的程序，一定可以并行的处理多个客户请求。</li>
<li>运行在共享计算机上，只要系统不关闭，就一直运行。</li>
<li>被动等待并且接收来自任意用户的通信请求</li>
<li>一般需要较强大的硬件和高级的操作系统支持</li>
</ol>
<p>客户软件：</p>
<ol>
<li>只有在进行通信时才被称为客户，它也可能可以在本地进行其他的计算并且实现其他功能。</li>
<li>由用户调用，在用户本地计算机上运行，在用户有需要时主动向远地服务器发起通信请求。</li>
<li>可以与多个服务器通信 并且一般不需要特殊硬件和复杂的操作系统</li>
</ol>
</blockquote>
<blockquote>
<p><strong>一个服务器软件通常需要包括哪些主要的功能部分？</strong></p>
<p>一个服务器软件主要包括：等待接收请求、处理单个请求和生成新线程</p>
</blockquote>
<blockquote>
<p><strong>为什么通常服务器端口号是唯一定义的，而客户端的端口号可以临时指定？</strong></p>
<p>服务器端口号唯一定义是为了让所有的客户都能正确找到它。因为C&#x2F;S交互的身份问题，客户端的端口号只需要做到不和自己同时运行的其他进程混淆即可，临时指定端口号也可以实现同一个端口号的复用(当某个客户软件不运行时就不占用端口号了)</p>
</blockquote>
<hr>
<h1 id="API-Application-Program-Interface"><a href="#API-Application-Program-Interface" class="headerlink" title="API [Application Program Interface]"></a>API [Application Program Interface]</h1><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h5 id="是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节"><a href="#是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节" class="headerlink" title="是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节"></a><code>是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节</code></h5><ul>
<li><strong>在应用从操作系统中获得相关服务时 通过调用API 将任务和控制权都交给操作系统，在执行完毕后，操作系统会交还控制权</strong></li>
<li>网络通信和数据交互调用API $\rightarrow$ 网络API(他是应用程序和TCP&#x2F;IP协议通信交互的接口)</li>
<li><strong>API造就了 应用和网络 的一体 和 分离 $\rightarrow$  在使用时一体，在开发时分离</strong></li>
</ul>
<p>互联网中主要有两类API 伯克利版 $\rightarrow$ Socket API 以及 A&amp;AT版 $\rightarrow$ TLI[Transport Lay Interface]</p>
<p>其中Socket API被主流操作系统使用，成为标准。</p>
<h3 id="Socket-API"><a href="#Socket-API" class="headerlink" title="Socket API"></a>Socket API</h3><ul>
<li>它来自Unix 由于Unix一切皆文件(open - read - write - close)的哲学影响，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</li>
<li><strong>在通信前 APP要向OS申请一个 套接字(也叫通信描述符)，OS返回一个小的整形数作为描述符来识别这个套接字 在通信结束后，这个代表特殊参数的套接字会被回收</strong></li>
<li><strong>套接字API 定义并调用多个函数来确定参数和选项 (创建套接字(返回描述符)，然后调用这些函数来完成对接)</strong></li>
</ul>
<h3 id="实现套接字API的函数"><a href="#实现套接字API的函数" class="headerlink" title="实现套接字API的函数"></a>实现套接字API的函数</h3><ol>
<li><p><code>Socket</code>函数 <strong>&#x2F;&#x2F; 创建套接字并返回整型描述符</strong></p>
<p>$Descriptor &#x3D; socket(pf,type,protocol)$ </p>
<p>pf $\rightarrow$ ProtocolFamily:协议栈(TCP&#x2F;IP)  Type $\rightarrow$ 连接&#x2F;无连接 protocol $\rightarrow$ 具体协议</p>
</li>
<li><p><code>Bind</code> 函数 <strong>&#x2F;&#x2F; 赋予套接字特定的端地址，实现socket和端地址的联编</strong> <strong><u><em>联编相当于 绑定</em></u></strong></p>
<p>$Bind(socket,locaaddr,addrlen)$ <strong>&#x2F;&#x2F; 不建立连接的话，bind函数之后就可以交互数据了</strong></p>
<p>loca addr $\rightarrow$ 本地端地址的一般socket地址描述结构。</p>
</li>
<li><p><code>Close</code> 函数 <strong>&#x2F;&#x2F; 告诉系统终止对一个套接字的使用(释放这个套接字)</strong></p>
<p>$close(socket)$ <strong>&#x2F;&#x2F; 如果面向连接，则先关闭连接，再回收套接字</strong></p>
</li>
<li><p><code>Listen</code> 函数 **&#x2F;&#x2F; (<em>只有面向连接使用) 套接字被设置为被动模式，等待连接请求</em>*</p>
<p>$Listen(socket,queuesize)$ Queue size $\rightarrow$ 客户请求队列长度</p>
</li>
<li><p><code>Connect</code>函数 <strong>&#x2F;&#x2F; 面向连接时使用，启动与服务器的连接(前提是服务器已经调用了listen和accept)</strong></p>
<p>$connect(socket,saddress,saddresslen)$  &#x2F;&#x2F;在UDP时 也可以使用 此时完成socket和目的服务器端地址联编</p>
</li>
<li><p><code>Accept</code>函数 **&#x2F;&#x2F; (<em>只有面向连接使用) 确定客户端的地址，确认连接，这时需要创建一个新的套接字，通信结束后回收</em>*</p>
<p>$newsock &#x3D; accept(caddress,caddresslen)$</p>
<p>c address$\rightarrow$按照socket地址结构描述的<strong>客户端IP地址</strong></p>
</li>
<li><p><code>Send</code>函数 <strong>&#x2F;&#x2F; 客户和服务器使用这个函数来发送消息</strong></p>
<p>$send(socket,data,length,flags)$ </p>
<p>data $\rightarrow$ 内存待发数据的地址	length $\rightarrow$ 数据字节数	flags $\rightarrow$ 特殊选项(用来调试系统)</p>
<p>$sendto(socket,data,length,flags,destaddress,addresslen)$ <strong>&#x2F;&#x2F;无连接使用sendto函数</strong></p>
<p>$sendmgs(socket,mgsstruct,flags)$ 作用和sendto类似</p>
</li>
<li><p><code>Recv</code>函数 <strong>&#x2F;&#x2F; 客户和服务器从套接字接收数据</strong></p>
<p>$recv(socket,buffer,length,flags)$</p>
<p>buffer $\rightarrow$ 内存中收到数据的地址	length $\rightarrow$ 缓冲区大小	flags$\rightarrow$特殊选项</p>
<p>$recvfrom(socket,buffer,length,flags,sndraddr,saddrlen)$ <strong>&#x2F;&#x2F;无连接使用recvfrom函数</strong></p>
<p>$recvmgs(socket,mgsstrucct,flags)$ 作用和recvfrom类似 <strong>sendmgs和recvmgs是原函数的简化参数版本</strong></p>
</li>
<li><p>其他</p>
<ol>
<li>$write(socket,buffer,length) &#x2F; read(socket,buffer,length)$ Unix的I&#x2F;O一般操作 在连接之后和send-recv一样</li>
<li>$getpeername$ <strong>&#x2F;&#x2F;调用accept接收连接请求后调用这个函数获取客户端地址</strong></li>
<li>$gethostname$ <strong>&#x2F;&#x2F;调用这个函数获取本机的完整信息，可以是域名，也可能是其他</strong></li>
<li>$ gethostbyname$ <strong>&#x2F;&#x2F;知道域名时 调用这个函数获取本机IP地址</strong></li>
<li>$getprotobyname$ <strong>&#x2F;&#x2F;知道域名时 调用这个函数获取 socket使用的二进制形式IP地址</strong></li>
<li>$gethostbyaddr$ <strong>&#x2F;&#x2F;知道IP地址，获取域名     这两个函数在API中完成IP地址和域名的转换</strong></li>
</ol>
</li>
</ol>
<p>备注：</p>
<ol>
<li><code>Accept</code>确认连接地址之后 需要创建一个新的socket (可以根据C&#x2F;S模式理解成，服务器创建新线程)，只要连接建立，原来的套接字就会用来和下一个客户进行连接。</li>
<li>服务器可以并发，服务器创建并发线程时套接字也会产生一个副本，这样就实现了并发线程都能调用所有的套接字功能</li>
<li><code>Listen</code>和 <code>Accept</code>函数是<em><strong>面向连接通信时</strong></em>服务器必须进行的调用</li>
</ol>
<h3 id="套接字API与C-S"><a href="#套接字API与C-S" class="headerlink" title="套接字API与C&#x2F;S"></a>套接字API与C&#x2F;S</h3><p>刚刚的程序每次收到请求都会打印一段信息(建立连接)。 </p>
<p>可以注意的是 <em><strong>客户端不需要 socket和端地址联编</strong></em> 因为客户端的端口号可以是临时指定的(端地址也就相当于是可变的)，如果客户端需要向服务器发送报文，那另说。</p>
<hr>
<blockquote>
<p><strong>API是否由TCP&#x2F;IP所定义，目前互联网最常用的API体系是什么。</strong></p>
<p>不是。API是宏观的概念，而网络中使用的API主要分为Socket API(它由Berkeley UNIX定义)和TLI ，其中Socket API被主流的操作系统使用，所以Socket API是互联网最常用的API体系。</p>
</blockquote>
<blockquote>
<p><strong>API接口与协议端口、插口有什么区别？</strong></p>
<p>在网络中使用的API，指的是应用程序和TCP&#x2F;IP协议通信交互的接口，它是经过抽象后定义的一组(函数)操作，由操作系统来调用它。API使得应用进程和TCP&#x2F;IP(运输层)实现透明。</p>
<p>协议端口是TCP&#x2F;UDP给每种服务定义的标识，在进程进行交互时协助对接。协议端口使得两端的操作系统都能识别身份和服务。</p>
</blockquote>
<blockquote>
<p><strong>服务器套接字API有哪些专门的函数（过程）；对一个面向连接的TCP通信，服务器端套接字API的实现要经过那些过程调用？</strong></p>
<ol>
<li>socket	bind	listen	accept	connect	close	send(sendto)	recv(recvfrom)	getpeername	gethostname	gethostbyname	getprotobyname	gethostbyaddr等</li>
<li>对于面向连接 服务器端API的实现要经过<ol>
<li>getprotobyname 获取IP地址</li>
<li>Socket 建立套接字</li>
<li>bind (socket和端口号联编)</li>
<li>listen 套接字设置为被动模式，等待连接请求</li>
<li>accept 确定客户端的地址，确认连接，并且返回一个新创建的套接字 </li>
<li>send&amp;recv 发送和接收数据</li>
<li>close 关闭连接 回收套接字</li>
</ol>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong>对一个非连接通信，客户端套接字为什么不必和本地端地址绑定？</strong></p>
<p>因为客户端的端口号可以是临时指定的(端地址也就相当于是可变的)，这个端地址仅仅具有本地的意义，由于端地址已经可以在本地唯一的标识进程，即使不绑定套接字OS和TCP&#x2F;IP也都能通过端地址来找到应用进程。</p>
</blockquote>
<hr>
<h1 id="Chapter7-Web开发技术"><a href="#Chapter7-Web开发技术" class="headerlink" title="Chapter7 Web开发技术"></a>Chapter7 Web开发技术</h1><h3 id="远程过程调用-RPC-「Remote-Procedure-Call」"><a href="#远程过程调用-RPC-「Remote-Procedure-Call」" class="headerlink" title="远程过程调用 RPC 「Remote Procedure Call」"></a>远程过程调用 RPC 「Remote Procedure Call」</h3><p><strong>RPC模式 以及利用此模式制作的RPC中间件(通信插件) 旨在简化Web开发，使得程序员可以使用高级语言来建构程序(特别是网络分布式程序 如C&#x2F;S架构) 而不是利用API来调用</strong></p>
<ul>
<li><code>套接字API</code> 是底层通信过程最直接的抽象 直接面向TCP&#x2F;IP通信过程 所以即使是使用API来调用底层硬件<strong>仍然比较麻烦</strong> 并且会出现异常 好在<em><strong>API不是网络应用程序间通信实现的唯一方法</strong></em></li>
<li><code>procedure 过程</code> 指能解决一系列相关人物的可调用程序，(传统面向过程编程里的子程序)</li>
<li><code>procedure call 过程调用</code> 是面向过程编程机制 每个过程利用一组形式化参数定义，当过程被调用时 调用者要提供与形参匹配的实参(直接可以理解成 函数 和函数的调用)</li>
<li><code>RPC</code> <ul>
<li>是最早被提出和开发的C&#x2F;S通信工具的机制 </li>
<li>使用<strong>传统编程语言结构</strong>向开发者提供接口，而不像API那样需要利用显式通信原语</li>
<li>RPC允许程序员将过程适配到多个主机上，通过不同计算机间进行的远程过程调用自动生产代码并完成通信</li>
</ul>
</li>
</ul>
<h4 id="RPC模式规范"><a href="#RPC模式规范" class="headerlink" title="RPC模式规范"></a>RPC模式规范</h4><ul>
<li>我们需要的 RPC模式在现有的编程语言中扩展，设计了一种符合<strong>高级语言编写规范(考虑到不同计算机的适配问题 需要用高级语言 汇编不行)</strong> 并能自动处理网络通信细节</li>
<li>RPC允许客户端 <strong>跨过网络调用服务器过程 在这种情况下就可以使用<code>RPC工具</code>，它将生成处理所需的通信过程插件<code>communication stub/proxy</code> 真正的通信任务交给插件来完成 如下图</strong><ul>
<li>在使用通信插件后 程序员被允许在忽略底层通信拓扑的基础上使用高级语言和成熟的编程方法来进行架构 提高软件的可靠性<ul>
<li>客户端 $\Rightarrow$ 客户插件 + 客户端主程序</li>
<li>服务器 $\Rightarrow$ 服务器插件 + 远程过程</li>
</ul>
</li>
</ul>
</li>
<li><code>中间件 middleware</code> 是介于传统应用程序和系统平台(os和hardware system) 之间的通用服务工具 主要的作用是以下三点 我认为这和API有很多相似之处<ul>
<li>提供标准接口 ｜ 支持分布式计算(负载均衡) ｜ 支持跨平台</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Chapter8-Multi-Media-VoIP"><a href="#Chapter8-Multi-Media-VoIP" class="headerlink" title="Chapter8 Multi-Media&amp;VoIP"></a>Chapter8 Multi-Media&amp;VoIP</h1><h2 id="互联网中的实时业务"><a href="#互联网中的实时业务" class="headerlink" title="互联网中的实时业务"></a>互联网中的实时业务</h2><ul>
<li>多媒体「multimedia」 一般用来指含有音频&#x2F;视频的数据，当然也适用于文本</li>
</ul>
<p>这类信号在数字化后如果按照因特网传输数据的方式到达接收方，<strong>并实时的展示出来</strong> 其结果是难以接受的</p>
<p>我们知道 音视频信号的传播过程 包括 抽样、编码(D&#x3D;&gt;S)、网络传输、解码</p>
<p>而因特网存在的 丢包 和 乱序问题</p>
<p>丢包 $\Rightarrow$ 抽样值丢失</p>
<p>乱序 $\Rightarrow$ 抽样值时延不一致！这会造成以下我们所说的 <code>抖动</code></p>
<ul>
<li><h4 id="网络吞吐率T-单位时间内-有效传输的-比特-字节数「与带宽、速率的区别在于-它们俩用来表示某条链路-而不是整个网络」"><a href="#网络吞吐率T-单位时间内-有效传输的-比特-字节数「与带宽、速率的区别在于-它们俩用来表示某条链路-而不是整个网络」" class="headerlink" title="网络吞吐率T 单位时间内 有效传输的 比特&#x2F;字节数「与带宽、速率的区别在于 它们俩用来表示某条链路 而不是整个网络」"></a>网络吞吐率T 单位时间内 有效传输的 比特&#x2F;字节数「与带宽、速率的区别在于 它们俩用来表示某条链路 而不是整个网络」</h4></li>
<li><h4 id="网络时延D-一个分组-通过网络需要的时间"><a href="#网络时延D-一个分组-通过网络需要的时间" class="headerlink" title="网络时延D 一个分组 通过网络需要的时间"></a>网络时延D 一个分组 通过网络需要的时间</h4></li>
</ul>
<p>处理实时业务时碰到的最大困难， 不是分组丢失 而是 <strong><code>抖动「jitter」</code></strong> 这意味着「**<code>与常规的传输协议不同，传输实时数据的协议 只需要处理抖动问题，而不需要重传丢失的分组</code>**」</p>
<p><em><u>抖动的定义：「信号的某特定时刻相对于其理想时间位置上的短期偏离」</u></em> 相当于“跳ping、很小的延迟变化”</p>
<p>因特网无法要求底层的网络具有处理实时业务的功能 所以解决方案有两个</p>
<ol>
<li><h4 id="设计等时延、无抖动的网络-PSTN-TDM电路"><a href="#设计等时延、无抖动的网络-PSTN-TDM电路" class="headerlink" title="设计等时延、无抖动的网络(PSTN\TDM电路)"></a>设计等时延、无抖动的网络(PSTN\TDM电路)</h4></li>
<li><h4 id="设计抖动补偿协议-实现平滑重放「playback」-这又包含了两种主要的模式"><a href="#设计抖动补偿协议-实现平滑重放「playback」-这又包含了两种主要的模式" class="headerlink" title="设计抖动补偿协议 实现平滑重放「playback」 这又包含了两种主要的模式"></a>设计抖动补偿协议 实现<em><strong>平滑重放「playback」</strong></em> 这又包含了两种主要的模式</h4><ol>
<li><h5 id="时间戳「timestamp」-每个小片提供一个时间戳，接收方按照时间戳重放"><a href="#时间戳「timestamp」-每个小片提供一个时间戳，接收方按照时间戳重放" class="headerlink" title="时间戳「timestamp」 每个小片提供一个时间戳，接收方按照时间戳重放"></a>时间戳「timestamp」 每个小片提供一个时间戳，接收方按照时间戳重放</h5></li>
<li><h5 id="抖动缓冲「jitter-buffer」缓冲收到的数据、然后推迟重放"><a href="#抖动缓冲「jitter-buffer」缓冲收到的数据、然后推迟重放" class="headerlink" title="抖动缓冲「jitter buffer」缓冲收到的数据、然后推迟重放"></a>抖动缓冲「jitter buffer」缓冲收到的数据、然后推迟重放</h5></li>
</ol>
<p>实现抖动缓冲 我们只需要维护一个cache然后延迟d个时间单位，虽然分组到达的时间略有不同，但总会在d时间之内到达，我们均匀的输出分组，就没有关系了</p>
</li>
</ol>
<ul>
<li>想要实现流式传输有两种方法 ： 实时流式传输「RTS」 和 顺序流式传输</li>
<li>新世纪以来，流式存储下载的局限性越来越明显，而顺序流式传输「progressive streaming」成为主流</li>
</ul>
<h2 id="实时传输协议RTP「Real-time-Transport-Protocol」"><a href="#实时传输协议RTP「Real-time-Transport-Protocol」" class="headerlink" title="实时传输协议RTP「Real-time Transport Protocol」"></a>实时传输协议RTP「Real-time Transport Protocol」</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p>来自应用层｜支持单播&#x2F;多播｜提供时间信息+实现流同步｜<strong>通常使用UDP 也可在TCP&#x2F;ATM等协议上工作</strong></p>
<p><strong>RTP &#x3D; RTP数据协议+RTP控制协议</strong></p>
<h3 id="RTP的架构如下："><a href="#RTP的架构如下：" class="headerlink" title="RTP的架构如下："></a>RTP的架构如下：</h3><ul>
<li>version｜P: 载荷是否为0填充｜X：是否有扩展头部 ｜ M：特殊帧标志</li>
<li><strong>CC「CSRC计数」：即有多少个源(媒体流被按照规则封装成一个个源)</strong><ul>
<li>一个多媒体文件中， 视频、音频、字幕···会来自不同的轨道 它们被封装成不同的源 然后在接收端混合输出</li>
</ul>
</li>
<li><strong>PT：载荷的编码特性「包括 编码算法 采样频率 承载通道」 用来指示接收端如何解码</strong></li>
<li><strong>序列号</strong> 每个数据分组有一个16位的序列号，每次自加1。类似TCP序列号， 用来检测<strong>是否丢包</strong> 序列号初始值是随机的 因为要防范对加密数据的攻击</li>
<li><strong>时间戳(时标)</strong> 32位 反映RTP数据包中第一个数据的 <strong>采样时刻</strong> 初始时间戳是随机选择的，而随后从单调且线性增加的时钟导出，以解决同步与抖动计算。 时间戳的单位不是固定的s&#x2F;ms 而是根据载荷类型确定</li>
</ul>
<blockquote>
<p>序列号与时间戳 是完全独立的</p>
<p>因为分组顺序 和 时间顺序 并不是线性相关的</p>
<p>「⚠️ 意思不只是 每个分组和分组到达的时间不是线性相关。 问题的关键在于 信号是数字化(离散)的，而时间戳会随着时间一直累加，而如果信号进入了空白帧，那么分组可以进入缓变状态(等到有数据了 再发送这个分组)」</p>
</blockquote>
<ul>
<li><strong>CSRC列表：接收端会对多个源的数据进行混合输出 以此列表作为参照</strong> </li>
<li>SSRC：标识多个源进行同步。 不是随机选择，每个RTP包里的每个同步源(需要同步播放)都有不同的SSRC标识</li>
</ul>
<h2 id="RTCP协议「Real-time-Transport-Control-Protocol」它和RTP是连体婴儿-不可分割"><a href="#RTCP协议「Real-time-Transport-Control-Protocol」它和RTP是连体婴儿-不可分割" class="headerlink" title="RTCP协议「Real-time Transport Control Protocol」它和RTP是连体婴儿 不可分割"></a>RTCP协议「Real-time Transport Control Protocol」它和RTP是连体婴儿 不可分割</h2><p><strong>不对实际音视频数据进行封装，是控制短分组协议</strong></p>
<h3 id="RTCP的任务："><a href="#RTCP的任务：" class="headerlink" title="RTCP的任务："></a>RTCP的任务：</h3><ul>
<li>服务质量监控和反馈<ul>
<li>接收端会多播发送丢包率、抖动···，发送端会多播发送 分组数、时间戳、绝对时间</li>
</ul>
</li>
<li>多源媒体之间的标识和同步</li>
</ul>
<h2 id="IP电话-IP-telephony-IP语音-Voice-over-IP-VoIP"><a href="#IP电话-IP-telephony-IP语音-Voice-over-IP-VoIP" class="headerlink" title="IP电话(IP telephony)&#x2F;IP语音(Voice over IP&#x2F; VoIP)"></a>IP电话(IP telephony)&#x2F;IP语音(Voice over IP&#x2F; VoIP)</h2><p>使用IP路由器取代传统电话交换机的动机很简单：💰</p>
<p>而且由于底层的网络设施共享，只要有了基本的设备就可以实现IP通话</p>
<p>IP电话的应用所面对的最大挑战就是 设计者希望IP电话能和已有的公共电话交换网络PSTN(Public Switched Telephone Network)兼容(向后兼容)，它们需要实现双向可通话。</p>
<h2 id="信令与VoIP标准"><a href="#信令与VoIP标准" class="headerlink" title="信令与VoIP标准"></a>信令与VoIP标准</h2><p>目前有两个组织为IP电话制定了标准：</p>
<p>国际电信联盟International Telecommunications Union 制定电话标准</p>
<p>因特网工程任务组Internet Engineering Task Force&#x2F; IETF 制定TCP&#x2F;IP标准</p>
<h3 id="IP电话的基础技术"><a href="#IP电话的基础技术" class="headerlink" title="IP电话的基础技术"></a>IP电话的基础技术</h3><ul>
<li>音频采用脉冲编码调制(PCM&#x2F; Pulse Code Modulation) 编码</li>
<li>数字化音频使用 RTP进行传输</li>
</ul>
<h3 id="IP电话的主要复杂之处在于-呼叫建立和呼叫管理-而我们把「建立和终止呼叫的过程-称为-信令-signaling-」"><a href="#IP电话的主要复杂之处在于-呼叫建立和呼叫管理-而我们把「建立和终止呼叫的过程-称为-信令-signaling-」" class="headerlink" title="IP电话的主要复杂之处在于 呼叫建立和呼叫管理  而我们把「建立和终止呼叫的过程 称为 信令(signaling)」"></a>IP电话的主要复杂之处在于 呼叫建立和呼叫管理  而我们把「建立和终止呼叫的过程 称为 信令(signaling)」</h3><p>电话中处理呼叫管理所采用的机制 就是<code>信令系统</code></p>
<p>为了和已有的电话系统兼容，我们需要和SS7(Signaling System 7)兼容 IETF剔除了 会话初启协议「Session Initiation Protocol，SIP」   </p>
<p><code>SDP（Session Description Protocol）是一个用来描述多媒体会话的应用层控制协议，它是一个基于文本的协议，用于会话建立过程中的媒体类型和编码方案的协商等</code></p>
<p><code>H.323 ITU定义的IP电话信令协议</code></p>
<h3 id="IP电话质量控制"><a href="#IP电话质量控制" class="headerlink" title="IP电话质量控制"></a>IP电话质量控制</h3><p>要求：</p>
<ul>
<li>使用光纤网络+特殊补偿算法 可以容忍最多30%的丢包率</li>
<li>电话通信端到端延时要求 &lt; 250ms。</li>
</ul>
<h2 id="SIP协议「Session-Initialization-Protocol」"><a href="#SIP协议「Session-Initialization-Protocol」" class="headerlink" title="SIP协议「Session Initialization Protocol」"></a>SIP协议「Session Initialization Protocol」</h2><p><code>用以一个或多个用户的会话建立、更改、管理、终止。不能单独完成多媒体通信的呼叫。</code></p>
<p>STP和SDP+RTP&#x2F;RTCP一起配合 组建完整的多媒体通信系统</p>
<h3 id="SIP功能："><a href="#SIP功能：" class="headerlink" title="SIP功能："></a>SIP功能：</h3><p>•用户定位：确定参加通信的终端用户位置。</p>
<p>•用户通信能力协商：确定通信的媒体类型和参 数。</p>
<p>•用户交互意愿：确定被叫加入通信的意愿。</p>
<p>•呼叫建立：建立主叫和被叫的会话参数。</p>
<p>•呼叫处理和控制：包括呼叫重定向、呼叫转移 ，终止呼叫等。</p>
<h3 id="SIP特点"><a href="#SIP特点" class="headerlink" title="SIP特点"></a>SIP特点</h3><ul>
<li>通过代理和重定向请求用户当前位置以支持用户移动性</li>
<li>独立于传输层协议，可以承载在不同的传输协议上 并扩展方便</li>
<li>只建立 更改 终止一个会话，和会话内容无关，这意味着其载体可以是任意的(甚至可以是视频和游戏)</li>
</ul>
<h3 id="SIP在网络中的主要实体："><a href="#SIP在网络中的主要实体：" class="headerlink" title="SIP在网络中的主要实体："></a>SIP在网络中的主要实体：</h3><ul>
<li><p>用户代理（ User Agent ）：用来发起或接收请求 的逻辑实体设备（如 IP 电话机、计算机、媒体网关等）。</p>
</li>
<li><p>用户代理客户 UAC （ User Agent Client ）：发 起请求的一方（如 SIP Phone ）；</p>
</li>
<li><p>用户代理服务器 UAS （ User Agent Server ）： 接收 请求，产生响应的一方。</p>
</li>
<li><p>定位 服务器（ Location Server ）：管理提供被 叫的位置数据库 , 如每个用户的 IP 地址集合（ IP 地址、电话号码、 email 地址）、用户订购业务 、用户偏好等，在呼叫过程中提供被叫用户的位 置信息</p>
</li>
<li><p>支持服务器（ Support Server ）：代理服务器、 重定向服务器、注册服务器，实际呼叫过程扩展 应用。 </p>
</li>
<li><p>代理服务器：作为一个实体转发用户代理客户 UAC 的请求至被叫（用户代理服务器 UAS ）或 一个代理服务器。</p>
</li>
<li><p>注册服务器：接收注册请求 , 将注册请求中的地 址映射关系更新到定位数据库中，并负责验证注 册请求和确保底层数据库一致性。</p>
</li>
<li><p>重定向服务器：为所收到的请求返回一个或多个 新的地址，用户代理客户 UAC 再向这些新的地址 发起请求。重定向服务器并不接收呼叫或拒绝呼 叫，主要完成路由重新定向，与注册过程配合可 以支持 SIP 终端的移动性</p>
</li>
</ul>
<h3 id="SIP协议消息类型"><a href="#SIP协议消息类型" class="headerlink" title="SIP协议消息类型"></a>SIP协议消息类型</h3><p>SIP分为请求和响应</p>
<hr>
<blockquote>
<p> <strong>试列举3-5种网络中可能产生的时延，什么是等时时延或非等时时延？</strong></p>
<p> 可能的时延有 信号传播时延、信号处理时延、路由器存储转发时延、丢包重传时延、播放时延等。</p>
<p> 等时时延&amp;非等时时延 ： </p>
<p> 以信号传输为例 就是信号总在一段固定时间后到达，这其中的时延称为等时时延</p>
<p> 如果每次传输信号会在不同的时间后到达，就将这段时延称为非等时时延</p>
</blockquote>
<blockquote>
<p><strong>在因特网丢包、乱序的状况下，分析比较对非实时email和实时IP电话所产生的影响？</strong></p>
<p>对于E-Mail来说，如果不使用可靠的传输协议，接收方很难收到正确、完整的信息。但由于其非实时性，借助SMTP等可靠传输协议实现差错检测和报文重传，客户发送的E-Mail几乎总能正确、完整的到达接收方处。</p>
<p>对于实时IP电话来说，由于音视频信号在网络上传输的特点，网络丢包、乱序导致网络抖动，使得还原出的信号产生失真。如果借助可靠传输，由于网络层丢包、乱序的状况，传输会不可避免的花费时间，会丧失实时性。如果实时传输并引入超时重传，在接收端已经收到并提取信息之后再把错误或丢失的数据包插播进来是毫无意义的。因此智能设计等时延、无抖动的网络结构 或者 设计补偿抖动的协议实现平滑重放。</p>
</blockquote>
<blockquote>
<p><strong>简述RTP协议中定义序列号、时标有什么作用？如何理解两者具有独立性。</strong></p>
<p>序列号 类似TCP序列号，用来检测是否丢包。</p>
<p>时间戳(时标) 反映RTP数据包中第一个数据的采样时刻，初始时间戳随机选择，随后则从单调、线性增加的时钟导出，以解决同步与抖动计算。</p>
<p>序列号所对应的是 分组顺序，时间戳对应的则是 时间顺序。两者之间不一定是线性相关的，因为信号的特点可能使得在一段时间内并无信号(数据帧)，或者出现可变长度视频编码(图像缓变)帧，而在这段时间内时间戳会一刻不停的累加。</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Computer-Network/" class="print-no-link">#Computer Network</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>互联网原理</div>
      <div>https://www.mementos.top/1976/04/01/互联网原理/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Natsumi</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>1976年4月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/1976/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/" title="计算机技术杂谈">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计算机技术杂谈</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>powered by Hexo</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/DynamicRibbon.min.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
